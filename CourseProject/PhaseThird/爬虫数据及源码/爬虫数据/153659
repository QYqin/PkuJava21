
Recno:: 0
URL:: http://bbs.csdn.net/topics/391876796

ParseText::
如果你希望开源未来能更好，那么欢迎来帮助开源“进步”-CSDN论坛-CSDN.NET-中国最大的IT技术社区 首页 精选版块 移动开发 iOS Android Qt WP 云计算 IaaS Pass/SaaS 分布式计算/Hadoop Java技术 Java SE Java Web 开发 Java EE Java其他相关 .NET技术 .NET Framework C# .NET分析与设计 ASP .NET VB .NET Web开发 PHP JavaScript ASP HTML(CSS) HTML5 Apache 开发语言/框架 Delphi VC/MFC VB C/C++ C++ Builder 其他开发语言 数据库开发 MS-SQL Server Oracle PowerBuilder Informatica 其他数据库开发 硬件/嵌入式开发 嵌入开发(WinCE) 驱动开发/核心开发 硬件设计 单片机/工控 汇编语言 VxWorks开发 Linux/Unix社区 系统维护与使用区 应用程序开发区 内核源代码研究区 驱动程序开发区 CPU和硬件区 论坛帮助 论坛牛人 论坛地图 专家问答 << >> CSDN > CSDN论坛 > 站务专区 > 活动专区 返回列表 管理菜单 置顶 取消推荐 锁定 移动 编辑 删除 帖子加分 取消高亮 结帖 发帖 回复 关注 CSDN [推荐] 如果你希望开源未来能更好，那么欢迎来帮助开源“进步” [问题点数：300分] 快速回复 只显示楼主 关注帖子 [推荐] 如果你希望开源未来能更好，那么欢迎来帮助开源“进步” [问题点数：300分] 不显示删除回复 显示所有回复 显示星级回复 显示得分回复 只显示楼主 收藏 取消关注 关注 CSDN CSDN 本版等级： 本版专家分：18565 结帖率：95.7% 楼主 发表于： 2015-12-15 10:25:02 开源软件 csdn 问卷调查 每一个程序员的内心，都渴望着自己的代码运行在世界各处，自己的名字在开源界叱咤风云，然而你是否觉得自己离开源界太远呢？No，立即参与我们的调查，告诉我们你如何参与开源，我们便能告诉你中国开源的完整现状。 你的一小步， 整个中国开源的一大步。参与我们的调研，更有机会抽取Apache免费T-shirt以及CSDN精美礼品，一年一次，还等什么！   CSDN与开源社携手推出“2015年中国开源社区参与调查报告”问卷，旨在对中国开源社区、开源生态、开源开发者做一次全面性地摸底调查。   本次调查的受访对象将覆盖开发者、社区成员、贡献者、学生、政府企业管理人员，问卷内容涵盖四个部分，包括：个人信息、工作状况、开源社区以及开发者技术调查，涉及开源社区的各种话题。比如，你或你的公司，会因为使用开源操作系统或开源软件，产生不安全感吗？你觉得“社区“与”代码”，谁比较重要？其中，也包括了许多具有争议性的话题，比如，开源软件是否就应该免费？开源软件是否可以有商业模式……等。   通过大约50项问题的统计调查与分析，我们希望能够还原出当前中国开源社区的真实现状，从而为开源的后来人提供权威的参考。   而身为参与开源社区的一份子，你的发声和意见将成为一块重要的拼图，拼凑构筑出中国开源社区的真实样貌。我们想看到你的支持，所以诚挚邀请你参加我们的问卷调查（ https://www.wenjuan.com/s/ZB7rIr/ ）。 更多 分享到： 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 回复次数：23 取消关注 关注 dear_Alice_moon dear_Alice_moon 本版等级： 本版专家分：54 结帖率：69.57% #1 得分：0 回复于： 2015-12-15 10:46:04 嗯，感觉不错，支持下，马上 去填写问卷调查。 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 testcs_dn testcs_dn 本版等级： 本版专家分：4 结帖率：88.24% #2 得分：0 回复于： 2015-12-15 11:12:02 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 u011098115 u011098115 本版等级： 本版专家分：0 结帖率：100% #3 得分：0 回复于： 2015-12-15 11:53:58 有奖调查  对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 sushengmiyan sushengmiyan 本版等级： 本版专家分：6 结帖率：100% #4 得分：0 回复于： 2015-12-15 14:25:44 鼓掌鼓掌。。。 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 enpterexpress enpterexpress 本版等级： 本版专家分：368 结帖率：83.44% 红花 2015年8月 扩充话题大版内专家分月排行榜第一 黄花 2015年10月 扩充话题大版内专家分月排行榜第二 2015年9月 扩充话题大版内专家分月排行榜第二 #5 得分：0 回复于： 2015-12-15 16:13:45 可以查看我的博客，如果有人给我推荐的话 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 wangyaninglm wangyaninglm 本版等级： 本版专家分：12 结帖率：97.52% #6 得分：0 回复于： 2015-12-16 09:21:11 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 zilin110 zilin110 本版等级： 本版专家分：8 结帖率：100% #7 得分：0 回复于： 2015-12-16 10:56:15 为毛没人 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 gotopause gotopause 本版等级： 本版专家分：0 结帖率：100% #8 得分：0 回复于： 2015-12-16 13:30:07 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 c602273091 c602273091 本版等级： 本版专家分：0 结帖率：0% #9 得分：0 回复于： 2015-12-16 14:00:41 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理

Recno:: 1
URL:: http://bbs.csdn.net/topics/391880332

ParseText::
深圳小伙伴的福利来啦，到场就送礼品哦！-CSDN论坛-CSDN.NET-中国最大的IT技术社区 首页 精选版块 移动开发 iOS Android Qt WP 云计算 IaaS Pass/SaaS 分布式计算/Hadoop Java技术 Java SE Java Web 开发 Java EE Java其他相关 .NET技术 .NET Framework C# .NET分析与设计 ASP .NET VB .NET Web开发 PHP JavaScript ASP HTML(CSS) HTML5 Apache 开发语言/框架 Delphi VC/MFC VB C/C++ C++ Builder 其他开发语言 数据库开发 MS-SQL Server Oracle PowerBuilder Informatica 其他数据库开发 硬件/嵌入式开发 嵌入开发(WinCE) 驱动开发/核心开发 硬件设计 单片机/工控 汇编语言 VxWorks开发 Linux/Unix社区 系统维护与使用区 应用程序开发区 内核源代码研究区 驱动程序开发区 CPU和硬件区 论坛帮助 论坛牛人 论坛地图 专家问答 << >> CSDN > CSDN论坛 > 站务专区 > 活动专区 返回列表 管理菜单 取消置顶 置顶 取消推荐 锁定 移动 编辑 删除 帖子加分 帖子高亮 结帖 发帖 回复 关注 chinese915 [置顶] [推荐] 深圳小伙伴的福利来啦，到场就送礼品哦！ [问题点数：40分] 快速回复 只显示楼主 关注帖子 [置顶] [推荐] 深圳小伙伴的福利来啦，到场就送礼品哦！ [问题点数：40分] 不显示删除回复 显示所有回复 显示星级回复 显示得分回复 只显示楼主 收藏 取消关注 关注 chinese915 chinese915 本版等级： 本版专家分：0 结帖率：97.73% 楼主 发表于： 2015-12-22 10:32:58 bluemix 福利 深圳 先给这个活动上一段正经八百的介绍，能领悟多少就看个人的智商了： Bluemix——在这个承载了IBM未来的超级计算平台，终于在中国落了地。2015年10月14日，IBM宣布携手中最大的中立IDC服务提供商世纪互联将Bluemix正式引中国。根据该协议，IBM将提供Bluemix相关技术，世纪互联提供Bluemix运行的基础架构以及端到端运营服务。 籍此IBM联合CSDN共同举办Bluemix开发者锦标赛。此次大赛，IBM为开发者提供了优先体验Bluemix的机会，使开发者可以在明年爆发的市场中抢得先机。我们广泛召集互联网、移动领域的开发者们，大家在展示梦想的舞台上角逐大奖、共同竞技。本次大赛参赛用户1200余人，征集应用325个。我们特邀本次大赛获奖代表团体、IBM技术专家与大家一同分享使用Bluemix的开发经验。 没明白的往这看： IBM的云平台Bluemix正式落地中国，CSDN&IBM共同举办了一场开发者大赛，现在大赛完成了，我们要跟小伙伴们分享一下这次大赛里牛X的作品，另外还邀请了IBM的专家给大家讲解Bluemix的技术。 说重点是么？ 免费午餐+阳光普照（到场就有奖），尤其是软件园的小伙伴们，中午参加完活动还不影响下午上班（14:30活动结束） 酱紫，快来报名吧！快点@你软件园的小伙伴来领福利啦！ 重要的事说三遍： 一定要先报名哦，要不木得午餐，木得奖品！ 一定要先报名哦，要不木得午餐，木得奖品！ 一定要先报名哦，要不木得午餐，木得奖品！ 一定要先报名哦，要不木得午餐，木得奖品！ 报名地址： http://huiyi.csdn.net/activity/product/goods_list?project_id=2674 活动日程： 12:00-12:30 签到 12:30-13:00 自由交流、用餐 13:00-13:05 IBM嘉宾黄英杰致辞 13:05-13:15 获奖代表团队作品分享 Demo（无人船） 13:15-14:00 获奖代表团队作品分享 3 Demos（周江南） 14:00-14:40 现场互动（QA）+抽奖 14:40-14:45 活动结束致辞+奖品发布 新年福利：参加本次活动的用户，现场均可获得CSDN精美礼品一份。 更多 分享到： 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 回复次数：36 取消关注 关注 u010850027 u010850027 本版等级： 本版专家分：3 结帖率：55.56% #1 得分：0 回复于： 2015-12-22 10:51:34 不在深圳  对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 chinese915 chinese915 本版等级： 本版专家分：0 结帖率：97.73% #2 得分：0 回复于： 2015-12-22 11:00:14 引用 1 楼 u010850027 的回复: 不在深圳  可以呼叫深圳的小伙伴 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 sushengmiyan sushengmiyan 本版等级： 本版专家分：6 结帖率：100% #3 得分：0 回复于： 2015-12-22 11:31:21 深圳深圳。 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 testcs_dn testcs_dn 本版等级： 本版专家分：4 结帖率：88.24% #4 得分：0 回复于： 2015-12-22 11:31:29 一定要先报名哦，要不木得午餐，木得奖品！ 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 dear_Alice_moon dear_Alice_moon 本版等级： 本版专家分：54 结帖率：69.57% #5 得分：0 回复于： 2015-12-22 12:25:35 表示没有在深圳，哈哈。 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 SunnyYoona SunnyYoona 本版等级： 本版专家分：1 结帖率：100% #6 得分：0 回复于： 2015-12-22 12:53:58 为啥要在深圳。。。。。。。。。。。。。。。 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 xiesq5112 xiesq5112 本版等级： 本版专家分：2 结帖率：78.57% #7 得分：0 回复于： 2015-12-22 14:07:36 周二呀，  要上班呀 我在车公庙我怎么去。 礼品寄给我吧！谢谢了。 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 chinese915 chinese915 本版等级： 本版专家分：0 结帖率：97.73% #8 得分：0 回复于： 2015-12-22 14:54:18 引用 6 楼 SunnyYoona 的回复: 为啥要在深圳。。。。。。。。。。。。。。。 下一站去成都，咋样？ 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 取消关注 关注 chinese915 chinese915 本版等级： 本版专家分：0 结帖率：97.73% #9 得分：0 回复于： 2015-12-22 14:54:57 引用 5 楼 dear_Alice_moon 的回复: 表示没有在深圳，哈哈。 呼叫在深圳的小伙伴啊 对我有用[0] 丢个板砖[0] 引用 | 举报 | 编辑 删除 管理 <

Recno:: 2
URL:: http://blog.csdn.net/atlassian2013/article/details/50291561

ParseText::
认识 Atlassian Datacenter 产品 - JIRA、Confluence中文官方技术博客 - 博客频道 - CSDN.NET JIRA、Confluence中文官方技术博客 分享JIRA、Confluence、Bamboo等Atlassian产品的安装部署及使用技巧，营造全面高效的学习交流空间。上atlassian.csdn.net下载享用,咨询QQ：2714137330 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 认识 Atlassian Datacenter 产品 2015-12-14 10:51 28046人阅读 评论 (1) 收藏 举报 分类： 最新消息 （6） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 认识 Atlassian Datacenter 产品 云端 原本就是群集化的架构，Atlassian 系列产品，应用的开发团队相当广范且行之有年，但是将应用程序作为节点（比如Jira,confluence,bamboo…等應用程式）然后群集化的运维团队却是少之又少，希望以基础架构的角度切入，由以下列举之细目引导大家了解 Altassian DataCenter这个 群集化的方案，进而盘点要建置DataCenter，到底需要哪些第三方技术才能够完整这样的架构： 群集化不可或缺的虚拟环境 (Virtualization)： 以一个节点为单位，虚拟节点当然要比实体节点好调度，而且群集化后的节点群，要在实体机之间迁移，没有俱备虚拟环境要如何轻易的完成这样的任务。要发挥DataCeneter所带来的好处，虚拟环境是必备的条件之一，且并不需要在特定的虚拟产品下运行。 如下知名的虚拟産品所建构的虚拟环境都可以 双机热备 (Hight Avaliable) 针对负载平衡，也许客户会列举出运行中的 jira 负载还好，不需要用到负载平衡。但是双机热备HA，就不单单只是在性能或是备援的考量，反而是应用面。怎么说呢？相信在应用程序或是插件的升级需求大家都有，但要在哪个节点测试呢？为了测试多买一套应用程序吗？就算预算充裕，那测试完毕确认是可以满足开发人员需求，接下来要如何在不干扰下把在线人员整个移转过来？还是就在线直接更新。在线直接更新是大部份目前的作法，所产的问题状况百出，有时还回复不了原始状态，轻则中断开发人员的应用，重则数据遗失。 也因此，有了 DataCenter 的应用程序再加上 Pacemaker 所建置完善的双机热备，那么整个应用程序的群集或是插件的应用就拥有了顺畅的演化环境，相关的升级就可以放手去进行，前端开发团队所提出的需求也能快速反应。 (pacemaker,corosync) 双机热备首选技朮 全新建置的节点，在这里建议大家采用 CentOS or RedHat 7 也就是 Linux 核心是 3.10，pacemaker 建置过程有稍稍较之前 Redhat or CentOS 5~6 较依赖 cli（command line）但整个建置完善后，不管是节点之间服务切换的速度，或是一些故障分析，都较能经得起考验。 当然维持原有的 Linux HA 旧环境，或是操作系统版本有需要让其他软件依赖的考量而无法升级，DataCenter 的架构仍然是可以完成的。只是在多节点的布署，操作系统最好选择以 Linux 核心为 3.10 来担任。 以下两张分别为 pacemaker 的堆栈及内构图示： 在 Pacemaker 下完整建构的双机热备 HA，在以下三种情境都是可以正常运作的。 网络文件系统(NFS)及存储装置(DRBD) Home-shared 是 DataCenter 的一个关键，原本 Atlassian 系列的应用程序都有一个 Local Home，透过 NFS 这个网络文件系统让同一种 AP 多个节点，供享同一个 home directory。如此协同运作，就可以让单一个节点所作的设置(比如插件升级或是安装)，群集里的其他成员也就跟着完成。 NFS 的供应端可以是任何云存储的分布式文件系统技术，这里用 CEPH 为示例来作说明，前端是藉由 NFS 分享出来的网络文件系统，后端是由三个 osd 节点组合出来的 RAW device，接下来是一个有趣的组合，我把监控 mon 和元数据 msd 原来两个节点组合为一个节点总共两组，这样就可以为 NFS-server 建置一个 HA 也就是提供一个虚拟 IP 给 Atlassian AP 作挂载，这样 share home 就有了热备援啦！在这里的 Pacemake 建置 HA 主要是为了 NFS-server 服务，mon 及 msd 的组合节点原本就有热备援的机制存在，不需要依赖 Packmaker 的 HA。 请以下面图型来想像一下我所描述的安排： 双机热备一开始我们都只考虑到应用程序端，现在我们来看看数据库如何跟双机热备集成，一开始当然想到数据库的存储位置，DRBD 跟 Pacemaker 整合的非常严密，以它来作为数据库的存储位置再也理想不过了，这个装置在两个节点之间以块层级随时同步着，但尽有一方会被挂载着，因此这样的构架方案不适合作数据库的负载均衡，只合适数据库的双机热备，也就是HA。 DRBD 只提供到 Raw Device，再上层的文件系统就由操作系统接手了，接下来的挂载再由 Pacemaker 安排，DRBD 模块负责着三个访问（ Raw Driver ， Disk Driver ， NIC Driver ）。 这里写图片描述 DRBD 算是很忙碌的一个模块， 因为是块层级的传输 ，所以虽然负责许多面向，但效率不减（访问 DRBD 官网请连接 http://drbd.linbit.com/ 再次提醒： 　DRBD的存储构架，对群集而言只适合集成双机热备构架也就是HA， 不合适负载均衡的安排，这点请注意 。 负载均衡 (LoadBalance) HAproxy 是个非常不错的负载均衡舵手，在这个角色下可以用简单的参数来调配，可以作到让出来面对客户端提出需求的 web-service 群，是用什么样的模式来运作。比如 roundrobin 或 static-rr ，甚至可以分头顾及到下层的数据库是不是采用 leastconn 模式。 当然 HAproxy 这么重要的网关怎么可以只由单一的节点来担任，再建一组 HA 吗？一个很有趣的安排，把 HAproxy 往群里面配，不管是由云存储的群（sql）或是云计算的群（html）都可以，只要把群里每个成员上的 HAproxy 服务全部启动，参数调配好后就由 Pacemaker 所供应出来的虚拟IP来面对客户端的需求访问，这样 HAproxy 就有热备援的机制啦！ 可以参考如下的图示想像一下这个有趣的安排。 roundrobin: 平均轮询在各个节点上，可调整权重让不同等级的服务器分配不同的负载。 static-rr: 平输询在各个节点上，但权重调整无效。不管各个服务器规格如何，按总节点数平圴轮询。 leastconn: 適合sessions較長的服務端，比如 LDAP，SQL….等，權重調整後會較緩慢生效。 first: 该算法的目的是要始终使用最小服务器的数量。 source: 这确保了同一客户端地址将始终达到相同的服务器端。 url: 同 source 差别在用 url 来辨别客户端。 url_arm: 同 url 差别在有参数，一般是服务器对服务器的访问。 hdr: 这一般指的是可识别的用户标头，也就是同一个用户帐号登入不同客户端作访问服务器，都是由同一台服务器来服务。 rdp-cookie: 如同 hdr 但以 cookie 存在与否来判别是否改变访问的主机。 设置步骤 (DataCenter Setup) 以下为 Atlassian 原厂 DataCenter for jira 的设置步骤 首先把数据库跟应用程序（这里指的是 jira）分离。 确认原本的 jira 版本是在 6.3 以上（含），如果版本条件不满足，请先进行升级或是改版计划。 将 Loadblance 的节点安排好，这篇文章建议的是 HAproxy 服务器。 把 Local Home Directory 分享出来，作为 DataCenter 最重要的 Share Home 的一个位置。 加入第二个应用程序节点，把数据库设定好，NFS-client 设定好访问 Shared Home。 将 HAproxy 上层之AP设定为 roundrobin 模式，将下层数据库设定为 lessconn 模式，然后全部串接起来，由 Pacemaker 建置好的虚拟 IP，准备接受客户端的访问。 效能监控工具 (Performance Monitor) 在建置 DataCentor 的整个过程还算繁琐，不只步骤繁多，构架多样化，但整个模型是一致的，会建构 jira 应用程序的 DataCenter 也就会建构其他应用程序的 DataCenter，整个过程中，在这里建议随时观测虛拟环境的效能监控工具，一边进行建置一边进行诊断，才不㑹进行了大部份的建构步骤才开始回头查问题的原因，那将㑹增加问题分析的困难度。 如下图标示例，在我们浏览 jiraIP 我们可以知道 ha1 和 ha2 彼此之间并非 roundrobin 关系 在整个 DataCenter 建置完成后开始上线，运行过程中要注意 CPU 负戴不要持续攀升在 80% 以上， 持续攀升需要调优或是硬件升级 ，瞬间是不碍事的。 如下以 VMware 性能监控器显示只有瞬间攀升。 本文作者：James XU（CSDN资深技术顾问）未经允许不得转载！ 软件商城： http://mall.csdn.net/tool 热门活动： Atlassian 购软件赠技术服务限时特惠火热进行中！ 上一篇 JIRA Software Data Center 企业级解决方案 顶 0 踩 0 我的同类文章 最新消息 （6） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 u012046931 访问： 129228次 积分： 1418 等级： 积分：1418 排名： 第17423名 原创： 14篇 转载： 33篇 译文： 5篇 评论： 44条 文章搜索 文章分类 最新消息 (7) Atlassian用户组活动分享 (6) JIRA (13) JIRA的安装及部署 (7) JIRA的使用 (11) JIRA案例 (1) Confluence教程 (10) Bamboo教程 (5) 项目管理 (0) datecenter (1) 文章存档 2015年12月 (3) 2014年04月 (1) 2014年03月 (4) 2014年02月 (6) 2013年12月 (6) 2013年11月 (19) 2013年10月 (3) 2013年09月 (10) 阅读排行 认识 Atlassian Datacenter 产品 (27165) “我们都用JIRA” 视频征集大赛火热开启！（3月5日—4月30日） (9554) 【推荐】JIRA入门教程，适合新手学习。 (5511) Confluence与Jira整合之统一用户管理 (5189) jira二次开发经验分享 (4840) Atlassian Confluence安装以及如何更改数据库 (4670) 为JIRA6.0.2安装中文语言包 (4304) 因你而变——JIRA使用心得 (3821) Bamboo入门教程及基础操作 (3621) 【 Confluence教程】二、在 Windows 下安装 Confluence (3561) 评论排行 “我们都用JIRA” 视频征集大赛火热开启！（3月5日—4月30日） (17) jira二次开发经验分享 (6) 【推荐】JIRA入门教程，适合新手学习。 (4) linux下安装jira (2) JIRA中的并联审批流程定制 (2) JIRA带来的管理思路 (2) 如何设置JIRA在创建问题时将当前经办人指定为报告人 (2) 记一次服务器迁移，包括jira、svn (2) Jira插件开发中的附件上传 (1) 认识 Atlassian Datacenter 产品 (1) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 认识 Atlassian Datacenter 产品 zhangao0086 : 上家公司用的 Atlassian 产品，有 JIRA、Stash、Confluence，确实很好用，... Atlassian Confluence安装以及如何更改数据库 peng1234gn : 手动备份数据库为xml的zip压缩包，如xmlexport-20111213-103142-2.zi... Jira插件开发中的附件上传 yieryi_ : 您好： 最近在做jira插件开发，采用eclipse，jira5.2.4，tomcat7.x，... jira二次开发经验分享 yieryi_ : 您好： 最近在做jira插件开发，采用eclipse，jira5.2.4，tomcat7.x，... 如何设置JIRA在创建问题时将当前经办人指定为报告人 thefly1988 : 如果创建问题时指定了经办人，那么就该分配给经办人，上面那样设置以后只能给报告人而不能指定特定的人了。... 记一次服务器迁移，包括jira、svn ybb896 : 不用一个项目一个项目的导入,直接全部导入就行了.一些附件拷贝过来就行了. 【推荐】JIRA入门教程，适合新手学习。 mengge : 合集在这里：http://download.csdn.net/detail/mengge/83999... 【 Confluence教程】一、开始你的 Confluence 之旅 sinat_15258199 : 请问一下博主，confluence中的用户信息保存在数据库中的什么表中？是在cwd_user中吗？它... 【推荐】JIRA入门教程，适合新手学习。 hmh2050 : 版本太低，写得太简单了 JIRA中的并联审批流程定制 fengmeimei_009 : 怎么脚本执行不了呢，CustomFieldManager customFieldManager = ...

Recno:: 3
URL:: http://blog.csdn.net/code/experts.html

ParseText::
编程语言博客专家 - 博客频道 - CSDN.NET 首页 博客专栏 博乐推荐 博客专家 热门文章 排行榜 我的博客 帮助 订阅 全部分类 移动开发 Web前端 架构设计 编程语言 互联网 数据库 系统运维 云计算 研发管理 特约专家 行业名家 名誉专家 荣誉专家 杨中科 刘建文 刘锋 齐飞 陈伟东 段宝立 牟勇 尧庆宇 胡传照 沈东良 更多 按上周发表原创(翻译)文章数量排序 编程语言专家 王书博 高焕杰 马海旭 马伟青 王辰龙 胡旭 李灵晖 李朋伟 胡耀武 周兆熊 雷文 邓晓 谢浩鹏 蔡军生 贾志刚 李强 张亮 左飞 刘毅 杨昌玉 兰亮 贺利坚 朱滋洲 任正光 苏华平 孔凡斌 王瑾华 朱金灿 王学强 丁亮 周岳 孔德芳 张龙 毛子兵 李尚林 张大伟 朱忠涛 刘勇 陈明 武龙飞 黄雪峰 王建敏 朱吉芳 罗中朋 张翔 王晓华 金旭亮 潘李亮 张庆 徐建明 马礼伟 史宁宁 魏红生 刘洪峰 高峰 朱继山 闫二康 谢华亮 王绍全 尤建波 帅宏军 李巍 陈士通 黄志斌 李天平 张云开 邓尚俊 王嘉 朱伟 孟康健 黄鸣 郭峰 黄灯桥 花纯春 方兴 李力 赖勇浩 庄晓立 赵开勇 汪立 郭勇生 张健滢 罗家振 陈锐 向青风 范晓超 陈超 梁宏涛 金庆 刘洪建 韩艳生 叶现一 周金桥 马如林 吴熹 王明照 李建功 李伟健 毛泽发 段喜龙 陈学明 宋海军 白乔 唐刘 何海涛 周天佐 罗莊 魏建军 付义方 高庆地 姚軍 邓学彬 李刚 费晓行 童磊 宋志朋 李民录 吴徐平 刘畅 吴阳平 娄振林 杨华 刘中正 班志华 张睿卿 陈新贤 徐杰 李守宏 吴帅 顾伟 刘克华 张路斌 胡春旭 杨友山 原林 段聪 田海德 周磊 高爽 曹胜欢 陈建秋 马智 伊海波 何一娜 高剑楠 陈伟琪 陈龙 魏兰 杨虹昌 刘水镜 左丞 罗伟富 郭晓湉 王昌平 何昊 邹晓艺 黄丹华 梁健辉 毛星云 雷霄骅 王成委 张鹏 滕伟 吴操 江文聪 刘志志 张二青 秦雄 李渊 蔡坤承 陈国林 胡峻铭 金少辉 王悦豪 尹开心 任富飞 张圆 金圣韬 冯乐乐 周超强 陈福林 戴辉 黄劲松 陈坚强 王维 张雁冰 马博浩 张龙 黎小华 刘硕 曹鹏 程乐超 陈龙飞 卢扬 王建坤 曹广界 饶齐 周树嘉 林欢 姜伟 林炳文 朱红姝雨 石海华 刘川 显示全部专家 最新文章 Linux中在主机上实现对备机上目录及文件的操作的C代码实现 编写程序，完成在主机上实现对备机上目录及文件的操作。例如，主机为A，备机为B，要求编写的程序运行在A机上，该程序实现在B机上创建文件目录及拷贝文件的操作。... zhouzxi 31分钟前 阅读(4) 评论(0) 从头认识java-15.1 填充容器（2） 接着上一章节，我们继续介绍填充容器。这一章节我们结束另一种填充容器的方式：addAll例子：package com.ray.ch15; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedHashSet; public class Test { public static void main(... java raylee2007 1小时前 阅读(71) 评论(0) HP 1522NF一体机网打怎么弄啊？打印机的IP怎么设置。 推荐本产品使用此网络配置模式。1. 在打开产品之前，先将网络电缆插入产品网络端口，以将产品直接连接到网络。2. 打开产品电源，等待 2 分钟，然后使用控制面板打印配置页。注： 确保配置页上列出 IP 地址，然后继续执行下一步。如果配置页上未列出 IP 地址，请重新打印配置页。3. 将产品 CD 插入计算机。如果软件安装程序未启动，请浏览到 CD 上的 hpsetup.exe 文件，然后双击该文件。... 惠普 打印机 1522NF testcs_dn 1小时前 阅读(10) 评论(0) ftp530 没有权限 ftp 530 没有权限... ftp 530 没有权限 qing_gee 1小时前 阅读(803) 评论(0) 用ImDisk在Windows 10中创建内存虚拟盘 从win 7升级到win 10后，运行ramdisk1.1简体绿色版无法创建内存虚拟盘。Bing了一下，网友们一般用Primo Ramdisk　或　ImDisk。由于ImDisk是开源的，所以选择了它。... Windows windows10 ImDisk 内存虚拟盘 虚拟盘 Purpleendurer 2小时前 阅读(125) 评论(1) There is no getter for property named '*' in 'class java.lang.String'之源码分析 There is no getter for property named '*' in 'class java.lang.String'，此错误之所以出现，是因为mybatis在对parameterType="String"的sql语句做了限制，假如你使用这样的条件判断时，就会出现该错误，不过今天我们来刨根问底一下。... getter property class string sql qing_gee 3小时前 阅读(686) 评论(3) Java中字节与对象之间的转换 最近公司里面用到了消息队列，而正如我们知道的是消息队列之间的是通过二进制形式的，下面就分享一下java中字节与对

Recno:: 4
URL:: http://blog.csdn.net/csfreebird/article/details/49330645

ParseText::
使用mongodb shard cluster构建高可用的系统架构 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 使用mongodb shard cluster构建高可用的系统架构 标签： mongodb 2015-10-22 11:10 4643人阅读 评论 (4) 收藏 举报 分类： MongoDB Sharding （3） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 在一个产品环境下，高可用是必须达到的目标。下图是mongodb 3.0之后的shard cluster架构图。 几个要点 1. mongos实现了mongod一样的服务接口，监听相同的27017端口，mongos接到访问请求后，会根据sharding算法，将请求转发到对应的shard中，然后会将各个shard返回的结果合并后返回给请求方 其实还有其他方法，比如通过LVS将多个mongos放在一个域名下，利用LVS的负载均衡。然后所有web server只通过这个域名发出查询/写入等请求。不过这个方法需要额外的LVS支持。一般情况下，1对1方案就已经够用 2. 部署程序的时候，请一同部署mongos。比如一个web服务器上有一个web server和一个mongos。web server总是访问本地运行的mongos，不需要指定一堆IP地址和端口号，那是访问replica set的方式。shard cluster模式下，反而简单了。 3. config server本质上是用mongod组成replica set，记录元数据。config server可以用三台低配的服务器，但是要独立，不要和shard, mongos放在一台服务器上。 上一篇 关闭transparent_hugepage 下一篇 Clojure语言十四 常用宏 顶 1 踩 0 我的同类文章 MongoDB Sharding （3） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247661次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 5
URL:: http://blog.csdn.net/csfreebird/article/details/49444467

ParseText::
Clojure语言十四 常用宏 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 Clojure语言十四 常用宏 标签： clojure 2015-10-27 10:02 559人阅读 评论 (0) 收藏 举报 分类： Clojure （33） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 常用宏 infix宏解析人的四则运算书写格式并执行 (defmacro infix "Use this macro when you pine for the notation of your childhood" [infixed] (list (second infixed) (first infixed) (last infixed))) 这么用： (infix (1 + 1)) ; => 2 用macroexpand检查返回的list 上面的例子中，其实经过了去除最后一个symbol，然后再对余下的list求值的过程。 (+ 1 2 10) -> (+ 1 2) -> 3 要想知道最后求值结果出来前的list，可以使用macroexpand. 注意要配合使用' 表示不要求值。 user=> (macroexpand '(ignore-last-operand (+ 1 2 10))) (+ 1 2) 这样就可以显示宏返回的list，而不是求值。 -> 宏改变从右到左的阅读方式 (defn read-resource "Read a resource into a string" [path] (read-string (slurp (clojure.java.io/resource path)))) 这个函数运算的时候会先从最右边的（因为也是最里面）的list开始求值，path -> (clojure...) -> (slurp...) -> (read-string ...), 然后往外层层求值。通过->宏可以将最先求值的放在最上面，写成这样。 (defn read-resource [path] (-> path clojure.java.io/resource slurp read-string)) 每个人有不同的偏好，有些人还是会这样用，为了减少括号的数目和符合自己从左到右或者从上到下的阅读习惯。 binding宏 binding宏用来创建线程专属的变量，在多线程中很常用。 user=> (def ^:dynamic x 1) user=> (def ^:dynamic y 1) user=> (+ x y) 2 user=> (binding [x 2 y 3] (+ x y)) 5 user=> (+ x y) 2 when宏 可以接受一堆参数，如果条件为真，这些参数都依次被求值，返回最后一个求值的结果。when的实现是用(if 和 (do。 (macroexpand '(when boolean-expression expression-1 expression-2 expression-3)) ; => (if boolean-expression (do expression-1 expression-2 expression-3)) 上一篇 使用mongodb shard cluster构建高可用的系统架构 下一篇 Clojure语言十五 quote & unquote 顶 0 踩 0 我的同类文章 Clojure （33） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247664次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 6
URL:: http://blog.csdn.net/csfreebird/article/details/49449125

ParseText::
Clojure语言十五 quote & unquote - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 Clojure语言十五 quote & unquote 标签： clojure 2015-10-27 15:45 629人阅读 评论 (0) 收藏 举报 分类： Clojure （33） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 quote (quote ...) 或者用 ' 来阻止list/symbol被求值 比如： > (quote a) a > 'b b unquote ~刚好相反，用来将quote的symbol被取消quote状态，恢复求值的功能 > ~'a ~@411CF0 a > ~(quote a) ~@411CF0 a quote unquoted symbol quote在前，不会抵消unquote的效果，而是把unquoted symbol一起保留不求值 > (quote ~a) ~a 上面~a是允许对a求值，(quote ~a)又禁止了求值功能 上一篇 Clojure语言十四 常用宏 下一篇 Clojure语言十六 clojure与java 顶 0 踩 0 我的同类文章 Clojure （33） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247656次 积分： 43540 等级： 积分：43540 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 7
URL:: http://blog.csdn.net/csfreebird/article/details/49509869

ParseText::
Clojure语言十六 clojure与java - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 Clojure语言十六 clojure与java 标签： clojure java 2015-10-30 15:05 683人阅读 评论 (1) 收藏 举报 分类： Clojure （33） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 Clojure可以基于任何语言 Clojure诞生之初，是基于Java的。但是任何语言都可以解析lisp并执行，所以Clojure可以基于任何语言，只要一个大拿愿意这么干。这不，Clojurescript基于JavaScript的已经出现了, 之后又引发了另一个项目的出现ClojureC。两个项目在github上的地址： https://github.com/clojure/clojurescript https://github.com/schani/clojurec Clojure和Java 现在来说说clojure与java的知识点。 将clojure代码编译成java代码 在core.clj文件中，可以添加一个list (:gen-class)用来生成java class, 比如我之前的博客中用过的 (ns hello-storm-clj.core (:import [backtype.storm StormSubmitter LocalCluster]) (:use [backtype.storm clojure config]) (:gen-class)) 这样会将namespace hello-storm-clj编译成java类hello-strom-clj 将clojure工程编译成java包 参考之前的 博客 主要命令是 lein do clean, uberjar 原理是先编译出java class，然后生成manifest.mf文件，最后打包成jar文件，就可以当作java程序运行 clojure release jar包是如何运行的 clojure的历次发布都以jar包的形式，运行的命令和所有java程序一样 java -jar clojure-1.7.0.jar 解开clojure-1.7.0.jar包，找到里面的manifest.mf文件 Manifest-Version: 1.0 Archiver-Version: Plexus Archiver Created-By: Apache Maven Built-By: hudson Build-Jdk: 1.7.0_20 Main-Class: clojure.main 入口类是clojure.main类，在github中看其 源代码 package clojure; import clojure.lang.Symbol; import clojure.lang.Var; import clojure.lang.RT; public class main{ final static private Symbol CLOJURE_MAIN = Symbol.intern("clojure.main"); final static private Var REQUIRE = RT.var("clojure.core", "require"); final static private Var LEGACY_REPL = RT.var("clojure.main", "legacy-repl"); final static private Var LEGACY_SCRIPT = RT.var("clojure.main", "legacy-script"); final static private Var MAIN = RT.var("clojure.main", "main"); public static void legacy_repl(String[] args) { REQUIRE.invoke(CLOJURE_MAIN); LEGACY_REPL.invoke(RT.seq(args)); } public static void legacy_script(String[] args) { REQUIRE.invoke(CLOJURE_MAIN); LEGACY_SCRIPT.invoke(RT.seq(args)); } public static void main(String[] args) { REQUIRE.invoke(CLOJURE_MAIN); MAIN.applyTo(RT.seq(args)); } } 一个正常的Java程序。里面的代码就不深究了。 clojure使用maven centre获取java依赖包 java生态圈极其庞大，调用java代码可以获得巨大的资源，clojure可以使用java库是个明智的决策。很多java依赖包都是通过maven centre组织的，因此要重复利用这个资源。前面介绍过，这里重复一下。 在project.clj中添加依赖，依赖参考pom.xml的maven依赖设置，org.apache.storm是groupId, storm-core是artifactId :dependencies [[org.clojure/clojure "1.5.1"] [org.apache.storm/storm-core "0.9.5"]] 只要熟悉maven怎么用，用clojure获取java依赖就很简单。那些只用IDE从不看pom.xml的程序员就遭殃了。 clojure调用已有Java代码（java interop) java interop就是值clojure能够调用java代码。 调用一个Java对象的方法 形如(.method-name object-variable arg1 arg2 ...)，比如： =>(.toUpperCase "call Java String") "CALL JAVA STRING" => (.length "call Java String") 16 传个参数 e=> (.indexOf "call Java String" "S") 10 其实都使用的是dot operator,形如： (. object-expr-or-classname-symbol method-or-member-symbol optional-args*) kafka2hdfs.core=> (.indexOf "call Java String" "S") 10 kafka2hdfs.core=> (. "call Java String" indexOf "S") 10 因此两种形式都可以使用 设置一个Java对象的公有成员变量 语法如下： (set! (.member-variable object-variable) new-value) 比如 (import java.awt.Point) (let [pt (Point. 0 10)] (set! (.y pt) 100) (.y pt)) ; ⇒ 100 读取变量值很简单,  语法如下： (.member-varible object-variable) 调用静态公有成员变量/函数 用/分开类和成员 (java.lang.Math/abs -3) ; => 3 如何创建一个对象 两种方法(Class-name. arg1 arg2 ...)  这个最常用，还有就是(new Class-name arg1 arg2 ...) 注意，第一个方法里面有. 不要忘记了。 => (String. "ok") "ok" 连续调用一个对象的方法 (doto (java.util.Stack.) (.push "Latest episode of Game of Thrones, ho!") (.push "Whoops, I meant 'Land, ho!'")) import java package (import [package.name1 ClassName1 ClassName2] [package.name2 ClassName3 ClassName4]) 比如： (import [java.util Date Stack] [java.net Proxy URI]) (Date.) ; => #inst "2015-09-19T20:40:02.733-00:00" 放入namespace中是推荐的写法，也就是前面加上: (ns pirate.talk (:import [java.util Date Stack] [java.net Proxy URI])) 访问一个类的内部类 用如下形式：package.class-name$inner-class rotation-policy (TimedRotationPolicy. 15.0 org.apache.storm.hdfs.bolt.rotation.TimedRotationPolicy$TimeUnit/MINUTES) 这里使用了内部静态枚举类TimeUnit的公有成员变量MINUTES,因为该类定义如下： public class TimedRotationPolicy implements FileRotationPolicy { public static enum TimeUnit { SECONDS((long)1000), MINUTES((long)1000*60), HOURS((long)1000*60*60), DAYS((long)1000*60*60*24); 注意需要import [org.apache.storm.hdfs.bolt.rotation TimedRotationPolicy] 上一篇 Clojure语言十五 quote & unquote 下一篇 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs 顶 0 踩 0 我的同类文章 Clojure （33） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247670次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 8
URL:: http://blog.csdn.net/csfreebird/article/details/49518687

ParseText::
storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs 标签： storm clojure 2015-10-30 22:49 842人阅读 评论 (1) 收藏 举报 分类： storm （8） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 要说storm程序最常用的数据源，自然是kafka，storm通常用来进行各种实时统计，但是也会顺带将从kafka读取的数据顺带写入hdfs，根据我的经验，这几乎是必须的功能。 所以本次程序就是实现读取kafka数据，然后写入hdfs。但是最大的不同是，这是clojure版本，而不是java版本。 下面分别说明 project配置 project.clj文件包含了依赖项： (defproject kafka2hdfs "0.1.0-SNAPSHOT" :description "demo to show read from kafka and write to hdfs" :url "http://blog.csdn.net/csfreebird" :license {:name "Eclipse Public License" :url "http://www.eclipse.org/legal/epl-v10.html"} :dependencies [[org.clojure/clojure "1.5.1"] [org.apache.kafka/kafka_2.10 "0.8.2.1" :exclusions [[org.apache.zookeeper/zookeeper] [log4j/log4j] [slf4j-api/org.slf4j]] ] [org.apache.storm/storm-kafka "0.9.5"] [org.apache.storm/storm-hdfs "0.9.5"]] :main kafka2hdfs.core :aot [kafka2hdfs.core] :profiles {:provided {:dependencies [[org.apache.storm/storm-core "0.9.5" :exclusions [[org.slf4j/log4j-over-slf4j] [org.slf4j/slf4j-api] [logback-classic/ch.qos.logback]] ]]}} :plugins [[cider/cider-nrepl "0.10.0-SNAPSHOT"]] :target-path "target/%s") core程序编写 引入包 在core.js开头导入java package和class (ns kafka2hdfs.core (:import [backtype.storm StormSubmitter LocalCluster spout.SchemeAsMultiScheme] [storm.kafka ZkHosts SpoutConfig StringScheme KafkaSpout] [org.apache.storm.hdfs.bolt HdfsBolt] [org.apache.storm.hdfs.bolt.format DefaultFileNameFormat DelimitedRecordFormat] [org.apache.storm.hdfs.bolt.sync CountSyncPolicy] [org.apache.storm.hdfs.bolt.rotation TimedRotationPolicy] ) (:use [backtype.storm clojure config]) ;; for (topology ...) (:gen-class)) 可以看到，这和java代码比起来简单很多，[ ]里面第一是package名称，第二个开始是属于该package的类，因此一行就可以表达java的多行import语句 组装topology 这个函数才是核心，可以看到 (defn mk-topology [] (let [;; config kafka reader broker-hosts (ZkHosts. "host1:21818,host2:21818,host3:21818,host4:21818,host5:21818/kafka") spout-config (SpoutConfig. broker-hosts "topic" "/offset" "bigdata") ;; config hdfs writer formatter (DelimitedRecordFormat.) sync-policy (CountSyncPolicy. 1000) rotation-policy (TimedRotationPolicy. 15.0 org.apache.storm.hdfs.bolt.rotation.TimedRotationPolicy$TimeUnit/MINUTES) file-name-format (DefaultFileNameFormat.) hdfs-writer (HdfsBolt.) kafka-reader (KafkaSpout. spout-config) ] (set! (.scheme spout-config) (SchemeAsMultiScheme. (StringScheme.))) (.forceFromStart spout-config true) (.withFieldDelimiter formatter ",") (doto file-name-format (.withPath "/tmp") (.withPrefix "kafka_") (.withExtension ".log")) (doto hdfs-writer (.withFsUrl "hdfs://my-hdfs:9000") (.withFileNameFormat file-name-format) (.withRecordFormat formatter) (.withRotationPolicy rotation-policy) (.withSyncPolicy sync-policy)) (topology {"kafka-reader" (spout-spec kafka-reader :p 2)} {"hdfs-writer" (bolt-spec {"kafka-reader" :shuffle} hdfs-writer :p 1)}) )) 这里大量使用了java interop语法来实现clojure调用java代码，参考我之前的博客。 这个topology只有两个节点，一个spout, 一个bolt。 spout负责读取kafka，bolt写入hdfs。数据采用shuffle的策略从kafka bolt emit到 hdfs bolt。 提交任务 这次不是提交本地测试任务了，因为我的笔记本电脑性能很可怜，经不起折腾。 就直接编写真正提交的任务了。提交任务有两种方式，一种是用lein do clean, uberjar 打包成jar包， 然后用下面的命令提交 storm jar target/uberjar/kafka2hdfs-0.1.0-SNAPSHOT-standalone.jar kafka2hdfs.core args... 还有一种，是通过代码直接提交，以后再细说。 上一篇 Clojure语言十六 clojure与java 下一篇 storm 远程提交任务 顶 0 踩 0 我的同类文章 storm （8） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247667次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 9
URL:: http://blog.csdn.net/csfreebird/article/details/49585845

ParseText::
storm 远程提交任务 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 storm 远程提交任务 标签： storm 2015-11-02 18:09 799人阅读 评论 (0) 收藏 举报 分类： storm （8） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 远程提交任务还是十分必要的，如果有一个storm集群用于调试（有点奢侈，但是必要），可以从本地开发机器上直接提交topology. 在生产环境下，通常我们通过Jenkins编译代码，然后提交到storm集群，这也是远程提交的一种方式。这样，开发团队不会直接和storm线上环境打交道，保证了集群的安全性。 基本原理是，通过运行本地的storm.jar和远程storm集群的nimbus通信，将任务（topology的jar包）提交到nimbus并运行。下面是步骤： 下载storm release包 下载方式是 wget http://mirror.bit.edu.cn/apache/storm/apache-storm-0.9.5/apache-storm-0.9.5.tar.gz 然后设置PATH环境变量 export PATH=${your-storm-folder}/apache-storm-0.9.5/bin:$PATH 设置nimbus主机地址 创建~/.storm/storm.yaml文件 添加配置 nimbus.host: "192.168.11.0" 运行storm程序测试 $ storm list Running: /home/dean/Downloads/jdk1.7.0_51/bin/java -client -Dstorm.options= -Dstorm.home=/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5 -Dstorm.log.dir=/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/logs -Djava.library.path=/usr/local/lib:/opt/local/lib:/usr/lib -Dstorm.conf.file= -cp /home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/math.numeric-tower-0.0.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/jgrapht-core-0.9.0.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/carbonite-1.4.0.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/commons-codec-1.6.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/servlet-api-2.5.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/joda-time-2.0.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/ring-devel-0.3.11.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/logback-classic-1.0.13.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/kryo-2.21.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/clj-time-0.4.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/ring-core-1.1.5.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/commons-logging-1.1.3.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/logback-core-1.0.13.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/storm-core-0.9.5.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/snakeyaml-1.11.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/reflectasm-1.07-shaded.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/hiccup-0.3.6.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/objenesis-1.2.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/tools.cli-0.2.4.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/asm-4.0.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/commons-fileupload-1.2.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/minlog-1.2.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/clojure-1.5.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/jetty-util-6.1.26.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/log4j-over-slf4j-1.6.6.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/commons-lang-2.5.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/clj-stacktrace-0.2.2.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/jetty-6.1.26.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/commons-io-2.4.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/commons-exec-1.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/json-simple-1.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/compojure-1.1.3.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/jline-2.11.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/chill-java-0.3.5.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/ring-servlet-0.3.11.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/core.incubator-0.1.0.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/clout-1.0.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/ring-jetty-adapter-0.3.11.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/disruptor-2.10.1.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/slf4j-api-1.7.5.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/tools.macro-0.1.0.jar:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/lib/tools.logging-0.2.3.jar:/home/dean/.storm:/home/dean/work/gitlab/nj/letv/study/storm/apache-storm-0.9.5/bin backtype.storm.command.list 1242 [main] INFO backtype.storm.thrift - Connecting to Nimbus at ${nimbus-host}:6627 No topologies running. 部署成功。 提交topology 语法 storm jar your-jar your-main-class, 比如： storm jar target/uberjar/kafka2hdfs-0.1.0-SNAPSHOT-standalone.jar kafka2hdfs.core 这样就能够通过本地~/.storm/storm.yaml的设置提交到storm集群 上一篇 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs 下一篇 Leiningen 与 maven 顶 1 踩 0 我的同类文章 storm （8） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247658次 积分： 43540 等级： 积分：43540 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 10
URL:: http://blog.csdn.net/csfreebird/article/details/49755735

ParseText::
去除HDFS WARN util.NativeCodeLoader - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 去除HDFS WARN util.NativeCodeLoader 标签： hadoop hdfs 2015-11-10 10:09 727人阅读 评论 (0) 收藏 举报 分类： Hadoop （34） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 经常遇到这个警告 # hdfs dfs -ls /input 15/11/10 10:00:32 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 问题在哪里？有人说这是hadoop的预编译包是32bit的，运行在64bit上就会有问题。但是这个答案大多数时候都是错的。 如何验证64bit还是32bit? 进入hadoop安装目录 cd /data/slot0/hadoop/lib/native 用ldd命令查看依赖库 ldd libhadoop.so.1.0.0 ./libhadoop.so.1.0.0: /lib64/libc.so.6: version `GLIBC_2.14' not found (required by ./libhadoop.so.1.0.0) linux-vdso.so.1 => (0x00007fff10b79000) libdl.so.2 => /lib64/libdl.so.2 (0x00007f4ef3512000) libc.so.6 => /lib64/libc.so.6 (0x00007f4ef317d000) /lib64/ld-linux-x86-64.so.2 (0x0000003401a00000) 可以看到依赖的都是/lib64/的动态库，所以不是64位/32位问题。 但是看到报错，GLIBC_2.14找不到，现在检查系统的glibc库,  ldd --version即可检查。 ldd --version ldd (GNU libc) 2.12 Copyright (C) 2010 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Written by Roland McGrath and Ulrich Drepper. 原来系统预装的glibc库是2.12版本，而hadoop期望是2.14版本，所以打印警告信息。 现在有两个办法，重新编译glibc.2.14版本，安装后专门给hadoop使用，这个有点危险。 第二个办法直接在log4j日志中去除告警信息。在/data/slot0/hadoop/etc/hadoop/log4j.properties文件中添加 log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR 顶 2 踩 0 我的同类文章 Hadoop （34） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247669次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 11
URL:: http://blog.csdn.net/csfreebird/article/details/49766635

ParseText::
spark 通过 RDD 从HDFS文件加载JSON文件到sql表 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 spark 通过 RDD 从HDFS文件加载JSON文件到sql表 标签： spark hdfs 2015-11-10 23:39 831人阅读 评论 (0) 收藏 举报 分类： spark （3） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 RDD定义 RDD全称是Resilient Distributed Dataset, 是spark的核心抽象层，通过它可以读取多种文件，这里演示如何读取hdfs文件。所有spark的工作都是发生在RDD上，比如创建新的RDD，转换已有的RDD，对现有的RDD计算求得结果。 RDD在spark中是不可变的(immutable)对象集合，RDD可以被划分成多个分区，存放在不同的节点。 创建RDD 有两种方法，一种是加载外部的数据集，比如下面加载HDFS的文件, 运行在scalar-shell中： val textFile = sc.textFile("hdfs://namenode-host:9000/input/dean/obd_hdfs-writer-4-9-1447126914492.log") textFile.count() res1: Long = 3574 另一种方法是在driver program中用SparkContext的paralleize方法。这里暂时不讨论。 读取JSON文件 上面的log文件内容其实是json格式的，所以可以换种读法： scala> val sqlContext = new org.apache.spark.sql.SQLContext(sc) sqlContext: org.apache.spark.sql.SQLContext = org.apache.spark.sql.SQLContext@2f92b5a1 scala> val path = "hdfs://namenode-host:9000/input/dean/obd_hdfs-writer-4-9-1447126914492.log" path: String = hdfs://namenode-host:9000/input/dean/obd_hdfs-writer-4-9-1447126914492.log scala> val c = sqlContext.read.json(path) c: org.apache.spark.sql.DataFrame = [data: struct<client_version:bigint,corp_id:string,east:bigint,ext_o_latitude:double,ext_o_longitude:double,gps_num:array<struct<east:bigint,gps_num:bigint,gpstime:bigint,latitude:double,longitude:double,msg_id:bigint,msg_length:bigint,msg_type:bigint,north:bigint,terminal:string,tsp_obd_n900_head:array<bigint>>>,gpstime:bigint,heading:bigint,k:string,latitude:double,longitude:double,msg_id:bigint,msg_length:bigint,msg_type:bigint,north:bigint,syn_type:bigint,systime_driverStorage:bigint,systime_listenerserver:bigint,target_id:string,target_name:string,terminal:string,terminal_id:string,terminal_status_desc:string,tsp_obd_n900_head:array<bigint>,type:bigint,update_time:bigint>, driverName: string, type: string] scala> c.printSchema() root |-- data: struct (nullable = true) | |-- client_version: long (nullable = true) | |-- corp_id: string (nullable = true) | |-- east: long (nullable = true) | |-- ext_o_latitude: double (nullable = true) | |-- ext_o_longitude: double (nullable = true) | |-- gps_num: array (nullable = true) | | |-- element: struct (containsNull = true) | | | |-- east: long (nullable = true) | | | |-- gps_num: long (nullable = true) | | | |-- gpstime: long (nullable = true) | | | |-- latitude: double (nullable = true) | | | |-- longitude: double (nullable = true) | | | |-- msg_id: long (nullable = true) | | | |-- msg_length: long (nullable = true) | | | |-- msg_type: long (nullable = true) | | | |-- north: long (nullable = true) | | | |-- terminal: string (nullable = true) | | | |-- tsp_obd_n900_head: array (nullable = true) | | | | |-- element: long (containsNull = true) | |-- gpstime: long (nullable = true) | |-- heading: long (nullable = true) | |-- k: string (nullable = true) | |-- latitude: double (nullable = true) | |-- longitude: double (nullable = true) | |-- msg_id: long (nullable = true) | |-- msg_length: long (nullable = true) | |-- msg_type: long (nullable = true) | |-- north: long (nullable = true) | |-- syn_type: long (nullable = true) | |-- systime_driverStorage: long (nullable = true) | |-- systime_listenerserver: long (nullable = true) | |-- target_id: string (nullable = true) | |-- target_name: string (nullable = true) | |-- terminal: string (nullable = true) | |-- terminal_id: string (nullable = true) | |-- terminal_status_desc: string (nullable = true) | |-- tsp_obd_n900_head: array (nullable = true) | | |-- element: long (containsNull = true) | |-- type: long (nullable = true) | |-- update_time: long (nullable = true) |-- driverName: string (nullable = true) |-- type: string (nullable = true) 转换成表格 现在来写入到临时表obd中，并遍历该表的内容： c.registerTempTable("obd") val set = sqlContext.sql("select * from obd") set.collect().foreach(println) 会自动将JSON的树形结构拉平，不管好不好，至少是个能用的表。 这是一个程序和sql混在一起使用的模式，有点意思，不过还有些缺憾。既然是程序，就需要自动补全等功能，spark-shell没有提供。 上一篇 去除HDFS WARN util.NativeCodeLoader 下一篇 spark sql 创建dataframes 顶 0 踩 0 我的同类文章 spark （3） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247660次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 12
URL:: http://blog.csdn.net/csfreebird/article/details/49787711

ParseText::
spark sql 创建dataframes - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 spark sql 创建dataframes 标签： sql spark 2015-11-11 22:43 892人阅读 评论 (0) 收藏 举报 分类： spark （3） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 Table of Contents 1. spark sql 2. SQLContext 2.1. sql context是spark sql的所有功能入口点 2.2. 通过spark context创建sql context 2.3. hive context功能上多于sql context，未来sql context也会增加功能 3. DataFrames 3.1. 功能 3.2. 创建DataFrames 3.3. DSL 3.3.1. 可以指定DataFrames的某列数据 1   spark sql 是spark的一个模块 处理结构化数据 提供了DataFrames作为编程的抽象层 同时也是一个分布式sql查询引擎 可以从hive中读取数据 2   SQLContext 2.1   sql context是spark sql的所有功能入口点 2.2   通过spark context创建sql context val sc: SparkContext // An existing SparkContext. val sqlContext = new org.apache.spark.sql.SQLContext(sc) 注意，上面的val sc: …其实不需要写，因为启动spark-shell的时候有这么一个提示, 所以直接用就好。 Spark context available as sc. 2.3   hive context功能上多于sql context，未来sql context也会增加功能 不过由于我对hive不感兴趣，不会创建hive context 3   DataFrames 3.1   功能 分布式数据集合 列的方式组织 理解为关系数据库的表 可以从结构化文件，hive表，外部数据库或者RDD构造 3.2   创建DataFrames 通过SQLContext创建DataFrames，可以从外部文件，hive表或者RDD来创建。 为了测试本地文件，启动spark-shell的时候不要用–master连接spark master, 否则会提示找不到本地文件。 而如果想访问hdfs文件，启动spark-shell的时候要用–master。 scala> val sqlContext = new org.apache.spark.sql.SQLContext(sc) sqlContext: org.apache.spark.sql.SQLContext = org.apache.spark.sql.SQLContext@5d9ac1ff scala> val df = sqlContext.read.json("/home/smile/people.json") df: org.apache.spark.sql.DataFrame = [age: bigint, name: string] scala> df.printSchema() df.printSchema() root |-- age: long (nullable = true) |-- name: string (nullable = true) scala> df.show() df.show() +---+----+ |age|name| +---+----+ | 38|Dean| +---+----+ 3.3   DSL DataFrames提供了DSL方面对结构化数据进行操作，都是些函数，比如select, printSchema, show, groupBy, filter等。 scala> df.select("name").show() +----+ |name| +----+ |Dean| +----+ 3.3.1   可以指定DataFrames的某列数据 比如：df("column-name") ，还可以用在select中 df.select(df("name")).show(), 结果还是一样，这里只是演示一种用法。 具体请参考 官方文档 Author: dean Created: 2015-11-12 四 23:21 Validate 上一篇 spark 通过 RDD 从HDFS文件加载JSON文件到sql表 下一篇 clojure实现java类 顶 0 踩 0 我的同类文章 spark （3） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247653次 积分： 43540 等级： 积分：43540 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 13
URL:: http://blog.csdn.net/csfreebird/article/details/49910897

ParseText::
clojure实现java类 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 clojure实现java类 标签： clojure java 2015-11-18 18:43 586人阅读 评论 (0) 收藏 举报 分类： Clojure （33） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 为什么需要这么干？因为clojure可以调用java的类，但有时候这些java类需要你实现一个子类或者传递一个自定义的java对象作为参数，所以需要将clojure代码编译成java代码。 还记得之前提过的:gen-class么，在(ns...)中，使用(:gen-class)，在(ns..)之外，应该用 (gen-class) 下面是一个例子, 文件MoveDailyAction.clj内容如下： (ns kafka2hdfs.MoveDailyAction (:import [org.apache.hadoop.fs FileSystem Path] [java.io.IOException] [java.text DateFormat SimpleDateFormat] [java.util.Date])) (gen-class :name "kafka2hdfs.MoveDailyAction" :implements [org.apache.storm.hdfs.common.rotation.RotationAction] :state dest :init init :constructors {[String][]}) (defn -init [dest] [[] dest]) 这个类名叫MoveDailyAction，实现了RotationAction接口，有一个不可变的公有成员变量dest, 有一个init成员函数会在构造函数内部被调用。构造函数不需要实现，只需要声明参数形式。 具体可以参考下面两篇文档： http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/gen-class http://kotka.de/blog/2010/02/gen-class_how_it_works_and_how_to_use_it.html 为了在lein项目中，运行lein repl时自动加载并编译该类，需要在project.clj中的:aot中添加, 注意core.clj依赖MoveDailyAction.class，所以需要将MoveDailyAction放在前面先编译 :aot [kafka2hdfs.MoveDailyAction kafka2hdfs.core ] 这里体会到:aot的用处了，就是需要将clojure代码提前编译成java class，然后用于其他地方。 在repl中运行下面的代码测试： kafka2hdfs.core=> (def o (kafka2hdfs.MoveDailyAction. "ab")) #'kafka2hdfs.core/o kafka2hdfs.core=> (.dest o) "ab" 构造函数接受的参数，在后面可以读取出来。 上一篇 spark sql 创建dataframes 下一篇 clojure引入另一个clojure实现的Java类 顶 0 踩 0 我的同类文章 Clojure （33） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247671次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 14
URL:: http://blog.csdn.net/csfreebird/article/details/49916071

ParseText::
clojure引入另一个clojure实现的Java类 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 clojure引入另一个clojure实现的Java类 标签： clojure 2015-11-19 00:19 777人阅读 评论 (0) 收藏 举报 分类： Clojure （33） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 说起来有点绕口，是这么回事。 core.clj文件里面要使用一个Java类，这个Java类(MoveDailyAction)是由同一个项目的clojure代码编译生成的，clojure -> java class请参考之前的博客 clojure实现java类 现在需要将clojure生成的Java类的class文件放在指定的目录下，然后让core.clj能够引用到这个class文件。这就主要靠leiningen工程配置 第一个需要用compile-path设置 :compile-path "%s/classy-files" 编译结果会出现在下面的目录 ls target/uberjar+uberjar/classy-files/kafka2hdfs/ core.class core$_main.class MoveDailyAction$_execute.class MoveDailyAction$loading__4910__auto__.class core$fn__48.class core$mk_topology.class MoveDailyAction$fn__26.class core__init.class core$submit_topology_BANG_.class MoveDailyAction__init.class core$loading__4910__auto__.class MoveDailyAction.class MoveDailyAction$_init.class 第二个需要用java-source-paths设置 :java-source-paths ["%s/classy-files"] 这样就可以使用第一步编译出来的class文件。 注意，:aot设置时被依赖的clojure类需要先编译，因此放在前面 :aot [kafka2hdfs.MoveDailyAction kafka2hdfs.core] 现在运行命令编译吧： lein do clean, uberjar 完成。 leiningen官方文档没有记录compile-path，可以参考github的example https://github.com/technomancy/leiningen/blob/master/sample.project.clj 上一篇 clojure实现java类 下一篇 spark-shell客户机设置 顶 2 踩 0 我的同类文章 Clojure （33） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247663次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 15
URL:: http://blog.csdn.net/csfreebird/article/details/49927227

ParseText::
spark-shell客户机设置 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 spark-shell客户机设置 标签： spark 2015-11-19 15:56 594人阅读 评论 (0) 收藏 举报 分类： spark （3） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 本文介绍spark集群客户机的设置 安装程序 spark集群是standalone集群 在root帐号下，从spark集群的master上复制spark1.5.2的安装包到目录下，这样配置文件就已经复制过来，其实主要是zookeeper的配置。 owner为root，group和other用户都是可以读和运行 drwxr-xr-x 14 root root 4.0K Nov 16 11:48 spark-1.5.2-bin-hadoop2.6 里面的metoastore.db的写权限需要放开 drwxrwxrwx 5 root root 126 Nov 16 14:15 metastore_db 配置环境变量 现在可以在这台机器上建立帐号，比如dean帐号。然后设置全局的环境变量，在/etc/profile中添加 export JAVA_HOME=/letv/java export MASTER=spark://10-149-*-*:7077,10-149-*-*:7077,10-149-*-*:7077 export PATH=/letv/spark-1.5.2-bin-hadoop2.6/bin:$PATH export PATH=$JAVA_HOME/bin:$PATH 特别是MASTER环境变量，能够让用户不需要每次输入--master参数 用dean登录后，运行spark-shell，然后到spark master的UI站点看看 ID: app-20151119144454-0036 Name: Spark shell User: dean Cores: Unlimited (168 granted) Executor Memory: 1024.0 MB Submit Date: Thu Nov 19 14:44:54 CST 2015 State: RUNNING Application Detail UI 而集群总资源是 Alive Workers: 7 Cores in use: 168 Total, 168 Used Memory in use: 874.5 GB Total, 7.0 GB Used Applications: 1 Running, 36 Completed Drivers: 0 Running, 0 Completed Status: ALIVE 可以看到cpu核都被占据了，内存只用了1GB 资源管理 spark-shell提供几个资源控制的参数，下面是一个例子： spark-shell --executor-memory 4G --total-executor-cores 10 --executor-cores 1 --executor-memory 默认1GB 是每个executor占用的内存 --total-executor-cores 所有executor总共使用的cpu核数 --executor-cores 每个executor使用的cpu核数 这样就限制了总cpu核数为10, executor数目为10 仍然想通过环境变量来简化启动命令，可惜不支持，必须传参数。要想想别的招。 改写脚本，就是$@的至修改为资源控制的参数，如下面修改spark-shell.sh else export SPARK_SUBMIT_OPTS RESOURCE_OPTIONS="--executor-memory 1G --total-executor-cores 10 --executor-cores 1 " CMD_OPTIONS=$RESOURCE_OPTIONS$@ echo "CMD_OPTIONS: " $CMD_OPTIONS "$FWDIR"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" $CMD_OPTIONS fi 增加了两个变量 RESOURCE_OPTIONS和CMD_OPTIONS，为了让用户看到发生了什么，用echo将参数打印出来， 比如启动spark-shell的时候： $ spark-shell CMD_OPTIONS: --executor-memory 1G --total-executor-cores 10 --executor-cores 1 那么如果需要针对不同的用户设置不同的资源权限呢，把脚本写的复杂点就可以了。这个不再多说。 ：） 上一篇 clojure引入另一个clojure实现的Java类 下一篇 数据分析的道与术 顶 1 踩 0 我的同类文章 spark （3） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247658次 积分： 43540 等级： 积分：43540 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 16
URL:: http://blog.csdn.net/csfreebird/article/details/50019105

ParseText::
数据分析的道与术 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 数据分析的道与术 标签： 数据分析 2015-11-24 21:46 777人阅读 评论 (1) 收藏 举报 分类： 数据分析理论与实践 版权声明：本文为博主原创文章，未经博主允许不得转载。 Table of Contents 1. 数据分析的道与术 1.1. 道 1.2. 术 2. "智能大数据SMART准则"的总章-制定智能战略 2.1. 制定智能战略 2.1.1. 困境从来就存在 2.1.2. 大公司与小公司 2.1.3. 无论企业大小，建立智能业务要从战略开始 2.1.4. 从战略目的出发，只生产所需数据 2.1.5. SMART战略模板 1  数据分析的道与术 1.1  道 指的是发挥数据价值的整体逻辑思维，若没有道，就是无头苍蝇，淹没在数据海洋之中。建议大家看看Bernard Marr的"智能大数据SMART准则"。 1.2  术 指的是为了实现数据价值必须掌握的技术，包括： 数据收集 数据传输/存储 数据计算 离线 实时 数据模型建设 小数据的关系模型建设 大数据的数据仓库模型建设 数据集市建设 数据统计与分析 数据挖掘 数据产品 数据可视化 数据服务化 若没有术，则无法实现数据价值。我们工程师每天都在实践各种术，确实有必要抬起头来看看数据的道，不要被别人扣上"成本中心"的帽子, 勇于思考如何为企业创造数据价值。 2  "智能大数据SMART准则"的总章-制定智能战略 就像九阴真经的总纲、独孤九剑的总诀一样，该书第一章给出了数据应用的困境，提出了很好的方法学，值得数据人好好学习。 我结合自己的理解和实践，简略摘要了本章精华和大家分享，全文还请大家买书吧。 2.1  制定智能战略 2.1.1  困境从来就存在 数据和分析科学容易让人迷失和崩溃，大数据出现之前就是如此，现在更是这样。世界各地的企业负责人都为此感到迷惑。 大多数企业家对于收集并存储所有的数据感到惶恐，产生一系列问题： 数据由什么组成？采用什么格式？ 存储在哪里？如何存储？ 谁会使用？谁会拥有？谁会花钱买 如何处理？到底从哪里开始？ 2.1.2  大公司与小公司 对处于优势地位的巨头而言 每一条信息都有价值 拥有分析技术、资金和技术能力，足以投资，挖掘海量数据 处于行业领先地位，总能吸引最好的人才 99.9%的其他公司 没有时间、资本、技术和意愿向巨头一样整合信息 但仍然不能忽视大数据 2.1.3  无论企业大小，建立智能业务要从战略开始 从制定战略起步，要明白需要什么，进而决定收集什么数据来解答问题 应把10%的分析工作用于数据发现，可能会产生意想不到的收获 Facebook预测用户从"单身"到"恋爱"的状态变换，可能会带来新的业务 乐视黄牛项目，获取下单时调用订单REST APIs接口的日志，为找到专用软件下单的黄牛提供重要线索 2.1.4  从战略目的出发，只生产所需数据 明确需要什么信息，能得到且会用到的信息是什么，然后建造最小、最直接的数据库 数据有生命周期 大多数情况下，超过5年的消费者数据都是无用的 巨头可以保留很长时间的数据，多数企业不需要 选择数据 问问自己什么是最重要的，用得到的结论指引行动和选择数据 正确的问题(参考下面SMART战略模板中列出的一些问题例子)会让寻找解决问题的数据容易很多，数据需求、成本和压力水平将大幅度下降。 不再收集所有数据，而只是收集信息X和Y来回到Z问题。大数据从不可能变为可能。 通常可能需要将传统的小数据和大数据结合起来 例子： 黄牛项目，订单数据是存储在RDBMS的小数据，用户行为数据和下单REST APIs的日志数据是大数据，结合起来将提高识别黄牛的数量和准确度 2.1.5  SMART战略模板 目标 -> 问题 -> 选择数据 -> 分析 -> 正确结论 这是一个零售公司提高销售额的例子，下面这些正确的问题帮助零售公司正确的选择数据解决问题 Q: 多少人经过我的店铺？ A: 店内安装一台廉价的微型设备，追踪和收集过客的信号。过客的手机会激活传感器，得到统计。 Q: 多少人驻足看向窗内？ A: 传感器能够测量多少人看向窗内，看了多久 Q: 多少人进店？ A: 传感器能够测量多少人进店 Q: 多少人最终消费？ A: 收银台提供销售数据 由此可以统计转化率来测试  橱窗展示效果  和  销售商品种类  ，看哪些因素增加了  转化率  。结果是  提高了销售额  , 关闭了一家无用的门店，因为过往  人流量  不足以支持门店的运转。 依靠直觉，遵从自然法则的梨树隐喻 下图是战略模板的构成  目的面板 该面板的主要目的是设定总体背景和方向 任务说明 清晰、简洁的表明你的组织为何而存在，设定路线图指引行动和决策 可以形成一份内部文件，用以 激励股东 界定衡量组织成功的标准 界定目标, 要从雄心报复或企业未来目标角度阐述 该文件要包括：目标受众、产品和服务，以及独一无二处 愿景说明 为内外利益相关这提供指引 内部员工收到鼓舞，努力工作 客户依据说明中的竞争力描述选择你的公司 股东受到鼓舞进行投资 对公司核心价值观、行为准则和对股东期望给出方向性描述 客户面板 促使思考对当前目标客户了解多少，需要了解什么才能实现战略目标。 目标市场 目标市场是什么 是否要迎合某个特定细分市场 如果是，为什么 你对该市场了解多少？ 是否瞄准某一特殊地理区域或目标人群 需要了解潜在客户的哪些信息 价值主张 客户为什么从你这里买东西 客户看中你的哪些方面：质量、价格、创新、服务还是其他方面 消费者满意和忠诚的贡献因素是什么 SMART客户问题 将消费者和战略结合，会引发一系列客户问题 最易变心的顾客时哪些，何时变心 如何加强识别目标客户 哪些因素影响客户忠诚 客户对我们的产品、服务、品牌的认知如何 预计客户全生命周期价值为多少 客户最看中服务的哪个方面 财务面板 当前战略对财务影响有多大以及你需要了解什么 如何利用战略赚钱 商业模式是什么？你确定这是合适的商业模式么？ 落实战略时你对营业额、利润和增长率的预测是多少？ 生产产品和提供服务成本为多少？ 你知道确定答案还仅仅是猜测？ SMART财务问题 收益增长和利润率最大化时的最佳产品/服务定价是多少 某产品的预期利润率是多少 最佳投资策略是什么 不影响客户满意度情况下，如何削减服务环节以节省成本 如何将财务吃紧状况降到最低 运营面板 合作伙伴 哪些供应商、分销商、合作伙伴或其他中介机构是重要的 是否已经建立合作关系，还是准备建立 已经建立的是否合作健康 核心竞争力 需要在哪些内部环节做到最好？（产品/服务研发，创造需求，满足需求，监管和社会关系等) 资源面板 IT系统和数据 基础设施 房产、机器或工厂？ 人、人才和文化 是否已经拥有合适的人才，如果没有，能找到么？ 价值和领导力 SMART资源问题 哪里能招聘到企业需要的人才 员工忠诚度如何 绩效最佳员工理智可能性 公司雇主形象如何 如何改进工厂的能源使用效率 在哪里建立分销中心效果最好 公众对公司管理模式有什么看法 竞争和风险面板 战略地图中经常收到忽略，却对战略成功执行造成严重的潜在威胁 谁是你的主要竞争对手，为什么 谁在威胁你的成功 是否存在特定市场、客户、竞争或监管风险导致无法顺利执行战略 面临何种运营、财务或用人风险 那些消费潮流对公司商业模板造成威胁 最大IT安全风险是什么 哪些关键供应商可能会有交货困难问题 公司主要财务风险 雇主品牌最大的威胁是什么 SMART问题的用处 因为信息太多了，不能被庞大的数据淹没，问对了问题是成功的一半, 不断的问问题。 从战略开始，明确目标，对每个面板提出4-5个问题，用这些问题来指导相关评价标准和数据的选择。 发现问题本质 理解获得数据的相关性 开放沟通和指导交流 根据事实证据做更好的决定 Author: dean Created: 2015-11-24 二 21:46 Validate 上一篇 spark-shell客户机设置 下一篇 ubuntu thrift 0.9.3编译安装 顶 0 踩 0 我的同类文章 http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247662次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720)

Recno:: 17
URL:: http://blog.csdn.net/csfreebird/article/details/50293715

ParseText::
ubuntu thrift 0.9.3编译安装 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 ubuntu thrift 0.9.3编译安装 标签： ubuntu thrift 2015-12-14 13:42 512人阅读 评论 (0) 收藏 举报 分类： thrift （1） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 Table of Contents 1. 下载thrift源代码 2. 编译并安装 3. 运行测试程序 4. 安装 1  下载thrift源代码 git clone https://git-wip-us.apache.org/repos/asf/thrift.git thrift git checkout 0.9.3 2  编译并安装 安装依赖 apt-get install automake apt-get install libssl-dev apt-get install byacc apt-get install bison apt-get install flex apt-get install libevent-dev 生成编译文件 cd thrift ./bootstrap.sh configure.ac:84: installing './compile' configure.ac:88: installing './config.guess' configure.ac:88: installing './config.sub' configure.ac:27: installing './install-sh' configure.ac:27: installing './missing' compiler/cpp/Makefile.am: installing './depcomp' configure.ac: installing './ylwrap' 编译前配置,禁用java和python, 安装目录设为/usr/lib,而不是默认的/usr/local/lib ./configure --libdir=/usr/lib --without-java --without-python ... thrift 0.9.3 Building C++ Library ......... : yes Building C (GLib) Library .... : no Building Java Library ........ : no Building C# Library .......... : no Building Python Library ...... : no Building Ruby Library ........ : no Building Haxe Library ........ : no Building Haskell Library ..... : no Building Perl Library ........ : no Building PHP Library ......... : no Building Erlang Library ...... : no Building Go Library .......... : no Building D Library ........... : no Building NodeJS Library ...... : no Building Lua Library ......... : no C++ Library: Build TZlibTransport ...... : yes Build TNonblockingServer .. : yes Build TQTcpServer (Qt4) .... : no Build TQTcpServer (Qt5) .... : no If something is missing that you think should be present, please skim the output of configure to find the missing component. Details are present in config.log. 编译 make 3  运行测试程序 测试 make check 注意,v0.9.3的make check有个bug, 这里是对应的 jira issue , 报错信息是 An error message from getaddrinfo on the console is expected: Thrift: Mon Dec 14 12:19:09 2015 TServerSocket::listen() BIND 9090 4  安装 sudo make install 注意: $thrift-git-project 是thrift gi项目所在目录 库文件安装在/usr/lib目录下 头文件安装在/usr/local/include/thrift目录下 Making install in compiler/cpp make[1]: Entering directory '$thrift-git-project/compiler/cpp' make install-am make[2]: Entering directory '$thrift-git-project/compiler/cpp' make[3]: Entering directory '$thrift-git-project/compiler/cpp' /bin/mkdir -p '/usr/local/bin' /bin/bash ../../libtool --mode=install /usr/bin/install -c thrift '/usr/local/bin' libtool: install: /usr/bin/install -c thrift /usr/local/bin/thrift make[3]: Nothing to be done for 'install-data-am'. make[3]: Leaving directory '$thrift-git-project/compiler/cpp' make[2]: Leaving directory '$thrift-git-project/compiler/cpp' make[1]: Leaving directory '$thrift-git-project/compiler/cpp' Making install in lib make[1]: Entering directory '$thrift-git-project/lib' Making install in cpp make[2]: Entering directory '$thrift-git-project/lib/cpp' Making install in . make[3]: Entering directory '$thrift-git-project/lib/cpp' make[4]: Entering directory '$thrift-git-project/lib/cpp' /bin/mkdir -p '/usr/lib' /bin/bash ../../libtool --mode=install /usr/bin/install -c libthrift.la libthriftnb.la libthriftz.la '/usr/lib' libtool: install: /usr/bin/install -c .libs/libthrift-0.9.3.so /usr/lib/libthrift-0.9.3.so libtool: install: (cd /usr/lib && { ln -s -f libthrift-0.9.3.so libthrift.so || { rm -f libthrift.so && ln -s libthrift-0.9.3.so libthrift.so; }; }) libtool: install: /usr/bin/install -c .libs/libthrift.lai /usr/lib/libthrift.la libtool: install: /usr/bin/install -c .libs/libthriftnb-0.9.3.so /usr/lib/libthriftnb-0.9.3.so libtool: install: (cd /usr/lib && { ln -s -f libthriftnb-0.9.3.so libthriftnb.so || { rm -f libthriftnb.so && ln -s libthriftnb-0.9.3.so libthriftnb.so; }; }) libtool: install: /usr/bin/install -c .libs/libthriftnb.lai /usr/lib/libthriftnb.la libtool: install: /usr/bin/install -c .libs/libthriftz-0.9.3.so /usr/lib/libthriftz-0.9.3.so libtool: install: (cd /usr/lib && { ln -s -f libthriftz-0.9.3.so libthriftz.so || { rm -f libthriftz.so && ln -s libthriftz-0.9.3.so libthriftz.so; }; }) libtool: install: /usr/bin/install -c .libs/libthriftz.lai /usr/lib/libthriftz.la libtool: install: /usr/bin/install -c .libs/libthrift.a /usr/lib/libthrift.a libtool: install: chmod 644 /usr/lib/libthrift.a libtool: install: ranlib /usr/lib/libthrift.a libtool: install: /usr/bin/install -c .libs/libthriftnb.a /usr/lib/libthriftnb.a libtool: install: chmod 644 /usr/lib/libthriftnb.a libtool: install: ranlib /usr/lib/libthriftnb.a libtool: install: /usr/bin/install -c .libs/libthriftz.a /usr/lib/libthriftz.a libtool: install: chmod 644 /usr/lib/libthriftz.a libtool: install: ranlib /usr/lib/libthriftz.a libtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin" ldconfig -n /usr/lib ---------------------------------------------------------------------- Libraries have been installed in: /usr/lib If you ever happen to want to link against installed libraries in a given directory, LIBDIR, you must either use libtool, and specify the full pathname of the library, or use the `-LLIBDIR' flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the `LD_RUN_PATH' environment variable during linking - use the `-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to `/etc/ld.so.conf' See any operating system documentation about shared libraries for more information, such as the ld(1) and ld.so(8) manual pages. ---------------------------------------------------------------------- /bin/mkdir -p '/usr/local/include/thrift/async' /usr/bin/install -c -m 644 src/thrift/async/TAsyncChannel.h src/thrift/async/TAsyncDispatchProcessor.h src/thrift/async/TAsyncProcessor.h src/thrift/async/TAsyncBufferProcessor.h src/thrift/async/TAsyncProtocolProcessor.h src/thrift/async/TConcurrentClientSyncInfo.h src/thrift/async/TEvhttpClientChannel.h src/thrift/async/TEvhttpServer.h '/usr/local/include/thrift/async' /bin/mkdir -p '/usr/local/include/thrift/concurrency' /usr/bin/install -c -m 644 src/thrift/concurrency/BoostThreadFactory.h src/thrift/concurrency/Exception.h src/thrift/concurrency/Mutex.h src/thrift/concurrency/Monitor.h src/thrift/concurrency/PlatformThreadFactory.h src/thrift/concurrency/PosixThreadFactory.h src/thrift/concurrency/StdMonitor.cpp src/thrift/concurrency/StdMutex.cpp src/thrift/concurrency/StdThreadFactory.cpp src/thrift/concurrency/StdThreadFactory.h src/thrift/concurrency/Thread.h src/thrift/concurrency/ThreadManager.h src/thrift/concurrency/TimerManager.h src/thrift/concurrency/FunctionRunner.h src/thrift/concurrency/Util.h '/usr/local/include/thrift/concurrency' /bin/mkdir -p '/usr/local/include/thrift/processor' /usr/bin/install -c -m 644 src/thrift/processor/PeekProcessor.h src/thrift/processor/StatsProcessor.h src/thrift/processor/TMultiplexedProcessor.h '/usr/local/include/thrift/processor' /bin/mkdir -p '/usr/local/include/thrift/protocol' /usr/bin/install -c -m 644 src/thrift/protocol/TBinaryProtocol.h src/thrift/protocol/TBinaryProtocol.tcc src/thrift/protocol/TCompactProtocol.h src/thrift/protocol/TCompactProtocol.tcc src/thrift/protocol/TDebugProtocol.h src/thrift/protocol/TBase64Utils.h src/thrift/protocol/TJSONProtocol.h src/thrift/protocol/TMultiplexedProtocol.h src/thrift/protocol/TProtocolDecorator.h src/thrift/protocol/TProtocolTap.h src/thrift/protocol/TProtocolException.h src/thrift/protocol/TVirtualProtocol.h src/thrift/protocol/TProtocol.h '/usr/local/include/thrift/protocol' /bin/mkdir -p '/usr/local/include/thrift/qt' /usr/bin/install -c -m 644 src/thrift/qt/TQIODeviceTransport.h src/thrift/qt/TQTcpServer.h '/usr/local/include/thrift/qt' /bin/mkdir -p '/usr/local/include/thrift/server' /usr/bin/install -c -m 644 src/thrift/server/TConnectedClient.h src/thrift/server/TServer.h src/thrift/server/TServerFramework.h src/thrift/server/TSimpleServer.h src/thrift/server/TThreadPoolServer.h src/thrift/server/TThreadedServer.h src/thrift/server/TNonblockingServer.h '/usr/local/include/thrift/server' /bin/mkdir -p '/usr/local/include/thrift' /usr/bin/install -c -m 644 ../../config.h src/thrift/thrift-config.h src/thrift/TDispatchProcessor.h src/thrift/Thrift.h src/thrift/TOutput.h src/thrift/TProcessor.h src/thrift/TApplicationException.h src/thrift/TLogging.h src/thrift/cxxfunctional.h src/thrift/TToString.h '/usr/local/include/thrift' /bin/mkdir -p '/usr/local/include/thrift/transport' /usr/bin/install -c -m 644 src/thrift/transport/PlatformSocket.h src/thrift/transport/TFDTransport.h src/thrift/transport/TFileTransport.h src/thrift/transport/TSimpleFileTransport.h src/thrift/transport/TServerSocket.h src/thrift/transport/TSSLServerSocket.h src/thrift/transport/TServerTransport.h src/thrift/transport/THttpTransport.h src/thrift/transport/THttpClient.h src/thrift/transport/THttpServer.h src/thrift/transport/TSocket.h src/thrift/transport/TPipe.h src/thrift/transport/TPipeServer.h src/thrift/transport/TSSLSocket.h src/thrift/transport/TSocketPool.h src/thrift/transport/TVirtualTransport.h src/thrift/transport/TTransport.h src/thrift/transport/TTransportException.h src/thrift/transport/TTransportUtils.h src/thrift/transport/TBufferTransports.h src/thrift/transport/TShortReadTransport.h src/thrift/transport/TZlibTransport.h '/usr/local/include/thrift/transport' /bin/mkdir -p '/usr/lib/pkgconfig' /usr/bin/install -c -m 644 thrift.pc thrift-nb.pc thrift-z.pc '/usr/lib/pkgconfig' make[4]: Leaving directory '$thrift-git-project/lib/cpp' make[3]: Leaving directory '$thrift-git-project/lib/cpp' Making install in test make[3]: Entering directory '$thrift-git-project/lib/cpp/test' make install-am make[4]: Entering directory '$thrift-git-project/lib/cpp/test' make[5]: Entering directory '$thrift-git-project/lib/cpp/test' make[5]: Nothing to be done for 'install-exec-am'. make[5]: Nothing to be done for 'install-data-am'. make[5]: Leaving directory '$thrift-git-project/lib/cpp/test' make[4]: Leaving directory '$thrift-git-project/lib/cpp/test' make[3]: Leaving directory '$thrift-git-project/lib/cpp/test' make[2]: Leaving directory '$thrift-git-project/lib/cpp' make[2]: Entering directory '$thrift-git-project/lib' make[3]: Entering directory '$thrift-git-project/lib' make[3]: Nothing to be done for 'install-exec-am'. make[3]: Nothing to be done for 'install-data-am'. make[3]: Leaving directory '$thrift-git-project/lib' make[2]: Leaving directory '$thrift-git-project/lib' make[1]: Leaving directory '$thrift-git-project/lib' Making install in test make[1]: Entering directory '$thrift-git-project/test' Making install in cpp make[2]: Entering directory '$thrift-git-project/test/cpp' make install-am make[3]: Entering directory '$thrift-git-project/test/cpp' make[4]: Entering directory '$thrift-git-project/test/cpp' make[4]: Nothing to be done for 'install-exec-am'. make[4]: Nothing to be done for 'install-data-am'. make[4]: Leaving directory '$thrift-git-project/test/cpp' make[3]: Leaving directory '$thrift-git-project/test/cpp' make[2]: Leaving directory '$thrift-git-project/test/cpp' make[2]: Entering directory '$thrift-git-project/test' make[3]: Entering directory '$thrift-git-project/test' make[3]: Nothing to be done for 'install-exec-am'. make[3]: Nothing to be done for 'install-data-am'. make[3]: Leaving directory '$thrift-git-project/test' make[2]: Leaving directory '$thrift-git-project/test' make[1]: Leaving directory '$thrift-git-project/test' Making install in tutorial make[1]: Entering directory '$thrift-git-project/tutorial' Making install in cpp make[2]: Entering directory '$thrift-git-project/tutorial/cpp' make install-am make[3]: Entering directory '$thrift-git-project/tutorial/cpp' make[4]: Entering directory '$thrift-git-project/tutorial/cpp' make[4]: Nothing to be done for 'install-exec-am'. make[4]: Nothing to be done for 'install-data-am'. make[4]: Leaving directory '$thrift-git-project/tutorial/cpp' make[3]: Leaving directory '$thrift-git-project/tutorial/cpp' make[2]: Leaving directory '$thrift-git-project/tutorial/cpp' make[2]: Entering directory '$thrift-git-project/tutorial' ../compiler/cpp/thrift --gen html -r ../tutorial/tutorial.thrift make[3]: Entering directory '$thrift-git-project/tutorial' make[3]: Nothing to be done for 'install-exec-am'. make[3]: Nothing to be done for 'install-data-am'. make[3]: Leaving directory '$thrift-git-project/tutorial' make[2]: Leaving directory '$thrift-git-project/tutorial' make[1]: Leaving directory '$thrift-git-project/tutorial' make[1]: Entering directory '$thrift-git-project' make[2]: Entering directory '$thrift-git-project' make[2]: Nothing to be done for 'install-exec-am'. make[2]: Nothing to be done for 'install-data-am'. make[2]: Leaving directory '$thrift-git-project' make[1]: Leaving directory '$thrift-git-project' Author: dean Created: 2015-12-14 一 22:46 Validate 上一篇 数据分析的道与术 下一篇 用C++编写thrift第一个例子 顶 0 踩 0 我的同类文章 thrift （1） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247663次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状�

Recno:: 18
URL:: http://blog.csdn.net/csfreebird/article/details/50319035

ParseText::
用C++编写thrift第一个例子 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 用C++编写thrift第一个例子 标签： thrift 2015-12-15 18:19 512人阅读 评论 (0) 收藏 举报 分类： thrift （1） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 Table of Contents 1. 创建thrift文件 2. 生成C++代码 3. 编写C++客户端代码 4. 例子项目 4.1. 项目目录 4.2. 编译服务端 4.3. 编译客户端 4.4. 运行 1  创建thrift文件 thrift文件非常简单,一个WorkerManager提供了一个ping方法,让客户端通过RPC方式远程调用,模拟icmp协议的ping,看看服务端是否正常. # worker.thrift # Dean Chen (csfreebird@gmail.com) # /** * Thrift files can namespace, package, or prefix their output in various * target languages. */ namespace cpp freebird /** * Defining a removed class named WorkerManager */ service WorkerManager { /** * client calls ping method to make sure service process is active or dead */ void ping() } 2  生成C++代码 用thrift命令行就可以生成C++代码,包括服务器端代码: thrift -r --gen cpp -o ../ worker.thrift 上面的命令会在../目录创建gen-cpp目录,里面包含了所有生成的C++代码. worker_constants.cpp worker_constants.h WorkerManager.cpp WorkerManager.h WorkerManager_server.skeleton.cpp worker_types.cpp worker_types.h WorkerManager_server.skeleton.cpp就是C++服务端的main函数入口文件,里面使用了TSimpleServer作为TCP服务,性能较低,但是实现简单,比较合适做进程管理类的接口. 这目前就是我需要的.因为我的一个程序中就是需要能够远程对worker进程进行状态查询和任务控制,而不是传递大量的数据. 下面是自动产生的代码: // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include "WorkerManager.h" #include <thrift/protocol/TBinaryProtocol.h> #include <thrift/server/TSimpleServer.h> #include <thrift/transport/TServerSocket.h> #include <thrift/transport/TBufferTransports.h> using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using boost::shared_ptr; using namespace ::freebird; class WorkerManagerHandler : virtual public WorkerManagerIf { public: WorkerManagerHandler() { // Your initialization goes here } /** * client calls ping method to make sure service process is active or dead */ void ping() { // Your implementation goes here printf("ping\n"); } }; int main(int argc, char **argv) { int port = 9090; shared_ptr<WorkerManagerHandler> handler(new WorkerManagerHandler()); shared_ptr<TProcessor> processor(new WorkerManagerProcessor(handler)); shared_ptr<TServerTransport> serverTransport(new TServerSocket(port)); shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory()); shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); server.serve(); return 0; } 3  编写C++客户端代码 客户端程序需要自己编写: #include <iostream> #include <thrift/protocol/TBinaryProtocol.h> #include <thrift/transport/TSocket.h> #include <thrift/transport/TTransportUtils.h> #include "../../server/gen-cpp/WorkerManager.h" using namespace std; using namespace apache::thrift; using namespace apache::thrift::protocol; using namespace apache::thrift::transport; using namespace freebird; int main() { boost::shared_ptr<TTransport> socket(new TSocket("localhost", 9090)); boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket)); boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport)); WorkerManagerClient client(protocol); try { transport->open(); client.ping(); cout << "ping()" << endl; transport->close(); } catch (TException& tx) { cout << "ERROR: " << tx.what() << endl; } } 4  例子项目 项目路径 4.1  项目目录 thrift_base$ tree -L 2 . ├── client │   ├── builder │   ├── include │   └── src └── server ├── builder ├── gen-cpp └── thrift 4.2  编译服务端 sever目录下除了thrift目录里的thrift文件外,没有任何额外的C++代码gen-cpp是命令行产生的. 用下面的命令进行编译 cd builder ./rebuild.lsp debug_config.lsp builder/bin目录下的thrift_server是可执行程序 4.3  编译客户端 client目录下src目录里的main.cc文件是唯一手写的代码,编译后在builder/bin目录下出现thrift_client可执行程序. 用下面的命令进行编译 cd builder ./rebuild.lsp debug_config.lsp 4.4  运行 先启动服务端程序,监听9099端口,然后启动客户端程序,调用服务端的ping方法,服务端控制台打印出文字. 一切工作正常. Author: dean Created: 2015-12-15 二 20:38 Validate 上一篇 ubuntu thrift 0.9.3编译安装 下一篇 基本原子操作 顶 0 踩 0 我的同类文章 thrift （1） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247663次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) <

Recno:: 19
URL:: http://blog.csdn.net/csfreebird/article/details/50321053

ParseText::
基本原子操作 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 基本原子操作 标签： atomic c++11 2015-12-15 23:19 527人阅读 评论 (0) 收藏 举报 分类： c++ 11 （2） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 Table of Contents 1. 处理器支持的一系列原子操作 1.1. CAS(Compare And Swap/Set) 1.1.1. 函数原型 1.1.2. 实现逻辑 1.1.3. C++11标准库 1.2. Fetch And Add 1.3. Test And Set 1  处理器支持的一系列原子操作 1.1  CAS(Compare And Swap/Set) 详细内容参考  wiki , 下面是我的理解 1.1.1  函数原型 int compare_and_swap(int* reg, int oldval, int newval) { ... } 1.1.2  实现逻辑 根据传入的参数oldval和内存地址存放的值*reg比较 如果相同则让内存地址存放新值 如果不同则不做操作 说明此时有竞争的线程抢先修改了内存地址存放的值,因此不做操作 返回值有两种,因此实现代码也有两种,第一种比较方便因此推荐 如果操作成功则返回true,不成功返回false bool compare_and_swap(int *accum, int *dest, int newval) { if (*accum == *dest) { *dest = newval; return true; } else {//此时有竞争的线程抢先修改了内存地址存放的值,因此不做操作 *accum = *dest; return false; } } 或者仅仅返回执行CAS操作前的内存存放的值 int compare_and_swap(int* reg, int oldval, int newval) { ATOMIC(); int old_reg_val = *reg; if (old_reg_val == oldval) *reg = newval; END_ATOMIC(); return old_reg_val; } 1.1.3  C++11标准库 C++11标准提供了几个 atomic_compare_exchange  开头的函数,以后演示如何使用. 1.2  Fetch And Add 在某个内存地址存储的值上增加一个值, 下面是段伪代码: function FetchAndAdd(address location, int inc) { int value := *location *location := value + inc return value } C++11标准提供了 atomic_fetch_add  前缀的函数 1.3  Test And Set 写新值入内存地址,并返回内存地址之前存放的值, 这可以通过spin技术实现lock函数. 伪码如下: function TestAndSet(boolean_ref lock) { boolean initial = lock lock = true return initial } 参考 wiki C++11标准提供了 该功能 Author: dean Created: 2015-12-15 二 23:18 Validate 上一篇 用C++编写thrift第一个例子 下一篇 Emacs 放大缩小图片 顶 1 踩 0 我的同类文章 c++ 11 （2） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247656次 积分： 43540 等级： 积分：43540 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 20
URL:: http://blog.csdn.net/csfreebird/article/details/50329551

ParseText::
Emacs 放大缩小图片 - Dean Chen的专栏 - 博客频道 - CSDN.NET Dean Chen的专栏 乐视大数据部招聘C++/Java工程师(chenshu@letv.com) 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 Emacs 放大缩小图片 标签： emacs 图片 2015-12-16 16:24 395人阅读 评论 (0) 收藏 举报 分类： Emacs （36） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 Emacs默认就可以查看图片, 但是在放大缩小方面需要写额外的配置工作 需要安装image+模块,可以通过package的方式安装 然后在init.el中添加一行 ;; image+ (eval-after-load 'image '(require 'image+)) 当打开png图片的时候,运行下面的命令M-x imagex-auto-adjust-mode 然后重新刷新buffer revert-buffer 就能看到在窗口内看到大小合适的图片. 如果需要放大缩小, M-x imagex-global-sticky-mode 然后用下面的快捷键进行缩放等操作 ;; * C-c + / C-c -: Zoom in/out image. ;; * C-c M-m: Adjust image to current frame size. ;; * C-c C-x C-s: Save current image. 上一篇 基本原子操作 顶 0 踩 1 我的同类文章 Emacs （36） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 sheismylife 访问： 3247666次 积分： 43541 等级： 积分：43541 排名： 第46名 原创： 1080篇 转载： 21篇 译文： 1篇 评论： 1074条 文章搜索 文章分类 田金龙太极拳法 (17) 数据分析理论与实践 (1) spark (4) storm (9) Clojure (34) thrift (2) Hadoop (35) zookeeper (6) Android (9) KVM (15) Redmine (13) c++ network (1) c++ 11 (3) c++语言 (96) c++模板技术 (9) c++编译 (30) c++ boost asio (17) c++ cppcms (17) c++ boost bind (19) c++ qt (21) c++ boost库 (6) c++ boost log (12) c++ boost smart pointer (5) c++ boost graph (0) c++ ace (7) c++ com (17) c++ wtl (10) c++ windows sdk (1) MongoDB (40) MongoDB JavaScript (4) MongoDB Sharding (4) Linux (63) Linux Disk (7) Linux wine (3) Linux Network (24) Linux 用户 (2) Scrum (17) 过程管理 (12) Emacs (37) Git&GitLab (64) c++ 14 (0) Web前端 (35) Emacs C++ (5) Emacs Org (15) Emacs Clojure (1) Emacs JDEE (6) Emacs Browser (7) Emacs Email (9) Emacs Muse (3) Emacs ELisp (15) protocol buffer (4) Monitor (15) 字符与编码 (10) 数据结构和算法 (12) HTTP (2) bash (22) Maven (22) Design Pattern (5) 图形图像 (18) Nginx (24) windows commands (1) 正则表达式 (3) Java (73) StarTeam (1) 3D (6) lua (5) cmake (6) Database (3) Ruby (3) 乒乓球 (1) dotNet (8) MySQL (3) 游戏编程 (2) MacBook (2) JSF (16) 杂谈 (3) Ubuntu (10) newLISP与人工智能 (7) newLISP 系统管理 (23) newLISP语法 (26) newLISP注释 (1) newLISP web开发 (6) newLISP FOOP (4) newLISP 大数据 (9) newLISP安装 (4) newLISP 网络通信 (5) newLISP 数字类型 (2) newLISP 正则表达式 (4) newLISP实用技巧 (9) newLISP文件处理 (5) newLISP list处理 (9) newLISP 进程管理 (1) newLISP时间日期 (5) newLISP C++ builder (2) Jenkins (26) kafka (4) sqoop (5) HBase (1) tableau (2) D语言编程 (6) 阅读排行 IDispatch接口原理与应用 (30583) git checkout之二 切换到分支和文件覆盖 (30134) Ubuntu 11.10 server 安装Git 服务器 (23594) 三年后再反思我的" Java Web项目管理得失谈" (21267) MongoDB Java 连接池的注意事项 (20258) git checkout之一 HEAD基本和detached 状态 (19881) Nginx的日志 (19601) JSP总结之六：创建第一个简单的JSP页面 (18720) Singleton之C++部分一 (16815) Windows安装Git客户端工具 (16151) 评论排行 回想那些年我抛弃的技术 (149) Singleton之C++部分一 (54) 三年后再反思我的" Java Web项目管理得失谈" (37) IDispatch接口原理与应用 (26) 最佳程序设计探索之一:需求驱动编写自顶向下的代码 (25) GitLab迁移 (22) SAFEARRAY使用实例 (19) Java HashMap 分析之三:放入元素 (17) git checkout之二 切换到分支和文件覆盖 (16) GitLab升级到5.1注意事项 (16) 最新评论 田金龙老师讲解杨式太极拳的起势 u011521468 : 夯劲的力量之源是来之翻胯，练习中我发现胯回落带不动身体下沉和前后摆的发力，应该注意哪里？ 前后摆发力 u011521468 : 初学，前后摆蹬腿的时候总是把身体等的往上去了，总也发不出前后这个劲，应该注意什么？ 数据分析的道与术 u010924878 : 总结的很棒，学习了 C++网络通信库性能大比拼 wingfiring : 博主能秀一下测试代码吗？ Clojure语言十六 clojure与java u010786678 : 谢谢小伙伴的分享，学习了 storm 开发系列三 Clojue编写程序读取kafka数据并写入到hdfs u010786678 : 谢谢小伙伴的分享，学习了 newlisp url 编码 wangdan199112 : 。。。。。 newlisp url 编码 dl_dl_ : @sheismylife:好可惜，好不容易碰到一个用 newlisp 的人……谢谢回复！我自己再想办... newlisp url 编码 sheismylife : @dl_dl_:windows? 我没有windows，真的没有，实在帮不了你。 newlisp url 编码 dl_dl_ : 您好，请教下 unicode 问题。(import "user32.dll" "MessageBox... 算法专家朋友的博客 GIS/ATL Server/JavaScript 清如许的博客 CSS/Android/Java/Linux 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一)

Recno:: 21
URL:: http://blog.csdn.net/experts/rule.html

ParseText::
申请规则 - 博客频道 - CSDN.NET 首页 博客专栏 博乐推荐 博客专家 热门文章 排行榜 我的博客 帮助 订阅 博客专家 > 博客专家申请规则 博客专家申请规则 “博客专家”是CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定，同时博客专家也需要承担一定的社区责任。 博客专家申请规则具体如下： 申请CSDN博客专家应具备的条件： 1.原创技术文章总数超过20篇，并且最近一个月内发布了新的原创技术文章。 2.博客文章总的浏览量超过5万次以上。 3.文章内容的质量很高。 4.企业、团队等非个人开设的博客，需要原创技术文章总数超过40篇，并且最近一个月内发布了新的原创技术文章，博客文章总的浏览量超过10万次以上才能申请博客专家。 5.如果已经在某IT领域具有较大影响力，但是尚没有达到上述申请条件的用户，可以通过现有博客专家的推荐，或者CSDN编辑部推荐，暂时成为“特约专家”，待达到上述条件之后，再转为正式的博客专家。申请用户自成为”特约专家“后六个月内如仍未达到CSDN博客专家应具备的条件，则”特约专家“身份取消。 注意事项： 1.CSDN博客专家如有违反CSDN网站规则的行为，如大量发布广告或软文，对CSDN网站造成不良影响等，将永久取消其CSDN博客专家身份。 2.CSDN博客专家在六个月内如果没有发布任何原创或翻译博文，其博客专家身份将自动取消，转为博客频道荣誉专家，进入博客频道荣誉专家列表，不能继续享有博客专家的福利。希望恢复博客专家身份可联系管理员重新申请。 3.CSDN博客专家是CSDN给予质量较高的技术博客的一个荣誉称号，代表官方对其博客内容的肯定。但CSDN博客专家不是CSDN博客的全职或兼职管理人员，不具备CSDN博客的管理权力，其观点及行为仅代表个人，不代表CSDN官方立场。 4.博客专家中的“行业名家”是与CSDN网站有合作关系的博客专家级用户。 5.所有博客专家（包括荣誉专家）均为实名制。 博客专家福利： 1.博客专家用户头像上显示“专家”勋章。 2.博客专家发布博客时可以直接引用CSDN站外的图片。 3.博客专家的个人博客提供量子恒道统计监测，可随时查看个人博客的数据统计详情。 4.文章获得更多的推荐机会。博客专家所发的文章都会进入文章预选库，我们有专门的编辑负责从中筛选优质内容，并推荐到CSDN首页或其他内容频道；同时博客专家每日发布到博客首页的博文不受次数限制。 5.博客专家有机会免费参加CSDN举办各种会议。由CSDN举办的移动开发者大会、云计算大会、SD2大会和各类CSDN举办的技术沙龙，都会免费赠送一些门票给我们的网友，其中博客专家拥有优先选择权，甚至有机会报销来往机票和住宿费用。 6.博客专家有机会成为CSDN学院讲师、CSDN博乐、CSDN问答导师、ink签约作家等。 7.我们会为博客专家们提供更多演讲机会，推荐给厂商或者各种IT技术大会作为演讲嘉宾。 8.其他不定时的福利。CSDN不定期会有一些奖品发放，博客专家享有优先获得权。

Recno:: 22
URL:: http://blog.csdn.net/nomasp/article/details/44966625

ParseText::
nomasp 博客导读：UWP、Android、Algorithm、Lisp - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 [置顶] nomasp 博客导读：UWP、Android、Algorithm、Lisp 标签： 博客 导读 开发 编程 算法 2015-09-17 12:28 6654人阅读 评论 (29) 收藏 举报 分类： nomasp 博客导读 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp Profile Introduction to Blog 您能看到这篇博客导读是我的荣幸，本博客会持续更新，感谢您的支持，欢迎您的关注与留言。博客有多个专栏，分别是关于 Windows App开发 、 UWP（通用Windows平台）开发 、 SICP习题解 和 Scheme语言学习 、 算法解析 与 LeetCode等题解 、 Android应用开发 ，而最近会添加的文章将主要是算法和Android，不过其它内容也会继续完善。 About the Author 独立 Windows App 和 Android 应用开发者，微软校园精英MSP，CSDN博客专家、C#版及Java SE版的小版主。多年C++/C#/Java、Lisp编程经验。密切关注人工智能、图像处理等，现阶段专攻算法和Android应用开发；热爱分享、支持开源，希望我的博客能够帮助到一些人，当然也希望能作为我成长的印记。2016年就要开始实习/工作了，希望从事于软件开发相关工作。 Contact 邮箱：kinhiox@gmail.com QQ：474780799（请注明来自CSDN） 微信：KeWang1996（请注明来自CSDN） CSDN博客： nomasp柯于旺 新浪微博： nomasp柯于旺 备用邮箱：nomasp@outlook.com Flagship Articles 【万字总结】以插排和分治为例来看如何分析与设计算法 【万字总结】探讨递归与迭代的区别与联系及如何求解10000的阶层 【万字总结】图解堆算法、链表、栈与队列（多图预警） 【万字总结】快速排序详解与各种线性时间排序对比 从Hello World到defmacro，那些令人惊叹的代码！ 图论算法 有图有代码 万字总结 向前辈致敬 Blog Navigation 说明：请点击以下标签进入相应的大版块，或直接往下逐个浏览。 编程语言（7）： C 、 C++ 、 C# 、 Java 、 HTML 、 Scheme 、 JavaScript 、 Common Lisp 算法（7）： Algorithm Example 、 Algorithm Column 、、 AOJ and POJ 、 LeetCode 、 SICP Exercise 、 Data Structures 、 Project Euler 、 Mathematics 技术（7）： Android 、 Android Errors 、 Android Notes 、 Linux Notes 、 WPF 、 Windows App 、 Windows App Books 、 Universal Windows Platform 工具（5）： Git/Github 、 OpenCV 、 OpenXML 、 SICP Summary 、 TCP/IP 其他（5）： Utility Series 、 Tech Talk 、 Books 、 Personal Record 、 Software Testing Algorithm Example 霍纳规则（C/C++，Scheme） 斐波那契数（C/C++，Scheme） 控制台绘制正弦/余弦曲线 控制台绘制正弦曲线和余弦曲线同时显示 控制台绘制正切曲线 100的阶层真的算不出来吗？ 杨辉三角形 抓交通肇事犯 存钱问题、利润最大问题 捕鱼分鱼、出售鱼、平分七筐鱼 字梯游戏 硬币问题 区间调度问题 字典序最小问题——Best Cow Line Saruman’s Army Fence Repair 背包问题 某大学程序设计竞赛 如何用两个栈实现一个队列，以及用两个队列实现一个栈 Algorithm Column 【算法】1 由插入排序看如何分析和设计算法 【算法】2 由股票收益问题再看分治算法和递归式 【算法】3 由招聘问题看随机算法 【算法】4 五张图带你体会堆算法 【算法】5 传说中的快排是怎样的 【算法】6 比较排序之外学习新的线性时间排序 【算法】7 分不清栈和队列？一张图给你完整体会 【算法】8 图文搭配诠释三种链表及其哨兵 Android Errors Android：problem opening wizard the selected wizard could not be started Android：OnClickListener cannot be resolved to a type Android：Plug-in com.android.ide.eclipse.adt was unable to load class android Android： Done. Nothing was installed Android : Can’t create handler inside thread that has not called Looper.prepare() Android Notes Android Version 在Ubuntu（Linux）上安装Android Studio 修改Android Studio的Android SDK Path 修改Android Studio的字体 如何使用Android命令 Android Studio 快捷键 如何在Android Studio上使用Github 如何引入android-support-v4/Fragment 如何将数据从Activity返回到Fragment——onActivityResult 如何在Fragment中使用findViewById呢？ 如何用Sencha Touch打包Android的APK Android Android 开发第一弹：倒计时 Android 开发第二弹：通讯录 Android 开发第三弹：自定义左右菜单（滑动动画+蒙版效果） Android 开发第四弹：围住神经猫（简单Demo） Android 开发第五弹：简易时钟（闹钟） Android 开发第六弹：简易时钟（计时器） Android 开发第七弹：简易时钟（秒表） Android 学习之路一：Activity之间传递数据的四种方式 AOJ and POJ POJ 1979 Red and Black（红与黑） POJ 3009 Curling 2.0 {深度优先搜索} AOJ 0118 Property Distribution {深度优先搜索} AOJ 0033 Ball AOJ 0121 Seven Puzzle {广度优先搜索}（*） Books 内容：2015读书计划及进度 《卡耐基写给男人的12堂财商课》摘录 C 字符串（C语言） C++ 【C++注意事项】1 数据类型及类型转换 【C++注意事项】2 变量声明和定义 【C++注意事项】3 引用 【C++注意事项】4 指针 Pointers 【C++注意事项】5 Top-level const , The auto and decltype Type Specifier 【C++注意事项】6 Library string Type 【C++注意事项】7 Library vector Type 日常小记：C++中的log10函数 一种巧妙的反转字符串的方法及思考过程 C# WPF和WinRT中的导航问题 文件属性及资源文件的使用 继承和多态 预处理指令 【LINQ技术】扩展特性和LINQ操作符 Common Lisp 从Hello World到defmacro，那些令人惊叹的代码！ Data Structures 【数据结构】回顾表ADT 【数据结构】回顾栈ADT和队ADT 【数据结构】回顾表、栈、队列 【数据结构】回顾二叉树 【数据结构】回顾散列表 【数据结构】回顾优先队列（堆） 图论算法 有图有代码 万字总结 向前辈致敬 Git/Github Github上的star和fork是什么 如何删除在Github中创建的项目 HTML 暂无 Java 用代码窥探Java支持的语言 Java 文件操作 如何调用有道翻译API（Java，HTTP） JavaScript 让JavaScript在Visual Studio 2015中编辑得更容易 LeetCode LeetCode 1 Two Sum（两个和） LeetCode 2 Add Two Numbers（两个数相加） LeetCode 3 Longest Substring Without Repeating Characters（无重复字符的最长子序列） LeetCode 4 Median of Two Sorted Arrays（两个已排序数组的中位数） LeetCode 5 Longest Palindromic Substring（最大回文子字符串） LeetCode 6 ZigZag Conversion（Z型转换） LeetCode 7 Reverse Integer（翻转整数） LeetCode 8 String to Integer (atoi)（转换到整型） LeetCode 9 Palindrome Number （回文数） LeetCode 10 Regular Expression Matching （正则表达式匹配） LeetCode 11 Container With Most Water（最大水容器） LeetCode 12 Integer to Roman（整型数到罗马数） LeetCode 13 Roman to Integer（罗马数到整型数） LeetCode 14 Longest Common Prefix（最长公共前缀） LeetCode 15 3Sum（3个数的和） LeetCode 16 3Sum Closest（最接近的3个数的和） LeetCode 17 Letter Combinations of a Phone Number（电话号码的字母组合） LeetCode 18 4Sum（4个数的和） LeetCode 19 Remove Nth Node From End of List（从列表尾部删除第N个结点） LeetCode 20 Valid Parentheses（有效的括号） LeetCode 21 Merge Two Sorted Lists（合并两个已排序的数组） LeetCode 22 Generate Parentheses（生成括号） LeetCode 23 Merge k Sorted Lists（合并K个已排序链表） LeetCode 24 Swap Nodes in Pairs（交换序列中的结点） LeetCode 25 Reverse Nodes in k-Group（在K组链表中反转结点） LeetCode 26 Remove Duplicates from Sorted Array（从已排序数组中移除重复元素） LeetCode 27 Remove Element（移除元素） LeetCode 28 Implement strStr()（实现strStr()函数） LeetCode 29 Divide Two Integers（两个整数相除）（*） LeetCode 30 Substring with Concatenation of All Words（与所有文字串联子串）（*） LeetCode 31 Next Permutation（下一个排列） LeetCode 32 Longest Valid Parentheses（最长有效括号）（*） LeetCode 33 Search in Rotated Sorted Array（在旋转排序数组中搜索）（*） LeetCode 34 Search for a Range（搜索范围） LeetCode 35 Search Insert Position（搜索并插入） LeetCode 36 Valid Sudoku（有效数独）（*） LeetCode 37 Sudoku Solver（求解数独）（*） LeetCode 38 Count and Say（计数与报数） LeetCode 292 Nim Game（Nim游戏） Linux Notes 在Ubuntu（Linux）上获取root权限 如何在Ubuntu中安装JDK VMware：锁定文件失败，未定启动虚拟机 Linux：在处理时有错误发生： open-vm-tools，E: Sub-process /usr/bin/dpkg returned an error code (1) 在Ubuntu（Linux）上安装Android Studio Mathematics 【找回数学的感觉】1 再版汉诺塔等 OpenCV 【OpenCV归纳】1 体验OpenCV 【OpenCV归纳】2 读写视频 【OpenCV归纳】3 在实例中学习简单函数以及数据读写 【OpenCV归纳】4 关于HighGUI 【OpenCV归纳】5 图像处理 【OpenCV】5种图像滤波辨析：方框、均值、高斯、中值、双边 OpenXML Open XML SDK 入门 Personal Record 你一事无成，还在那里傻乐 只要你敢，总会有光芒指引你 稻香 我的CSDN生涯 Markdown大赛二等奖 仅仅是来自深夜的想法 【Walk on】我仅仅想留下点东西 为什么你不能静下心来 nomasp的2015博客之星投票总结 Project Euler 暂无 Scheme 【Scheme归纳】1 使用Edwin 【Scheme归纳】2 算数运算 【Scheme归纳】3 比较do, let, loop 【Scheme归纳】4 高阶函数 【Scheme归纳】5 数据结构 【Scheme归纳】6 赋值 【Scheme归纳】7 常用关键字 从Hello World到defmacro，那些令人惊叹的代码！ SICP Exercise 进入专栏： SICP练习 SICP Summary 【SICP归纳】1 过程和代换模型 【SICP归纳】2 高阶函数和数据抽象 【SICP归纳】3 层次性数据和符号数据 【SICP归纳】4 模式匹配和以规则为基础的代换 【SICP归纳】5 泛型运算符 【SICP归纳】6 副作用与环境模型 Software Testing 软件测试相关简要记录 TCP/IP PV、UV、IP分别是什么意思？ 用开发者视角看Microsoft Edge 如何在MyEclipse上耍Chrome Tech Talk 微软的改名大法 缅怀我的第一台平板——Surface RT Microsoft Build 2015 从《硅谷传奇》看微软和苹果 MIT评选出的全球最聪明的50个公司-完整名单（附带往年名单）！ 我们应该怀念爱因斯坦的五个原因 15条谷歌轶事 微软早在1985年便首次使用了安卓上饱受争议的汉堡按钮 Utility Series 怎样学习一门编程语言 Google Chrome 快捷方式 网络受限是个什么东东？ VMware 11 安装 OS X 10.10 虚拟机 如何拯救任务栏 给常用电脑者推荐一个护眼小工具 在Code::Blocks中使用C++11标准 如何在Visual Studio和CodeBlocks中反编译C++代码 在VirtualBox上安装OS X 10.10 旋转90度也可以，Lumia的四大重置方式 用Visual Studio将Objective-C编译为C++ 3行代码列出硬盘上所有文件及文件夹 用Alt码打出Pi以及各式各样的符号 关于“50% CPU 占有率”题目的内容扩展 几乎所有编程语言的hello, world程序（1） 几乎所有编程语言的hello, world程序（2） 几乎所有编程语言的hello, world程序（3） 用C#获取电脑硬件信息 【征文】极客头条使用体验及改进建议 【征文】极客头条使用体验及改进建议 Eclipse 智能感知 如何写软件概要设计？ WPF 好玩的WPF第一弹：窗口抖动+边框阴影效果+倒计时显示文字 好玩的WPF第二弹：电子表字体显示时间+多彩呼吸灯特效按钮 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ 好玩的WPF第四弹：用Viewport2DVisual3D实现3D旋转效果 Windows App 【万里征程——Windows App开发】开发准备 【万里征程——Windows App开发】页面布局和基本导航 【万里征程——Windows App开发】控件大集合1 【万里征程——Windows App开发】控件大集合2 【万里征程——Windows App开发】编辑文本及键盘输入 【万里征程——Windows App开发】动画 【万里征程——Windows App开发】绘制图形 【万里征程——Windows App开发】画笔和图像 【万里征程——Windows App开发】应用栏 【万里征程——Windows App开发】用浮出控件做预览效果 【万里征程——Windows App开发】DatePicker&Timepicker 【万里征程——Windows App开发】ListView&GridView之添加数据 【万里征程——Windows App开发】ListView&GridView之分组 【万里征程——Windows App开发】SemanticZoom视图切换 【万里征程——Windows App开发】使用华丽丽的字体 【万里征程——Windows App开发】数据绑定——简单示例、更改通知、数据转换 【万里征程——Windows App开发】文件&数据——读取文件/文件夹名 【万里征程——Windows App开发】文件&数据——文件选取器 【万里征程——Windows App开发】文件&数据——写入与读取 【万里征程——Windows App开发】文件&数据——获取文件属性 【万里征程——Windows App开发】如何保存、读取、删除应用数据 【万里征程——Windows App开发】补充：JSON 【万里征程——Windows App开发】应用设置和应用帮助 【万里征程——Windows App开发】在应用中集成搜索 【万里征程——Windows App开发】如何使用粘贴板 【万里征程——Windows App开发】设置共享（共享源和共享目标） 【万里征程——Windows App开发】使用Toast通知 【万里征程——Windows App开发】动态磁贴 【万里征程——Windows App开发】DatePickerFlyout、TimePickerFlyout的使用 Windows App Books （备注：这个文档教程我已经上传至CSDN，点击即可下载： 传送门 ，无需积分） Universal Windows Platform 【UWP应用开发实战】第一弹 使用剪切板 【UWP应用开发实战】第二弹 移动版秒变桌面版 实践：罗马数计算器 【UWP通用应用开发】开发准备、部分新特性 【UWP通用应用开发】应用布局、基本导航 【UWP通用应用开发】控件、应用栏 【UWP通用应用开发】集合控件与数据绑定 【UWP通用应用开发】编辑文本、绘制图形、3D透视效果及绘制时钟实战 【UWP通用应用开发】文件选取器、获取文件属性、写入和读取、保存读取和删除应用数据 【UWP通用应用开发】集成搜索、粘贴板以及设置共享源和共享目标 【UWP通用应用开发】使用Toast通知与动态磁贴 Conclusion 上善若水。 脚踏实地，全力以赴。 学如逆水行舟，不进则退。 看优势让人自信，看劣势让人奋进。 优秀是一种行为，优秀更是一种习惯。 Standing on shoulders of giants to Learn world with a humble heart. 感谢您的访问，希望对您有所帮助。 欢迎大家关注或收藏、评论或点赞。 联系作者：kinhiox@gmail.com 本文主站点： http://blog.csdn.net/nomasp 博客导航完成时间： 2015-09-17 12:28 博客导航更新日期： ………… 2015-12-23 21：05 （此前的更新时间未记录在案） 上一篇 Eclipse 智能感知 下一篇 LeetCode 4 Median of Two Sorted Arrays 顶 12 踩 0 我的同类文章 http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577542次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0

Recno:: 23
URL:: http://blog.csdn.net/nomasp/article/details/45827145

ParseText::
图论算法 有图有代码 万字总结 向前辈致敬 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 [置顶] 图论算法 有图有代码 万字总结 向前辈致敬 标签： 图论 深度优先搜索 活动网络 网络流 算法 2015-05-18 20:55 3523人阅读 评论 (27) 收藏 举报 分类： Data Structures （8） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 图的定义 背景知识 看到这篇博客相信一开始映入读者眼帘的就是下面这幅图了，这就是传说中的七桥问题（哥尼斯堡桥问题）。在哥尼斯堡，普雷格尔河环绕着奈佛夫岛（图中的A岛）。这条河将陆地分成了下面4个区域，该处还有着7座连接这些陆地的桥梁。 问题是如何从某地出发，依次沿着各个桥，必须经过每座桥且每座桥只能经过1次，最终回到原地。 不知道这个问题且好奇的童鞋现在肯定在忙活着找出来这道题的结果了。 是伟大的数学家欧拉（Leonhard Euler）在1736年首次使用图的方法解决了该问题。 欧拉将上面的模型转换成了下面这种”图“的形式。 欧拉把顶点的度定义为与该顶点相关联的边的条数，并且他证明了存在从任意点出发，经过所有边恰好一次，并最终回到出发顶点的走法的充分必要条件是：每个顶点的度均为偶数。人们称之为 欧拉闭迹 （Eulerian walk）。 简要定义 图 （ g r a p h ） G = （ V ， E ） 由顶点（vertex）的集 V 和边（Edge）的集 E 组成。顶点代表了对象，在示意图中我们使用点或圆来表示它；边代表了两个对象的连接关系，在示意图中我们使用连接两顶点的线段来表示。 有时也把边称作弧（arc），如果点对 （ v ， w ） 是有序的，那么图就叫做有向的图（有向图）。如果点对 ( v , w ) 是无序的，那么图就叫做无向的图（无向图）。简单的讲，边没有指向性的图叫做无向图，边具有指向性的图叫做有向图。 顶点 v 和 w 邻接（adjacent）当且仅当 （ v ， w ） 属于 E 。 我们可以给边赋予各式的属性，比如权值（cost）。权值可以表示从一个顶点到另一个顶点的距离，也可以表示一个顶点到另一个顶点说话费的代价（比如时间、金钱等）。一个边上带权值的图称为网络（network）。 如果无向图中从每一个顶点到其他每个顶点都存在一条路径，则称该无向图是 连通的 （connected）。具有这样性质的有向图称为是 强连通的 的（strongly connected）。如果有向图不是强连通的，但它的基础图（underlying graph）（也就是其弧上去掉方向说形成的图）是连通的，那么称该有向图是 弱连通的 （weakly connected）。 完全图 （complete graph）是其每一对顶点间都存在一条边的图。 所谓 入度 （indegree）是指的顶点 v 的边 （ u ， v ） 的条数。 如下表示了一个有着7个顶点和12条边的有向图。 如果具有n个顶点，e条边的图G的顶点i的度为 d i ，则G的边数为： e = ∑ n − 1 0 d i 2 以上这个数学公式的markdown“源码”： $ e =\frac { \sum_{0} ^ {n-1} d_i} {2} $ 现在将图看作抽象数据类型，下面给出ADT图的结构： objects 一个非空顶点的集合和一个无向边的集合，其中每条边都是一个顶点对 functions 对于所有的 g r a p h ∈ G r a p h ， v ， v 1 ， v 2 ∈ V e r t i c e s Graph Create() return一个空图 Graph InsertVertex (graph, v) 向图graph中插入没有关联边的新顶点v，return改变后的图 Graph InsertEdge (graph, v 1 ， v 2 ) 在图graph的顶点 v 1 和 v 2 之间插入一条边，return改变后的图 Graph DeleteVertex (graph, v) 删除图graph的顶点v及与其关联的所有边，return改变后的图 Graph DeleteEdge (graph， v 1 ， v 2 ) 删除图graph的边（ v 1 , v 2 )，顶点 v 1 , v 2 不删除，return改变后的图 Boolean IsEmpty (graph) if(graph==空图） return TRUE,else return FALSE List Adjacent (graph, v) return顶点v的所有邻接结点 图的存储表示方式 图主要有3种常用的存储表示方式： 邻接矩阵 （adjacency matrices）， 邻接表 （adjacency lists）， 邻接多重表 （adjacency multilists）。 邻接矩阵 邻接矩阵使用 | V | ∗ | V | 的二维数组来表示图。 g [ i ] [ j ] 表示的是顶点 i 和顶点 j 的关系。 1）因为在无向图中，我们只需要知道顶点 i 和顶点 j 是否是相连的，因此我们只需要将 g [ i ] [ j ]

Recno:: 24
URL:: http://blog.csdn.net/nomasp/article/details/50255191

ParseText::
AOJ 0118 Property Distribution {深度优先搜索} - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 AOJ 0118 Property Distribution {深度优先搜索} 标签： 广度优先搜索 广搜 深搜 AOJ 算法 2015-12-10 21:43 708人阅读 评论 (0) 收藏 举报 分类： AOJ and POJ （4） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 题意 原题是这样的： 原题呢就是上面这个，我还是来简单翻译一下吧。 看到下面的图了么？大概有3种图案的标志，相同的可以拼接到一起，你需要找出最后一共有多少块。比如这里的就是有10块。 它的输入是这样的： 10 10 #### ** ** *@ @# @@ @@ # *# * @# # ** *@ @@ * # ** ** # *@ ** ## @* # @@ *# # *@ @@ @* @@ @# ** *# @* @# #* *@ @@ *@ @# #@ *@ *# *@ ## ** @* ** *# @@ #@ 0 0 两个0表示结束输入，输出块的个数即可，上面的输入对应的输出就是33。 分析 我还是用的这个给代码定的规定，方向什么的。 走过的点，全部都赋值为 ! ，保证下次不会走到就好。for循环中进行判断，每走一次就完成计算一块，step也跟着加1，最后输出其和即可。 代码 #include <iostream> using namespace std ; #define MAX_W 100 #define MAX_H 100 char room[MAX_W][MAX_H]; int W,H; const int direc[ 4 ][ 2 ] = { { 0 , - 1 }, { 1 , 0 }, { 0 , 1 }, {- 1 , 0 }, }; void dfs( const int & row, const int & col, const char c); int main() { while ( cin >>H>>W, W > 0 ) { int step = 0 ; int col, row; for (row = 0 ; row < H; ++row) { for (col = 0 ; col < W; ++col) { cin >> room[row][col]; } } for (row = 0 ; row < H; ++ row) { for (col = 0 ; col < W; ++ col) { if (room[row][col] != '!' ) { dfs(row, col, room[row][col]); ++ step; } } } cout <<step<<endl; } return 0 ; } void dfs( const int & row, const int & col, const char c) { room[row][col] = '!' ; for ( int d = 0 ; d < 4 ; ++ d) { int curRow = row + direc[d][ 1 ]; int curCol = col + direc[d][ 0 ]; if (curRow >= 0 && curRow < H && curCol >= 0 && curCol < W && room[curRow][curCol] == c) { dfs(curRow, curCol, c); } } } 上一篇 【UWP通用应用开发】应用布局、基本导航 下一篇 【UWP通用应用开发】控件、应用栏 顶 6 踩 0 我的同类文章 AOJ and POJ （4） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577547次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 25
URL:: http://blog.csdn.net/nomasp/article/details/50263383

ParseText::
【UWP通用应用开发】控件、应用栏 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【UWP通用应用开发】控件、应用栏 标签： visual studio 应用 微软 控件 编辑器 2015-12-11 14:28 796人阅读 评论 (2) 收藏 举报 分类： UWP （9） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 控件的属性、事件与样式资源 如何添加控件 添加控件的方式有多种，大家更喜欢下面哪一种呢？ 1）使用诸如Blend for Visual Studio或Microsoft Visual Studio XAML设计器的设计工具。 2）在Visual Studio XAML编辑器中将控件添加到XAML代码中。 3）在代码中添加控件。 注意：当应用运行时会看到你在代码中添加的控件，但在 Visual Studio XAML 设计器中看不到。 前面我们通过在工具箱拖住控件以及直接在写XAML代码来设置控件，在教程的后面，我们会看到在C#后台代码中添加控件。Blend我们暂时还没有用到，不过其在绘制图形和动画上可谓非常强大和优秀。 设置控件的属性 控件的属性相比大家都已经会用了，一来可以直接在XAML中添加属性，二来可以在属性视图中添加和修改属性。 为控件添加事件 如果要添加和修改事件呢，同样在属性视图中，点击右上角的闪电图标即可。如果要添加Click事件，那么在Click的输入框中输入好事件名称后直接按Enter即可。此时VS就会自动跳转到C#后台代码中，第一个参数sender是对处理程序所附加的对象的应用，第二参数是事件数据，它通常在签名中显示为e参数。 private void btnSetStyle_Click ( object sender, RoutedEventArgs e) { Button b = (Button)sender; b.Height = 400 ; b.Width = 320 ; } 上面的这段代码这会将所点击的Button的高设置为400，宽设置为320；除了这种方式外，也可以按如下操作，其中btnSetStyle是当前Button的名字： private void btnSetStyle_Click ( object sender, RoutedEventArgs e) { btnSetStyle.Height = 400 ; btnSetStyle.Width = 320 ; } 除此之外，我们也可以不在XAML中定义Click事件，按照如下操作也可以达到相同的效果，它会将两个事件相互关联。 public MainPage () { this .InitializeComponent(); btnSetStyle.Click += new RoutedEventHandler(btnSetStyle_Click); } private void btnSetStyle_Click ( object sender, RoutedEventArgs e) { btnSetStyle.Height = 400 ; btnSetStyle.Width = 320 ; } 为控件设置样式资源 即便没有添加过资源，也不清楚什么是样式，没关系，想必大家都玩过2048吧。游戏中有许多方格，那这些方格的样式会不会一个个去定义呢，当然不是，可以直接用样式资源来定位到所有的Button。 以下是一个基本样式， <Page.Resources> < Style TargetType= "Button" > < Setter Property = "FontWeight" Value = "Bold" /> < Setter Property = "FontSize" Value = "40" /> < Setter Property = "HorizontalAlignment" Value = "Center" ></ Setter > < Setter Property = "VerticalAlignment" Value = "Center" ></ Setter > < Setter Property = "Background" Value = "Gray" ></ Setter > < Setter Property = "Width" Value = "100" ></ Setter > < Setter Property = "Height" Value = "100" ></ Setter > < Setter Property = "Template" > < Setter . Value > <ControlTemplate TargetType= "Button" > < Grid x:Name= "Grid" Background = "Transparent" > <Border x:Name= "Border" Width= "{TemplateBinding Width}" Height= "{TemplateBinding Height}" Background = "{TemplateBinding Background}" > <ContentPresenter x:Name= "ContentPresenter" ContentTemplate= "{TemplateBinding ContentTemplate}" Content= "{TemplateBinding Content}" HorizontalAlignment= "Center" VerticalAlignment= "Center" /> </Border> </ Grid > </ControlTemplate> </ Setter . Value > </ Setter > </ Style > </Page.Resources> 但是这里也有一个问题，如果我们有10个Button控件，却只想其中8个用到这些定义，另外2个想用另一种控件，那该怎么办呢？ 将样式定义为资源，其实是有2中方式的。 一种就是直接用Style的TargetType属性来定义到所有的目标控件。 另一种则除了用TargetType属性外，还可以用x:key属性，然后再具体的控件中庸显式的关键字StaticResource来设置具体的Style属性。 <Page.Resources> < Style TargetType= "Button" > < Setter Property = "FontStyle" Value = "Oblique" /> < Setter Property = "FontSize" Value = "20" /> < Setter Property = "BorderBrush" Value = "Green" /> < Setter Property = "BorderThickness" Value = "5" /> < Setter Property = "Foreground" Value = "Orange" /> < Setter Property = "Height" Value = "80" /> < Setter Property = "Width" Value = "160" /> </ Style > < Style x:Key= "OtherStyle" TargetType= "Button" > < Setter Property = "FontStyle" Value = "Italic" /> < Setter Property = "FontSize" Value = "16" /> < Setter Property = "Foreground" Value = "Lavender" /> < Setter Property = "Height" Value = "160" /> < Setter Property = "Width" Value = "320" /> < Setter Property = "Opacity" Value = "0.2" /> </ Style > </Page.Resources> 具体效果见下图，其中Opacity属性为透明度。 大家都知道类可以继承，样式也是可以继承的。 部分控件介绍 通过前面的学习，已经见过一些控件了，现在起将逐步见到更多控件。但由于控件太多，教程中无法一一介绍，请自行举一反三。教程内容也将不断更新。 Button 前面最常用的控件就是Button了，Button还有一个有意思的属性，当把鼠标指针放在Button上时，就会在Button的头顶冒出一串文本。 < Button ToolTipService.ToolTip = "Go to www.blog.csdn.net/nomasp" Margin = "692,458,0,230" /> Button有一个很有意思的属性。 < Button Content = "摩天轮" Margin = "134,363,0,367" > < ToolTipService.ToolTip > < Image MaxHeight = "80" MaxWidth = "100" Source = "Assets/343219.jpg" /> </ ToolTipService.ToolTip > </ Button > 只要把鼠标放到Button上面就会显示出这张图片了，也叫做帮助提示吧。其实更简单的方法是下面这种。它显示的是一个后退的样式，而且鼠标放上去会有文字Back提示。 < Button Content= "摩天轮" ToolTipService.ToolTip= "Back" Style = "{StaticResource NavigationBackButtonNormalStyle}" /> ToggleSwitch 这个控件和Button很像，它像开关一样。 < ToggleSwitch x:Name = "toggleSwitch1" Header = "NoMasp Toggle" OnContent = "On" OffContent = "Off" Toggled = "ToggleSwitch_Toggled" Margin = "409,468,0,227" /> < ToggleSwitch x:Name = "toggleSwitch2" Header = "NoMasp Toggle" OnContent = "On" OffContent = "Off" IsOn = "True" Toggled = "ToggleSwitch_Toggled" Margin = "409,565,0,130" /> MessageDialog 这控件和Button一起讲还蛮合适的，我们随意添加一个Button，然后写好Click事件如下。 private async void Button_Click ( object sender, RoutedEventArgs e) { Windows.UI.Popups.MessageDialog messageDialog = new Windows.UI.Popups.MessageDialog( "噢，你刚刚踩到了地雷！" ); await messageDialog.ShowAsync(); } 注意要在函数上加上async表示异步。 如果需要预览效果，可以参见教程随后的“用浮出控件做预览效果”。 ComboBox ComboBox提供了下拉列表，自然也是一个很常用的控件。 <ComboBox Height= "50" Width= "200" Name= "cbox1" SelectionChanged= "cbox1_SelectionChanged" Margin= "17,47,1049,671" > <x: String > Select 1 </x: String > <x: String > Select 2 </x: String > <x: String > Select 3 </x: String > <x: String > Select 4 </x: String > </ComboBox> ListBox ListBox控件和ComboBox很相似，都可以让用户选择已经嵌入在列表中的选项。用法如下： <ListBox x:Name= "listBox1" SelectionChanged= "listBox1_SelectionChanged" Width= "100" > <x: String > Item 1 </x: String > <x: String > Item 2 </x: String > <x: String > Item 3 </x: String > </ListBox> DatePicker、TimePicker Winows平台设置时间的控件倒是很有特色，就是DatePicker和TimePicker。 < DatePicker Foreground = "Red" Header = "NoMasp Date" Margin = "3,177,0,533" /> < TimePicker Foreground = "Green" Header = "NoMasp Time" Margin = "3,246,0,464" Width = "289" /> 以下既是截图，也是写这篇教程的时间。 这个控件的更多介绍也在教程随后的“时间控件的更多介绍”中。 FlipView FlipView是一个可以让用户逐个浏览的项目集合的控件，下面是相关的示例代码。CommonAssets文件夹完全可以定义在Shared目录下，这样WP也可以拿来用了。 < FlipView > < Image Source = "CommonAssets/5083.jpg" /> < Image Source = "CommonAssets/5503.jpg" /> < Image Source = "CommonAssets/6121.jpg" /> </ FlipView > 除此之外呢，我们还可以在后台代码中添加，下面的第二段代码和第一段类似，不过是用的List。 FlipView flipView = new FlipView() ; flipView .Items .Add ( "Item 1" ) ; flipView .Items .Add ( "Item 2" ) ; flipView .SelectionChanged += filpView_SelectionChanged ; grid1 .Children .Add (flipView) ; List<String> listItems = new List<string>() ; listItems .Add ( "Item 1" ) ; listItems .Add ( "Item 2" ) ; FlipView flipView = new FlipView() ; flipView .ItemsSource = listItems ; flipView .SelectionChanged += filpView_SelectionChanged ; grid1 .Children .Add (flipView) ; 除了这2种方式之外呢，用CollectionViewSource来绑定数据也是完全没问题的。 < Page.Resources > < CollectionViewSource x:Name = "collectionVSFlipView" Source = "{Binding Items}" /> </ Page.Resources > 上面是一段资源文件，然后FlipView ListView的ItemsSource添加静态资源绑定就OK了。 < FlipView x:Name = "flipView" ItemsSource = "{Binding Source={StaticResource collectionVSFlipView}}" /> 如果大家自己试过FlipView就会发现它的图片资源等都是左右滚动的，如果要用上下滚动呢？那就用下面这个ItemsPanelTemplate模板就好了。 < FlipView.ItemsPanel > < ItemsPanelTemplate > < VirtualizingStackPanel Orientation = "Vertical" /> </ ItemsPanelTemplate > </ FlipView.ItemsPanel > ScrollBar 如果有缩放图片，并且可以滚动以查看图片的需要，那么就可以用ScrollBar啦。这主要是能留给图片的位置太小以至于图片无法全部显示出来。 < ScrollViewer ZoomMode = "Enabled" MaxZoomFactor = "12" HorizontalScrollMode = "Enabled" HorizontalScrollBarVisibility = "Visible" VerticalScrollBarVisibility = "Visible" VerticalScrollMode = "Enabled" Height = "200" Width = "200" Margin = "363,35,803,533" > < Image Source = "CommonAssets/6121.jpg" Height = "400" Width = "400" /> </ ScrollViewer > Viewbox 还有一个控件则可以将图片等缩放到指定的大小的，那就是Viewbox。大家看看下面这个图，是不是很炫酷呢。 < Viewbox MaxHeight = "33" MaxWidth = "33" Margin = "23.5,35,-26,-35" > < Image Source = "CommonAssets/5503.jpg" Opacity = "0.9 " /> </ Viewbox > < Viewbox MaxHeight = "66" MaxWidth = "66" Margin = "26,35,-26,-35" > < Image Source = "CommonAssets/5503.jpg" Opacity = "0.6" /> </ Viewbox > < Viewbox MaxHeight = "99" MaxWidth = "99" Margin = "26,35,-26,-35" > < Image Source = "CommonAssets/5503.jpg" Opacity = "0.3" /> </ Viewbox > GridView 相信大家都已经看过了GridView控件，很多Modern应用都会采用的。其和ComboBox挺类似的。 <GridView x:Name= "gView1" SelectionChanged= "gView1_SelectionChanged" > <x: String > Item 1 </x: String > <x: String > Item 2 </x: String > <x: String > Item 3 </x: String > </GridView> HyperlinkButton HyperlinkButton既可以作为Button来用，也可以用来做超链接。 < HyperlinkButton Content = "NoMasp--CSDN" NavigateUri = "http://blog.csdn.net/nomasp" /> ProgressBar 相信大家都挺喜欢玩进度条的吧？我本人倒是觉得相比于Win7及Vista等，Win8的进度条变得更加有意思了。 < ProgressBar x:Name = "progressBar1" IsIndeterminate = "True" Width = "100" Margin = "607,377,659,385" /> < ProgressBar x:Name = "progressBar2" Value = "70 " Width = "100" Margin = "607,352,659,410" /> 第一个图是运行中的进度条啦；第二个图中的上图也就是progressBar1，其Value为70的确定进度的进度条，下图则是progressBar2，是运行中的进度条在设计器中的静止状态。 ProgressRing 环形的进度条会不会更好玩呢？ < ProgressRing x:Name = "progressRing1" IsActive = "True" /> Slider 比如说win8上的音量呀、屏幕亮度呀，这些地方都用到了滑动条。这里来看看它的ThumbToolTipValueConverter属性吧。为了将值绑定到Slider上，我们需要有一个类，这个类需要一个为数据绑定提供值转换的接口。可视化元素也就是Slider为绑定目标，其有2个方向：数据源->数据->绑定目标，绑定目标->数据->数据源。 我们需要写一个类，可以直接在MainPage.xaml.cs下写，但更好是单独新建一个类，再考虑到这个是通用应用，所以将类新建到Shared下比较合适。 public class ThumbToolTipValueConverter : Windows.UI.Xaml.Data.IValueConverter { public object Convert ( object value , Type targetType, object parameter, string language) { if ( value is double ) { double dValue= System.Convert.ToDouble( value ); return dValue; } return null ; } public object ConvertBack ( object value , Type targetType, object parameter, string language) { return null ; } } 然后添加以下代码作为本地实例化的资源即可。 < Page.Resources > < local:ThumbToolTipValueConverter x:Key = "thumbToolTipValueC" /> </ Page.Resources > 最后就是传说中的本体啦。 < Slider Width = "200" Height = "50" Name = "slider1" ThumbToolTipValueConverter = "{StaticResource thumbToolTipValueC}" /> 我们还可以添加一个Button和TextBlock，让点击来在TextBlock上显示Slider的Value。 private void btnGetSliderValue_Click ( object sender, RoutedEventArgs e) { tblockSlider.Text = slider1.Value.ToString(); } 用浮出控件做预览效果 在前面学习控件的时候，我们已经见过了MessageDialog了，关于Button还有一个浮出控件Flyout哦。具体是怎样用呢？接下来就一起看看。 我们还是延续前面的那个示例好了，那么，代码来了。 < Button x:Name = "btnWhat" Content = "这是什么？" > < Button.Flyout > < Flyout > < StackPanel > < TextBlock Width = "430" Style = "{StaticResource BaseTextBlockStyle}" Text = "噢！你刚刚又踩到地雷了，要撤销吗？" Foreground = "Red" FontSize = "25" /> < Button Click = "btnUndo_Click" Margin = "12" Content = "撤销" /> </ StackPanel > </ Flyout > </ Button.Flyout > </ Button > 当我们点击了撤销按钮后，当然需要btnWhat按钮的Flyout消失掉，这个嘛，也只要1行代码啦。另外这个踩雷的逻辑这里就不展开啦. private void btnUndo_Click ( object sender, RoutedEventArgs e) { btnWhat.Flyout.Hide(); } 更为重要的是在于这些在WP8上也是通用的，这才是核心所在。既然这一篇教程主要是浮出控件，如果可以借助浮出产生预览图像的效果会不会很棒呢？先来看张运行截图吧。 以下都是代码啦，什么Binding呀之类的都不用管啦。需要注意的地方也就是那些Height和Width可能需要拿来调整一下。 <Page.Resources> <Flyout x:Key= "ResourceFlyoutImage" Placement= "Right" > < Image Source= "{Binding Path=Source}" MaxHeight= "800" MaxWidth= "1400" Stretch= "Uniform" /> <Flyout.FlyoutPresenterStyle> < Style TargetType= "FlyoutPresenter" > < Setter Property = "MinHeight" Value = "900" /> < Setter Property = "MinWidth" Value = "1600" /> < Setter Property = "BorderThickness" Value = "3" /> < Setter Property = "Background" Value = "Wheat" /> < Setter Property = "BorderBrush" Value = "Green" /> < Setter Property = "ScrollViewer.ZoomMode" Value = "Enabled" /> </ Style > </Flyout.FlyoutPresenterStyle> </Flyout> </Page.Resources> < Grid > <StackPanel HorizontalAlignment= "Left" Orientation= "Vertical" > < Image Source= "Assets/14152.jpg" Width= "100" Height= "100" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> < Image Source= "Assets/14158.jpg" Width= "100" Height= "100" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> < Image Source= "Assets/14160.jpg" Width= "100" Height= "100" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> < Image Source= "Assets/14164.jpg" Width= "100" Height= "100" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> </StackPanel> </ Grid > private void img_Tapped ( object sender, TappedRoutedEventArgs e) { FlyoutBase.ShowAttachedFlyout((FrameworkElement)sender); } 同样的，在WP上也是可以得哦，一下是做了些修改后的XAML代码啦。正如大家所见，我把图片都缩小了，Placement也设置成了Top，StactPanel的属性也做了修改。 <Page.Resources> <Flyout x:Key= "ResourceFlyoutImage" Placement= "Top" > < Image Source= "{Binding Path=Source}" MaxHeight= "600" MaxWidth= "400" Stretch= "Uniform" /> <Flyout.FlyoutPresenterStyle> < Style TargetType= "FlyoutPresenter" > < Setter Property = "MinHeight" Value = "600" /> < Setter Property = "MinWidth" Value = "400" /> < Setter Property = "BorderThickness" Value = "3" /> < Setter Property = "Background" Value = "Wheat" /> < Setter Property = "BorderBrush" Value = "Green" /> < Setter Property = "ScrollViewer.ZoomMode" Value = "Enabled" /> </ Style > </Flyout.FlyoutPresenterStyle> </Flyout> </Page.Resources> < Grid > <StackPanel VerticalAlignment= "Bottom" Orientation= "Horizontal" > < Image Source= "Assets/14152.jpg" Width= "72" Height= "60" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> < Image Source= "Assets/14158.jpg" Width= "72" Height= "60" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> < Image Source= "Assets/14160.jpg" Width= "72" Height= "60" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> < Image Source= "Assets/14164.jpg" Width= "72" Height= "60" Margin= "12" Tapped= "img_Tapped" FlyoutBase.AttachedFlyout= "{StaticResource ResourceFlyoutImage}" DataContext= "{Binding RelativeSource={RelativeSource Mode=Self}}" /> </StackPanel> </ Grid > 看样子效果还不错嘛。 时间控件的更多介绍 在前面我们走马观花地介绍了一大堆控件，其中自然也包括这DatePicker和TimePicker，那么稍微高级些的用法呢？ 如果你想做一个关于健身、闹钟等的App，那么不可避免的会用到时间这些控件了。 < DatePicker x:Name = "datePicker" Header = "NoMasp Date" Foreground = "Beige" /> < Button x:Name = "btnOK" Click = "btnOK_Click" Content = "确定" Foreground = "Cyan" Margin = " 292 , 378 , 0 , 352 " > < Button.Flyout > < Flyout > < TextBlock x:Name = "tblock1" Foreground = "Fuchsia" /> </ Flyout > </ Button.Flyout > </ Button > 那么我们可能需要所选定的时间是未来时间，也就是比应用运行时的时间要大。获取当前选中的时间给程序的其他部分使用也是很简单的，我这里的year等都在之前定义过了哦，在函数内定义可是不明智的哟。 private void btnOK_Click(object sender, RoutedEventArgs e) { if (datePicker. Date >DateTimeOffset. Now ) tblock1.Text = string .Format( "你所选中的时间是：{0}。" , datePicker. Date .ToString( "D" )); else tblock1.Text = "噢！你想要穿越吗？" ; year = datePicker. Date . Year ; month = datePicker. Date . Month ; day = datePicker. Date . Day ; } 有意思的事情又来了，如果你是想要做一个时间囊，默认的时间就是10年之后，那么DatePicker的初始事件如果正好就是10年后不是非常好吗。那么我们要做的呢，首先就是给DatePicker的Loaded写一条事件啦。（虽然我觉得App是保存不了10年的） private void datePicker_Loaded ( object sender, RoutedEventArgs e) { datePicker.Date = DateTimeOffset.Now.AddYears( 10 ); } 如果不想兴师动众去用DatePicker的Loaded，那么也可以直接在后台代码中这样写。 protected override void OnNavigatedTo (NavigationEventArgs e) { datePicker.Date = DateTimeOffset.Now.AddYears( 10 ); } 我还做了一个小测试呢，在Loaded事件中让时间增加11年，在OnNavigatedTo事件中让时间增加10年，结果——结果是增加了11年啦，看来还是自家的Loaded更厉害。 接下来就是TimePicker啦，回到健身的话题，假设哈，6点到18点才适合运动，那么我们的Microsoft Band就做了以下这么个要求（开玩笑啦）。 private void btnOK_Click ( object sender, RoutedEventArgs e) { TimeSpan startTime = new TimeSpan(

Recno:: 26
URL:: http://blog.csdn.net/nomasp/article/details/50267225

ParseText::
【万字总结】以插排和分治为例来看如何分析与设计算法 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【万字总结】以插排和分治为例来看如何分析与设计算法 标签： 插入排序 分治算法 迭代 递归 设计 2015-12-11 18:13 1063人阅读 评论 (2) 收藏 举报 分类： Algorithm （30） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 插入排序及其解决思路 算法的作用自然不用多说，无论是在校学生，还是已经工作多年，只要想在计算机这条道路走得更远，算法都是必不可少的。 就像编程语言中的“Hello World！”程序一般，学习算法一开始学的便是排序算法。排序问题在日常生活中也是很常见的，说得专业点： 输入是：n个数的一个序列 < a 1 , a 2 , . . . , a n − 1 , a n > 输出是：这n个数的一个全新的序列 < a , 1 , a , 2 , . . . , a , n − 1 , a , n > ，其特征是 a , 1 ≤ a , 2 ≤ . . . ≤ a , n − 1 ≤ a , n 举个例子，在本科阶段学校往往要求做的实验中大多是“学生管理系统”、“信息管理系统”、“图书管理系统”这些。就比如“学生管理系统”中的分数，每当往里面添加一个新的分数时，便会和其他的进行比较从而得到由高到低或由低到高的排序。 我本人是不太喜欢做这种管理系统的…… 再举个比较有意思的例子。 大家肯定都玩过扑克牌，撇开部分人不说，相信大部分童鞋都热衷于将牌按序号排好。那么这其中就蕴含着算法的思想： 1）手中的扑克牌有2种可能：没有扑克牌（为空）或者有扑克牌且已排好序。 2）从桌上抓起一张牌后，从左往右（从右往左）依次进行比较，最终选择一个合适的位置插入。 简单的说，插入排序的精髓在于“ 逐个比较 ”。 在列出代码之前，先来看看下面的第一张图，我画的不是太好，就是有没有经过排序的 “8，7，4，2，3，9”几个数字，根据上面的描述，将排序过程描述为： 1）将第二个数字“7”和“8”比较，发现7更小， 于是将“8”赋值到“7”所在的位置， 然后将7赋值给“8”所在的位置。 2）将”4“移到”7“所在的位置，”7“和”8“后移一位。 3）同样的步骤，将”2“和”3“移到”4“的前面。 4）”9“比前面的数字都大，故不移动。 仅仅是这样的描述还是不够的，我们需要更加专业一点。 1 ）设置一个循环，从第二个数字开始（索引为 1 ）不断与前面的数字相比。 2 ）每次循环开始时作为比较的数的索引为 j ，设置temp为其值。（因为在前面也看到了，将” 8 “赋值到” 7 “的位置时，如果不将” 7 “保存起来，那么便丢失了这个数字。） 3 ）取得 j 的前一位 i 。 4 ）只要 i 仍在数组中，并且索引为 i 处的值大于temp，就将 i 后一位的值设为 i 处的值，同时将 i 减 1 。 5 ）在 i 不在数组中或 i 处的值不必temp大时结束第四部的循环，然后将 i 后一位的值设置为temp。 将上面这部分描述翻译为insertion_sort函数，下面是完整的测试程序。 #include <iostream> #include <cstdio> using namespace std ; #define MAX_N 1000 int A[MAX_N]; int n; void insertion_sort(); int main() { printf ( "数组长度：\n" ); scanf ( "%d" ,&n); printf ( "数组内容：\n" ); for ( int i= 0 ;i<n;i++) { scanf ( "%d" ,&A[i]); } insertion_sort(); for ( int i= 0 ;i<n;i++) { printf ( "%d " ,A[i]); } return 0 ; } void insertion_sort() { for ( int j= 1 ;j<n;j++) { int temp=A[j]; int i=j- 1 ; while (i>= 0 &&A[i]>temp) { A[i+ 1 ]=A[i]; i=i- 1 ; } A[i+ 1 ]=temp; } } 下面是能够帮助我们理解算法的正确性的循环不变式的三条性质： 初始化：循环第一次迭代之前，它为真。 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。 终止：在循环终止时，不变式能够提供一个有助于证明算法正确性的性质。 就比如上面排序的例子，终止意味着在最后一次迭代时，由传入数组元素构成的子数组元素都已排好序，因此此时子数组就等同与原数组，于是循环终止。 学习如何分析算法 继续分析排序算法，我们知道排序10000个数肯定要比排序10个数所花费的时间更长，但除了输入的项数外就没有其他的影响因素吗？当然有，比如说输入的序列的已被排序的程度，如果是“23456781”这个序列，我们仅仅需要将1放到首位就好，而输入是”87654321“，我们就需要将7到1依次与其前面的数字进行比较。 关于算法的分析也有两个定义： 1）输入规模，当考虑的是排序算法时，那么规模就指的是项数；如果考虑的是图算法，那么规模就是顶点数和边数。 2）运行时间，名义上来说就是算法执行的时间，但实际上我们在分析一个算法时考量的算法执行的操作数或步数。 下面我们通过前面排序算法的伪代码来分析它的运行时间。 INSERTION-SORT(A) 1 for j = 2 to A. length // 代价c1，次数n 2 temp=A[j]; // 代价c2，次数n-1 3 // 将A[j]插入到已排序的A[1..j-1] // 代价0，次数n-1 4 i=j- 1 ; // 代价c4，次数n-1 5 while i> 0 and A[i]>temp // 代价c5 6 A[i+ 1 ]=A[i]; // 代价c6 7 i=i- 1 ; // 代价c7 8 A[i+ 1 ]=temp; // 代价c8，次数n-1 代价为c1处的次数为n应该比较好理解对吧，从j=1到j=n一共有n步，j=n也应该包括在内，因为这是算法终止的情况。而j=n时，程序直接终止了，所以在代价c2、c3、c7处次数都为n-1。 那么在while循环中呢，代价为c4的时候次数为多少呢，很显然应该是 ∑ n j = 2 t j ，而c5和c6在while循环里总有一次它不会去执行，因此次数为 ∑ n j = 2 ( t j − 1 ) 。 将代价和次数相乘，便得到了该算法所需的总时间： T ( n ) = c 1 n + c 2 ( n − 1 ) + c 4 ( n − 1 ) + c 5 ∑ n j = 2 t j + c 6 ∑ n j = 2 ( t j − 1 ) + c 7 ∑ n j = 2 ( t j − 1 ) + c 8 ( n − 1 ) 除此之外我们还可以来对算法进行最好和最坏情况的分析： 1）在最好情况下，也就是整个输入数组其实都是排好序的，那么它根本没法进入while循环，也就是说当i取初值j-1时，有 A [ i ] ≤ t e m p ，从而对 j = 2 , 3 , 4... n 都有 t j = 1 。 那么算法的总时间也就可以算出来了： T ( n ) = ( c 1 + c 2 + c 4 + c <

Recno:: 27
URL:: http://blog.csdn.net/nomasp/article/details/50269541

ParseText::
AOJ 0033 Ball - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 AOJ 0033 Ball 标签： ball aoj 算法 广搜 深搜 2015-12-11 22:08 942人阅读 评论 (0) 收藏 举报 分类： AOJ and POJ （4） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 题意 题目我截图下来了，我大致解释下。有编号1到10共10个球，从上方丢下去，入口处可以选择进入左边或者右边，最后10个球全部落下去后如果左右两侧都是从小到大的顺序，则输出YES；否则输出NO。 代码 一开始我先测试了一下自己理解的题意是不是对的： #include <iostream> #include <vector> using namespace std ; int main() { vector < int > left; vector < int > right; vector < int > all; bool flag = true ; int n; cin >> n; if (n == 0 ) return - 1 ; for ( int i = 0 ; i < n; i++) { for ( int j = 0 ; j < 10 ; j++) { int temp; cin >> temp; all.push_back(temp); } } for ( int i = 0 ; i < n; i++) { for ( int j = 0 ; j < 10 ; j++) { if (left.size() > 0 ) { if (all[ 10 * i + j] > left[left.size() - 1 ]) { left.push_back(all[ 10 * i + j]); } else { if (right.size() > 0 ) { if (all[ 10 * i + j] > right[right.size() - 1 ]) right.push_back(all[ 10 * i + j]); else flag = false ; } else { right.push_back(all[ 10 * i + j]); } } } else { left.push_back(all[ 10 * i + j]); } } if (flag) cout << "YES" << endl; else cout << "NO" << endl; flag = true ; } return 0 ; } 后来提交代码居然错了，什么鬼！！我用题目中的用例测试是对的啊，还是没有发现原因在哪…… 因为知道题意是要求用DFS，所以改改代码，思路一样，再试试： #include<stdio.h> #include <queue> using namespace std ; bool flag = true ; void solve( queue < int > left, queue < int > right, queue < int > all) { if (all.size() > 0 ) { if (left.size() > 0 ) { if (all.front() > left.back()) { left.push(all.front()); all.pop(); solve(left, right, all); } else { if (right.size() > 0 ) { if (all.front() > right.back()) { right.push(all.front()); all.pop(); solve(left, right, all); } else if (all.size() == 0 ){ } else { flag = false ; } } else { right.push(all.front()); all.pop(); solve(left, right, all); } } } else { left.push(all.front()); all.pop(); solve(left, right, all); } } } int main() { int n; scanf ( "%d" , &n); for (; n > 0 ; n--) { queue < int > all; queue < int > left; queue < int > right; for ( int i = 0 ; i < 10 ; i++) { int temp; scanf ( "%d" , &temp); all.push(temp); } solve(left, right, all); if (flag) printf ( "YES\n" ); else printf ( "NO\n" ); } return 0 ; } 这次终于可以了，证明我的思路没有问题的呀！ 找了份代码过来，变量挺多的： #include<iostream> #include<stack> #include<queue> using namespace std ; int main() { stack < int > b, c; int a[ 10 ]; bool which[ 11 ]; int data[ 11 ]; int index; int n, m, A; int i, j; cin >> n; for (i = 0 ; i<n; i++) { index = 0 ; for (j = 0 ; j< 10 ; j++) { cin >> m; a[j] = m; data[j + 1 ] = 0 ; } b.push( 0 ); c.push( 0 ); while (index >= 0 ) { A = a[index]; if (b.top() < A && (data[A] != 1 && data[A] != 3 )) { b.push(A); data[A] += 1 ; which[A] = true ; } else if (c.top() < A && (data[A] != 2 && data[A] != 3 )) { c.push(A); data[A] += 2 ; which[A] = false ; } else { index--; if (index < 0 ) { break ; } else if (which[a[index]]) { b.pop(); } else { c.pop(); } continue ; } index++; if (index > 9 ) { cout << "YES" << endl; break ; } } if (index < 0 ) { cout << "NO" << endl; } } } 上一篇 【万字总结】以插排和分治为例来看如何分析与设计算法 下一篇 【万字总结】探讨递归与迭代的区别与联系及如何求解10000的阶层 顶 2 踩 0 我的同类文章 AOJ and POJ （4） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577535次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 28
URL:: http://blog.csdn.net/nomasp/article/details/50273685

ParseText::
【万字总结】探讨递归与迭代的区别与联系及如何求解10000的阶层 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【万字总结】探讨递归与迭代的区别与联系及如何求解10000的阶层 标签： 迭代 递归 阶层 区别 算法 2015-12-12 11:32 1066人阅读 评论 (1) 收藏 举报 分类： Algorithm （30） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 递归和迭代 这两个概念也许很多童鞋依旧分不清楚，下面通过求解斐波那契数来看看它们俩的关系吧。 斐波那契数的定义： f 0 = 0 f 1 = 1 f i = f i − 1 + f i − 2 ( i > 1 ) 递归： ( factorial 6 ) ( * 6 ( factorial 5 ) ) ( * 6 ( * 5 ( factorial 4 ) ) ) ( * 6 ( * 5 ( * 4 ( factorial 3 ) ) ) ) ( * 6 ( * 5 ( * 4 ( * 3 ( factorial 2 ) ) ) ) ) ( * 6 ( * 5 ( * 4 ( * 3 ( 2 ( factorial 1 ) ) ) ) ) ) ( * 6 ( * 5 ( * 4 ( * 3 ( * 2 1 ) ) ) ) ) ( * 6 ( * 5 ( * 4 （ * 3 2)))) (* 6 ( * 5 ( * 4 6 ) ) ) ( * 6 ( * 5 24 ) ) ( * 6 120 ) 720 迭代： ( factorial 6 ) ( factorial 1 1 6 ) ( factorial 1 2 6 ) ( factorial 2 3 6 ) ( factorial 6 4 6 ) ( factorial 24 5 6 ) ( factorial 120 6 6 ) ( factorial 720 7 6 ) 720 递归的核心在于： 不断地回到起点 。 迭代的核心在于： 不断地更新参数 。 在下面的代码中： 递归的核心是sum的运算，sum不断的累乘，虽然运算的数值不同，但形式和意义一样。 而迭代的核心是product和counter的不断更新。如上表中，product就是factorial的前2个参数不断的累乘更新成第一个参数；而第二个参数则是counter，其不断的加1来更新自己。 product <- counter * product counter < - counter + 1 #include <iostream> using namespace std ; int factorialRecursive( int n); int factorialIteration( int product, int counter, int max_count); int main() { int n; cout << "Enter an integer:" <<endl; cin >>n; cout <<factorialRecursive(n)<<endl; cout <<factorialIteration( 1 , 1 ,n)<<endl; return 0 ; } int factorialRecursive( int n) { int sum= 1 ; if (n== 1 ) sum*= 1 ; else sum=n*factorialRecursive(n- 1 ); return sum; } int factorialIteration( int product, int counter, int max_count) { int sum= 1 ; if (counter>max_count) sum*=product; else factorialIteration((counter*product),(counter+ 1 ),max_count); } 补充问题： 关于上面的factorialIteration函数，今天收到一份邮件，我也通过再次分析学到了很多，这里罗列一下。 第一个问题： 首先来看相对简单的问题，该童鞋在函数内以两种不同方式加上another_sum=2却有着不同的结果。 int factorialIteration( int product, int counter, int max_count) { int sum = 1 ; int another_sum= 2 ; if (counter>max_count) { sum *=product; another_sum*=product; } else factorialIteration((counter*product),(counter+ 1 ),max_count); } int factorialIteration( int product, int counter, int max_count) { int sum = 1 ; int another_sum= 2 ; if (counter>max_count) { another_sum*=product; sum *=product; } else factorialIteration((counter*product),(counter+ 1 ),max_count); } 因为这个函数声明的是int型的返回类型，但没有用return语句，所以C++自动将其运行的最后一行语句作为了返回语句。所以这两个函数类似于： int factorialIteration( int product, int counter, int max_count) { int sum = 1 ; int another_sum= 2 ; if (counter>max_count) { sum *=product; return another_sum*=product; } else factorialIteration((counter*product),(counter+ 1 ),max_count); } int factorialIteration( int product, int counter, int max_count) { int sum = 1 ; int another_sum= 2 ; if (counter>max_count) { another_sum*=product; return sum *=product; } else factorialIteration((counter*product),(counter+ 1 ),max_count); } 然而我在CodeBlocks中写的代码不用return是可以的，但在Visual Studio中却是会报错的。 有了这个发现，我原来的代码也可以这样来写： #include <iostream> using namespace std ; int factorialRecursive( int n); int factorialIteration( int product, int counter, int max_count); int main() { int n; cout << "Enter an integer:" <<endl; cin >>n; cout <<factorialRecursive(n)<<endl; cout <<factorialIteration( 1 , 1 ,n)<<endl; return 0 ; } int factorialRecursive( int n) { int sum= 1 ; if (n== 1 ) sum*= 1 ; else sum=n*factorialRecursive(n- 1 ); // return sum; // 去掉这里的return语句 } int factorialIteration( int product, int counter, int max_count) { int sum= 1 ; if (counter>max_count) return sum*=product; // 在这里加上return语句 else factorialIteration((counter*product),(counter+ 1 ),max_count); } 现在来看另一个问题： #include <iostream> using namespace std ; int test( int n); int sum; int main() { cout <<test( 1 )<<endl; return 0 ; } int test( int n) { sum = 1 ; sum += n; if (sum < 5 ) test(n+ 1 ); } 如果设sum为全局变量，那么会在test函数中每一次调用sum=1时都将sum重新赋值为1。整个程序最后输出为5。这个应该没有什么悬念吧？ 如果设sum给test内的局部变量，则会在每一次执行int sum=1语句时都会创建一个新的sum对象，它的存放地址和之前的sum并不相同。然后整个程序最后输出意外的是4。 #include <iostream> using namespace std ; int test( int n); int main() { cout <<test( 1 )<<endl; return 0 ; } int test( int n) { int sum = 1 ; sum += n; if (sum < 5 ) return test(n+ 1 ); // return sum; 此处有这一行代码命名为程序1，没有这行代码命名为程序2 } 程序1的输出是5，程序2的输出是4。具体函数执行过程如下： 第一步，调用test(1)： int sum = 1 sum = 2 return test( 2 ) 第二步，调用test(2)： int sum = 1 sum = 3 return test( 3 ) 第三步，调用test(3)： int sum = 1 sum = 4 return test( 4 ) 第四步，调用test(4)： int sum = 1 sum = 5 执行到第四步的时候，由于sum以及不比5小了，所以程序1没有进入if语句而是执行下一句return sum，所以输出为1。 而如果是程序2，也就是没有return sum语句，那么程序在执行完第四步后就会返回到第三步，最终调用(return) sum=4，输出4。 第三个问题： 该童鞋还提到了尾递归，这里我就来说说我的理解，如有问题欢迎大家直接评论或邮件给我。 上面代码中的递归函数factorialRecursive应该没问题的吧。 上面的代码我给其命名为迭代。 int factorialIteration( int product, int counter, int max_count) { int sum = 1 ; if (counter>max_count) sum *=product; else factorialIteration((counter*product),(counter+ 1 ),max_count); } 通过在main函数中调用如下代码来执行该函数： cout<< factorialIteration( 1 , 1 ,n) <<endl; 当然，也可以另外写一个函数如下： int factorialIter( int n) { return factorialIteration( 1 , 1 ,n); } 并通过在main函数中直接调用该函数来做计算： cout<< factorialIter(n) <<endl; 函数factorialIteration中的max_count我们称其为“循环不变量”，也就是对于整个运算过程而言这个变量是不变的。为了让大家更加印象深刻，将前面出现过的东西再来复制一遍： ( factorial 6 ) ( factorial 1 1 6 ) ( factorial 1 2 6 ) ( factorial 2 3 6 ) ( factorial 6 4 6 ) ( factorial 24 5 6 ) ( factorial 120 6 6 ) ( factorial 720 7 6 ) 720 从第二行开始的factorial的第三个参数”6“就是循环不变量。 尾递归： 在计算机科学中，尾调用是一个作为过程最后一步的子例程调用执行。如果尾调用可能在以后的调用链中再调用这同一个子例程，那么这个子例程就被称为是尾递归，它是递归的一个特殊情况。尾递归非常有用，在实现中也容易处理。尾调用可以不通过在调用堆栈中添加新的栈帧而实现。 传统上，尾部调用消除是可选的。然而，在函数式编程语言中，尾调用消除往往由语言标准作为保障，这种保证允许使用递归，在特定情况下的尾递归，来代替循环。在这种情况下，尽管用它作为一种优化是不正确的（尽管它可能是习惯用法）。在尾递归中，当一个函数调用它自身这种特殊情况下，可能调用消除比传统的尾调用更加合适。 迭代： 迭代是一个重复过程，它的目的是接近既定的目标或结果。每次重复的过程也称为”迭代“，作为迭代的结果都将作为下一次迭代的起点。 迭代在计算中是指的计算机程序中的重复的语句块。它可以表示两个专业术语，同义重复，以及描述一种具有可变状态重复的具体形式。然后令人费解的是，它也可以表示通过显式重复结构的任何重复，而不管其可变性。 在第一个意义上，递归是迭代的一个例子，但通常用”递归“来标记，而不作为”迭代“的例子。 在第二个意义上，（更加狭义地）迭代描述了一种编程风格。这与一个有着更有声明性方法的递归有着鲜明的对比。 第三个意义上，使用while或for循环，以及使用map或fold的函数也被视为迭代。 （以上定义部分摘自英文维基百科） 关于递归和尾递归在函数式编程中的应用也可以看这里： 【Scheme归纳】3 比较do, let, loop 下面我也列出了相关的Scheme语言的代码： ( define ( factorial n) ( if ( = n 1 ) 1 ( * n ( factorial ( - n 1 ) ) ) ) ) ( define ( factorial n) ( fact-iter 1 1 n) ) ( define ( fact-iter product counter max-count) ( if ( > counter max-count) product ( fact-iter ( * counter product) ( + counter 1 ) max-counter) ) ) 以上分别是递归和迭代的阶层，下面是Common Lisp语言版的斐波那契数求法： ( defun fib ( n ) ( fib-iter 1 0 n) ) ( defun fib-iter ( a b count) ( if ( = count 0 ) b ( fib-iter ( + a b) a ( - count 1 ) ) ) ) 借助递归树求解递归式 前面我们已经看到了递归式，也看到了递归树，那么如何借助递归树来求解递归式呢？接下来就来看看吧。 在递归树中， 每个结点都表示一个单一问题的代价，子问题对应某次递归函数调用。 通过对树中每层的代价进行求和，就可以得到每层的代价；然后将所有层的代价求和，就可以得要到所有层次的递归调用的总代价。 我们通常用递归树来得出一个较好的猜测结果，然后用代入法来证明猜测是否正确。但是通过递归树来得到结果时，不可避免的要忍受一些”不精确“，得在稍后才能验证猜测是否正确。 因为下面的示例图太难用键盘敲出来了，我就用了手写，希望大家不介意。 如下所示，有一个递归式，我们要借助它的递归树来求解最终的结果。前面所说的忍受“不精确”这里就有2点： 1）我们要关注的更应该是解的上界，因为我们知道舍入对求解递归式没有影响，因此可以将 Θ ( n 2 ) 写成 c n 2 ，且为该递归式创建了如下递归树。 2）我们还将 n 假定为2的幂，这样所有子问题的规模均为正数。 图a所示的是 T ( n ) ，在图b中则得到了一步扩展的机会。它是如何分裂的呢？递归式的系数为3，因此有3个子结点；n被分为2部分，因此每个结点的耗时为 T ( n / 2 ) 。图c所示的则是更加进一步的扩展，且直到最后的终点。 这棵树有多高（深）呢？ 我们发现对于深度为 i 的结点，相应的规模为 n / 2 i 。因此当 n / 2 i = 1 时，也就意味着等式 i = log 2 n 成立，此时子问题的规模为1。因此这个递归树有 log 2 n + 1 层。那为什么不是 log 2 n 层呢？因为深度从 0 开始，也就是 ( 0 , 1 , 2 , . . . ,

Recno:: 29
URL:: http://blog.csdn.net/nomasp/article/details/50281677

ParseText::
【UWP通用应用开发】集合控件与数据绑定 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【UWP通用应用开发】集合控件与数据绑定 标签： 数据 控件 应用 gridview windows 2015-12-13 11:24 619人阅读 评论 (0) 收藏 举报 分类： UWP （9） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 为ListView和GridView添加数据 ListView采用垂直堆叠得方式显示数据，而GridView则采用水平堆叠得方式。 长相的话嘛，它们都差不多。 < Grid Name= "grid1" Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > <ListView x:Name= "listView1" SelectionChanged= "listView1_SelectionChanged" > <x: String > Item 1 </x: String > <x: String > Item 2 </x: String > </ListView> <GridView x:Name= "gridView1" SelectionChanged= "gridView1_SelectionChanged" > <x: String > Item 1 </x: String > <x: String > Item 2 </x: String > </GridView> </ Grid > 当然，也可以在后台代码上添加。我只是为了将它们放在一起比较而已，这些代码堆一起肯定是很丑的。 ListView listView1 = new ListView() ; listView1 .Items .Add ( "Item 1" ) ; listView1 .Items .Add ( "Item 2" ) ; listView1 .Items .Add ( "Item 3" ) ; listView1 .SelectionChanged += listView1_SelectionChanged ; grid1 .Children .Add (listView1) ; GridView gridView1 = new GridView() ; gridView1 .Items .Add ( "Item 1" ) ; gridView1 .Items .Add ( "Item 2" ) ; gridView1 .SelectionChanged += gridView1_SelectionChanged ; grid1 .Children .Add (gridView1) ; 如果只是像上面这样来添加内容会不会比较麻烦呢，我们也可以把这些Item 1、Item 2之类的全部放在List中。 List<String> itemsList = new List<string>() ; itemsList .Add ( "Item 1" ) ; itemsList .Add ( "Item 2" ) ; ListView listView1 = new ListView() ; listView1 .ItemsSource = itemsList ; listView1 .SelectionChanged += listView1_SelectionChanged ; grid1 .Children .Add (listView1) ; 这样一来所显示的ListView就是两行，非常简陋，完全不能够满足要求。那么我们可以用它的ItemTemplate属性来再里面添加一些东西，如下所示，我们可以在Grid中写一个Image绑定头像，用TextBlock绑定用户的ID，再来一个TextBlock绑定用户的消息，还可以来写边框呀什么的。而这些乱七八糟的Binding之类的，以后我们也会一起讲的哦，现在只要它们是数据绑定就好。 < Page.Resources > < CollectionViewSource x:Name = "collectionVS" Source = "{Binding Items}" /> </ Page.Resources > < Grid Name = "grid1" Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < ListView x:Name = "listView1" ItemsSource = "{Binding Source={StaticResource collectionVS}}" SelectionChanged = "listView1_SelectionChanged" > < ListView.ItemTemplate > < DataTemplate > < Grid > </ Grid > </ DataTemplate > </ ListView.ItemTemplate > </ ListView > </ Grid > 还可以像下面这样哦，通过WrapGrid来决定这些Item的摆放方式。 < Grid Name = "grid1" Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < ListView VerticalAlignment = "Bottom" > < ListView.ItemsPanel > < ItemsPanelTemplate > < WrapGrid Orientation = "Vertical" MaximumRowsOrColumns = "2" /> </ ItemsPanelTemplate > </ ListView.ItemsPanel > < Rectangle Height = "100" Width = "100" Fill = "Wheat" /> < Rectangle Height = "100" Width = "100" Fill = "White" /> < Rectangle Height = "100" Width = "100" Fill = "Gainsboro" /> < Rectangle Height = "100" Width = "100" Fill = "Violet" /> < Rectangle Height = "100" Width = "100" Fill = "DarkBlue" /> < Rectangle Height = "100" Width = "100" Fill = "RosyBrown" /> < Rectangle Height = "100" Width = "100" Fill = "SaddleBrown" /> < Rectangle Height = "100" Width = "100" Fill = "AliceBlue" /> < Rectangle Height = "100" Width = "100" Fill = "Fuchsia" /> < Rectangle Height = "100" Width = "100" Fill = "Aqua" /> < Rectangle Height = "100" Width = "100" Fill = "Tan" /> </ ListView > </ Grid > 当然啦，对于ListView和GridView而言，知道用户选择了哪一项是很重要的。SelectionMode属性决定了ListView和GridView的选择模式：单个、多个、无、扩展。 下面这个函数将选择的项给了selectedItems啦。我们还可以通过IsItemClickEnabled来启用ListView和GridView的点击事件，但是务必要注意将SelectionMode设置为None。 private void listView1_SelectionChanged ( object sender, SelectionChangedEventArgs e) { selectedItems = (List< object >)e.AddedItems; } 为ListView和GridView添加分组 本文承接“为ListView和GridView添加数据”。 在上一节中我们已经了解了怎样将数据绑定到ListView或GridView，但既然要用到这两个控件往往是因为数据繁多，那么几乎就不可避免的要让其能够分组。我们所绑定的数据源可能是项列表，其中的每个项甚至还有其自己的项，那么问题就来了。 一时不会也想不出什么宏伟的例子，就做一个简单的闹钟的时间表的ListView和GridView吧。那么先在项目中添加一个类，最好在Shared下。内容都是很简易的，闹钟的标题、时间、备注等，为了增加一级目录就加了一个AlarmMode，就算作学习和生活吧，学习生活两不误…… public class Alarm { public string Title { get ; set ; } public DateTime AlarmClockTime { get ; set ; } public string Description { get ; set ; } public string AlarmMode { get ; set ; } } public class AlarmMode { public AlarmMode () { alarmMode = new ObservableCollection<Alarm>(); } public string Name { get ; set ; } public ObservableCollection<Alarm> alarmMode { get ; private set ; } } 首先，先来定义一个全局的时间，然后在页面加载时加载两个函数（将在下一步定义）。 DateTime globalTime; protected override void OnNavigatedTo (NavigationEventArgs e) { DateTime.TryParse( "1/1/2115" , out globalTime); AddAlarm(); AddAlarmMode(); } 一大波数据正在靠近！ private void AddAlarm() { List<Alarm> listAlarm = new List<Alarm>() ; listAlarm .Add (new Alarm() { Title = "Alarm1" , Description = "First Alarm" , AlarmClockTime = globalTime .AddHours ( 1 ), AlarmMode = "Alarm In Life" }) ; listAlarm .Add (new Alarm() { Title = "Alarm2" , Description = "Second Alarm" , AlarmClockTime = globalTime .AddHours ( 11 ), AlarmMode = "Alarm In Life" }) ; listAlarm .Add (new Alarm() { Title = "Alarm3" , Description = "Third Alarm" , AlarmClockTime = globalTime .AddDays ( 1 ), AlarmMode = "Alarm In Life" }) ; listAlarm .Add (new Alarm() { Title = "Alarm1" , Description = "First Alarm" , AlarmClockTime = globalTime .AddHours ( 12 ), AlarmMode = "Alarm In Study" }) ; listAlarm .Add (new Alarm() { Title = "Alarm2" , Description = "Second Alarm" , AlarmClockTime = globalTime .AddHours ( 15 ), AlarmMode = "Alarm In Study" }) ; listAlarm .Add (new Alarm() { Title = "Alarm3" , Description = "Third Alarm" , AlarmClockTime = globalTime .AddMonths ( 1 ), AlarmMode = "Alarm In Study" }) ; ar alarmSetting = from ala in listAlarm group ala by ala .AlarmMode into alaSetting orderby alaSetting .Key select alaSetting ; collectionVSAlarm .Source = alarmSetting ; } private void AddAlarmMode() { List<AlarmMode> listAlarmMode = new List<AlarmMode>() ; AlarmMode am1 = new AlarmMode() ; am1 .Name = "Alarm In Life" ; am1 .alarmMode .Add (new Alarm() { Title = "Alarm1" , Description = "First Alarm" , AlarmClockTime = globalTime .AddHours ( 1 ), }) ; am1 .alarmMode .Add (new Alarm() { Title = "Alarm2" , Description = "Second Alarm" , AlarmClockTime = globalTime .AddHours ( 11 ), }) ; am1 .alarmMode .Add (new Alarm() { Title = "Alarm3" , Description = "Third Alarm" , AlarmClockTime = globalTime .AddDays ( 1 ), }) ; listAlarmMode .Add (am1) ; AlarmMode am2 = new AlarmMode() ; am2 .Name = "Alarm In Study" ; am2 .alarmMode .Add (new Alarm() { Title = "Alarm1" , Description = "First Alarm" , AlarmClockTime = globalTime .AddHours ( 12 ), }) ; am2 .alarmMode .Add (new Alarm() { Title = "Alarm2" , Description = "Second Alarm" , AlarmClockTime = globalTime .AddHours ( 15 ), }) ; am2 .alarmMode .Add (new Alarm() { Title = "Alarm3" , Description = "Third Alarm" , AlarmClockTime = globalTime .AddMonths ( 1 ), }) ; listAlarmMode .Add (am2) ; collectionVSAlarmMode .Source = listAlarmMode ; } 这些数据都是乱七八糟啦，大家凑合着看。这是两个函数，数据我都是用List<>来定义的，将数据通过Add函数添加到listAlarm和listAlarmMode中即可。最后再从listAlarm中根据AlarmMode挑出数据到alaSetting，同时还要根据Key值进行排序最后选出并连接到collectionVSAlarm的Source属性中。这个是需要在MainPage.xaml中定义的哦，就像 < UserControl.Resources > < CollectionViewSource x:Name = "collectionVSAlarm" IsSourceGrouped = "True" /> < CollectionViewSource x:Name = "collectionVSAlarmMode" IsSourceGrouped = "True" ItemsPath = "alarmMode" /> </ UserControl.Resources > 然后我们还需要创建一个ListGridGroupStyle类来继承GroupStyleSelector，重载它的SelectGroupStyleCore方法，并且返回ListGridGroupStyleResource资源，这个资源在博客后文中有定义，其定义在App.xaml中。相应的代码如下咯： public class ListGridGroupStyle : GroupStyleSelector { protected override GroupStyle SelectGroupStyleCore ( object group , uint level) { return (GroupStyle)App.Current.Resources[ "ListGridGroupStyleResource" ]; } } 方法重载好之后就需要在前面的UserControl.Resources中加上以下这条代码啦。 < local :ListGridGroupStyle x:Key= "ListGridGroupStyleResource" /> 然后我们来一系列的基本样式到App.xaml中就好啦，关于资源文件的使用我们在后面会系统的来学习。这里的DataTemplate和GroupStyle都在资源字典中，前者是Template模板，后者是Style风格。内容的排版大家都随意啦，记得设置好Key值。 < Application.Resources > < ResourceDictionary > < DataTemplate x:Key = "dataTemplateListView" > < StackPanel Width = "700" Margin = "10" > < StackPanel Orientation = "Horizontal" > < TextBlock Text = "{Binding Title}" FontWeight = "Bold" Margin = "12" /> < TextBlock Text = "{Binding AlarmClockTime}" TextWrapping = "NoWrap" Margin = "12" /> < TextBlock Text = "{Binding Description}" TextWrapping = "NoWrap" Margin = "12" /> </ StackPanel > </ StackPanel > </ DataTemplate > < GroupStyle x:Key = "ListGridGroupStyleResource" > < GroupStyle.HeaderTemplate > < DataTemplate > < Grid Background = "LightGray" > < TextBlock Text = '{Binding Key}' Foreground = "CornflowerBlue" Margin = "12" /> </ Grid > </ DataTemplate > </ GroupStyle.HeaderTemplate > </ GroupStyle > </ ResourceDictionary > </ Application.Resources > 那么这些各种资源都定义好了之后就在MainPage.xaml把下面这些敲进去。各种资源的调用在这里尤其需要注意，其实对于稍微复杂一丁点的程序而言，名称就已经变得让人崩溃了。所以拥有一个良好的命名习惯很重要。 < Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < Grid.ColumnDefinitions > < ColumnDefinition Width = "auto" /> < ColumnDefinition Width = "auto" /> </ Grid.ColumnDefinitions > < GridView Grid.Column = "0" ItemsSource = "{Binding Source={StaticResource collectionVSAlarmMode}}" Margin = "12,120,12,12" MaxHeight = "600" > < GridView.ItemTemplate > < DataTemplate > < StackPanel Margin = "18" > < TextBlock Text = "{Binding Title}" FontWeight = "ExtraBold" /> < TextBlock Text = "{Binding AlarmClockTime}" FontWeight = "Light" TextWrapping = "NoWrap" /> < TextBlock Text = "{Binding Description}" TextWrapping = "NoWrap" /> </ StackPanel > </ DataTemplate > </ GridView.ItemTemplate > < GridView.ItemsPanel > < ItemsPanelTemplate > < ItemsWrapGrid MaximumRowsOrColumns = "2" /> </ ItemsPanelTemplate > </ GridView.ItemsPanel > < GridView.GroupStyle > < GroupStyle > < GroupStyle.HeaderTemplate > < DataTemplate > < Grid Background = "Green" Margin = "12" > < TextBlock Text = '{Binding Name}' Foreground = "Bisque" Margin = "36" /> </ Grid > </ DataTemplate > </ GroupStyle.HeaderTemplate > </ GroupStyle > </ GridView.GroupStyle > </ GridView > < ListView Grid.Column = "1" ItemsSource = "{Binding Source={StaticResource collectionVSAlarm}}" ItemTemplate = "{StaticResource dataTemplateListView}" GroupStyleSelector = "{StaticResource ListGridGroupStyleResource}" Margin = "120" /> </ Grid > 我这写的真是太丑了哎，做产品的时候可得好好调调了。 缩放视图SemanticZoom 相信用过Windows Phone或者Windows 8/8.1/10的朋友对下面这张截图肯定不陌生。这就是通过SemanticZoom来实现的，当数据过多时，这种控件尤其适用。它有一个放大视图ZoomedInView和一个缩小试图ZoomedOutView，前者主要用来显示当前页面的详细信息，后者则致力于快速导航。 那么我就自己来动手实践咯，首先我们在XAML中添加大致的界面，就像画画要先画轮廓一样。 < Grid Name = "grid1" Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < SemanticZoom x:Name = "semanticZoom" VerticalAlignment = "Center" HorizontalAlignment = "Center" > < SemanticZoom.ZoomedOutView > </ SemanticZoom.ZoomedOutView > < SemanticZoom.ZoomedInView > </ SemanticZoom.ZoomedInView > </ SemanticZoom > </ Grid > 然后分别在这两个视图中添加你想要加入的东西。这里的核心就是，ZoomedOutView和ZoomedInView都是使用的同一个CollectionViewSource对象作为自己的数据集的。而这个属性我们在“为ListView和GridView分组”谈到过。 我们先把后台代码写好，我就像一篇那样装模作样写一个类吧。 public class Alarm { public string Title { get ; set ; } public DateTime AlarmClockTime { get ; set ; } public string Description { get ; set ; } } 然后用一个函数来添加一大堆数据……一大堆数据。 private Alarm[] AddAlarmData () { return new Alarm[] { new Alarm {Title= "Alarm 1" ,AlarmClockTime=globalTime.AddHours( 17 ),Description= "First Alarm for Study" }, new Alarm {Title= "Alarm 2" ,AlarmClockTime=globalTime.AddHours( 2 ),Description= "Second Alarm for Study" }, new Alarm {Title= "Alarm 3" ,AlarmClockTime=globalTime.AddHours( 7 ),Description= "Third Alarm for Study" }, new Alarm {Title= "Alarm 4" ,AlarmClockTime=globalTime.AddHours( 4 ),Description= "4th Alarm for Study" }, new Alarm {Title= "Alarm 5" ,AlarmClockTime=globalTime.AddHours( 5 ),Description= "First Alarm for Fun" }, new Alarm {Title= "Alarm 6" ,AlarmClockTime=globalTime.AddHours( 1 ),Description= "First Alarm for Fun" }, new Alarm {Title= "Alarm 7" ,AlarmClockTime=globalTime.AddHours( 15 ),Description= "Second Alarm for Fun" }, new Alarm {Title= "Alarm 8" ,AlarmClockTime=globalTime.AddHours( 9 ),Description= "Third Alarm for Fun" }, new Alarm {Title= "Alarm 9" ,AlarmClockTime=globalTime.AddHours( 20 ),Description= "4th Alarm for Fun" }, new Alarm {Title= "Alarm 10" ,AlarmClockTime=globalTime.AddHours( 14 ),Description= "Second Alarm for Sleep" }, new Alarm {Title= "Alarm 11" ,AlarmClockTime=globalTime.AddHours( 9 ),Description= "First Alarm for Sleep" } }; } 因为我们最后要把放大视图变成缩小视图，记得缩小视图上面有一些ABCD之类的字母么，这里我们用的是时间，就分成中午晚上等好啦。就通过下面这样的一个函数来搞定。其用了一个键值对，用time作为参数。后面再将这些数据筛选出来，绑定到新添加的CollectionViewSource中。至于gridView1和gridView2是即将添加到XAML中，这里可以先不填，一回再补上。 Func<int, string > SwitchTime = ( time ) => { if ( time <= 10 && time >= 6 ) return "上午" ; else if ( time > 10 && time < 14 ) return "中午" ; else if ( time >= 14 && time <= 20 ) return "下午" ; else return "晚上" ; }; var varTime = from t in AddAlarmData() orderby t.AlarmClockTime.Hour group t by SwitchTime(t.AlarmClockTime.Hour); CollectionViewSource collectionVS = new CollectionViewSource(); collectionVS.IsSourceGrouped = true ; collectionVS.Source = varTime; this.gridView1.ItemsSource = collectionVS.View.CollectionGroups; this.gridView2.ItemsSource = collectionVS.View; 我们先来写主视图（也就是放大视图）。 < GridView x:Name = "gridView2" IsSwipeEnabled = "True" HorizontalAlignment = "Center" VerticalAlignment = "Center" ScrollViewer.IsHorizontalScrollChainingEnabled = "False" Width = "1800" Height = "1000" > < GridView.ItemTemplate > < DataTemplate > < StackPanel Orientation = "Horizontal" Margin = "12" HorizontalAlignment = "Left" Background = "White" > < TextBlock Text = "{Binding Title}" TextWrapping = "Wrap" Foreground = "Red" FontFamily = "Harrington" Width = "150" Height = "100" FontSize = "26" FontWeight = "Light" /> < TextBlock Text = "{Binding AlarmClockTime}" Foreground = "Red" TextWrapping = "Wrap" Width = "150" Height = "100" FontFamily = "Harrington" FontSize = "26" FontWeight = "Light" /> < TextBlock Text = "{Binding Description}" Foreground = "Red" TextWrapping = "Wrap" Width = "150" Height = "100" FontFamily = "Harrington" FontSize = "26" FontWeight = "Light" /> </ StackPanel > </ DataTemplate > </ GridView.ItemTemplate > < GridView.ItemsPanel > < ItemsPanelTemplate > < ItemsWrapGrid MaximumRowsOrColumns = "8" /> </ ItemsPanelTemplate > </ GridView.ItemsPanel > < GridView.GroupStyle > < GroupStyle > < GroupStyle.HeaderTemplate > < DataTemplate > < TextBlock Text = '{Binding Key}' Foreground = "{StaticResource ApplicationForegroundThemeBrush}" Margin = "12" FontSize = "30" FontFamily = "华文彩云" FontWeight = "ExtraBold" /> </ DataTemplate > </ GroupStyle.HeaderTemplate > </ GroupStyle > </ GridView.GroupStyle > </ GridView > 相信大家都能看得懂，另外稍后我会在截图中添加一些注释的哦。然后是缩小视图。 <GridView Name= "gridView1" Background = "Wheat" ScrollViewer.IsHorizontalScrollChainingEnabled= "False" HorizontalAlignment= "Center" VerticalAlignment= "Center" Width= "600" Height= "200" > <GridView.ItemTemplate> <DataTemplate> <TextBlock Width= "100" Height= "100" Text = "{Binding Group.Key}" FontFamily = "华文行楷" FontWeight = "Normal" FontSize = "24" /> </DataTemplate> </GridView.ItemTemplate> <GridView.ItemsPanel> <ItemsPanelTemplate> <ItemsWrapGrid ItemWidth= "100" ItemHeight= "100" MaximumRowsOrColumns= "2" /> </ItemsPanelTemplate> </GridView.ItemsPanel> <GridView.ItemContainerStyle> < Style TargetType= "GridViewItem" > < Setter Property = "Margin" Value = "12" /> < Setter Property = "Padding" Value = "3" /> < Setter Property = "BorderThickness" Value = "1" /> < Setter Property = "Background" Value = "Green" /> </ Style > </GridView.ItemContainerStyle> </GridView> 那么代码就到这里为止了，接下来自然就是截图了。 （这种图片如果看不清的话可以保存到电脑上再看。） 想了解字体相关的信息，可以看第九章的“使用更多字体”。 数据绑定介绍 简单的数据绑定示例 相比于理论，我更倾向于从实践中开始博客，尤其是对于数据绑定。那么，我们先来看看几个简单的例子。 1.数据绑定到TextBox 我们依旧使用前面的闹钟类来开始。在下面的代码中，我们有属性、构造函数，还有一个ToString()方法的重载。之所以重载这个方法是因为我们想在最后绑定的时候，这三个属性能够在TextBox上显示得更加工整。 public class Alarm { public string Title { get ; set ; } public string Description { get ; set ; } public DateTime AlarmTime { get ; set ; } public Alarm () { } public Alarm ( string title, string description,DateTime alarmTime) { Title = title; Description = description; AlarmTime = alarmTime; } public override string ToString () { return "Title: " + Title + "\n" + "Time: " + AlarmTime.ToString( "d" ) + "\n" + "Description: " + Description; } } 接下来再在XAML中添加TextBox控件如下，因为TextBox此时是用作显示而非输入，所以建议设置其的只读属性。数据绑定的核心就是Text属性中的那么一个Binding关键字。 < TextBox x:Name= "textBox1" FontSize = "28" Height= "150" Width= "400" TextWrapping= "Wrap" Text = "{Binding}" IsReadOnly= "True" /> 但是光这样还不够，我们还需要在后台代码中将数据绑定到textBox1的DataContext（数据上下文）中。 textBox1.DataCont

Recno:: 30
URL:: http://blog.csdn.net/nomasp/article/details/50286261

ParseText::
AOJ 0121 Seven Puzzle {广度优先搜索}（*） - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 AOJ 0121 Seven Puzzle {广度优先搜索}（*） 标签： 搜索 移动 广搜 算法 aoj 2015-12-13 20:50 675人阅读 评论 (0) 收藏 举报 分类： AOJ and POJ （4） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 原题 题意 题意是有一个输入，比如： 1 0 2 3 4 5 6 7 摆成如下形状： 1 0 2 3 4 5 6 7 0表示空格，其他数字可以移动到0的位置。最后需要到如下形状： 0 1 2 3 4 5 6 7 上面的这种情况是需要移动一步，也就是0和1直接移动就好。 代码 #include<iostream> #include<string> #include<algorithm> #include<queue> #include<map> using namespace std ; int dx[ 4 ] = { 1 ,- 1 , 4 ,- 4 }; map < string , int > res; void solve( void ) { queue < string > que; que.push( "01234567" ); while (!que.empty()) { string v = que.front(); que.pop(); int pos = 0 ; for ( int i = 0 ; i < 8 ; i++) if (v[i] == '0' )pos = i; for ( int i = 0 ; i < 4 ; i++) { if ( 0 <= pos + dx[i] && pos + dx[i] < 8 && !(pos == 3 && i == 0 ) && !(pos == 4 && i == 1 )) { string u = v; swap(u[pos], u[pos + dx[i]]); if (res[u] == 0 ) { que.push(u); res[u] = res[v] + 1 ; } } } } } int main( void ) { int in; res[ "01234567" ] = 1 ; solve(); while ( true ) { string s; for ( int i = 0 ; i < 8 ; i++) { if (!( cin >> in)) return 0 ; s += in + '0' ; } cout << res[s] - 1 << endl; } return 0 ; } 上一篇 【UWP通用应用开发】集合控件与数据绑定 下一篇 【UWP通用应用开发】编辑文本、绘制图形、3D透视效果及绘制时钟实战 顶 1 踩 0 我的同类文章 AOJ and POJ （4） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577537次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 31
URL:: http://blog.csdn.net/nomasp/article/details/50292375

ParseText::
【UWP通用应用开发】编辑文本、绘制图形、3D透视效果及绘制时钟实战 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【UWP通用应用开发】编辑文本、绘制图形、3D透视效果及绘制时钟实战 标签： 应用 密码 图形 textbox 控件 2015-12-14 11:19 640人阅读 评论 (2) 收藏 举报 分类： UWP （9） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 编辑文本及键盘输入 相信大家都会使用TextBox，但如果要让文本在TextBox中换行该怎么做呢？将TextWrapping属性设置为Wrap，将AcceptsReturn属性设置为True就好咯。 PasswordBox很明显就是一个密码框了，和其他的控件相比其有2个特殊之处，一个是其可以用MaxLength来控制最大的长度，一个是用PasswordChanged来捕捉密码的改名。显然比如QQ密码的MaxLength就是16位了，而PasswordChanged可以用来监测比如用户设置的密码和用户名是否相同。 大家在用电脑或者手机输入时偶尔键盘是出来的26字母拼音或是26字母英文亦或是10个数字对吧，那这个是怎么实现的呢？同样也是很简单的噢！直接在TextBox上用InputScope属性就好啦，比如有Default、TelephoneNumber、EmailSmtpAddress、Url、Search、Chat等可以设置。 除了在XAML中设置InputScope属性外，也可以在后台C#文件中设置。 InputScope inputScope = new InputScope() ; InputScopeName inputScopeName= new InputScopeName() ; inputScopeName .NameValue = InputScopeNameValue .TelephoneNumber ; inputScope .Names .Add (scopeName) ; phoneNumberTtBox .InputScope = scope ; 在这段代码中，phoneNumberTtBox是TextBox的名字哟，或者也可以简写这段代码的： phoneNumberTtBox.InputScope = new InputScope() { Names = { new InputScopeName(InputScopeNameValue.TelephoneNumber)} }; 除此之外，我们还可以给RichEditBox控件设置IsSpellCheckEnabled属性让这个文本控件启用拼写检查。另外值得注意的是TextBox控件的拼写检查只在Windows Phone上启用，在Windows上市禁用的。而文本预测属性在TextBox和RichEditBox以及在Windows和Windows Phone上都是可用的哦，也就是IsTextPredictionEnabled。 情节提要动画与关键帧动画 简单动画示例 因为下面这些Rectangle都是在ItemsControl中的，因为在容器控件中应用主题样式时，其所有的子对象也都会继承下来。 < Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < ItemsControl Grid.Row = "1" x:Name = "itemsControlRectangle" > < ItemsControl.ItemContainerTransitions > < TransitionCollection > < EntranceThemeTransition /> </ TransitionCollection > </ ItemsControl.ItemContainerTransitions > < ItemsControl.ItemsPanel > < ItemsPanelTemplate > < WrapGrid Height = "400" /> </ ItemsPanelTemplate > </ ItemsControl.ItemsPanel > < ItemsControl.Items > < Rectangle Fill = "Red" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Wheat" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Yellow" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Blue" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Green" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Gray" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "White" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Gainsboro" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Magenta" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "CadetBlue" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "NavajoWhite" Width = "100" Height = "100" Margin = "12" /> < Rectangle Fill = "Khaki" Width = "100" Height = "100" Margin = "12" /> </ ItemsControl.Items > </ ItemsControl > </ Grid > 情节提要动画 就像我们前面介绍的定义样式资源一样，我们也可以将动画设为资源。 < Page.Resources > < Storyboard x:Name = "storyboardRectangle" > < DoubleAnimation Storyboard.TargetName = "rectangle" Storyboard.TargetProperty = "Opacity" From = "1.0" To = "0" Duration = "0:0:1" AutoReverse = "True" RepeatBehavior = "Forever" /> </ Storyboard > </ Page.Resources > < Grid > < Rectangle x:Name = "rectangle" Width = "200" Height = "130" Fill = "Blue" /> </ Grid > 在理解这些代码意思之前，还是先让动画跑起来，你可以加上一个Button并设置其Click事件，也可以在MainPage方法下直接写如下代码： storyboardRectangle. Begin (); 运行应用后，Rectangle的透明度就会渐渐的消失而后出现。 在上面这个示例中，我们为Rectangle的Opacity（透明度）属性设置了动画，Storyboard通常存放在 Storyboard .TargetProperty = "(rectangle.Fill).(SolidColorBrush.Color)" 如果你已经定义了TargetName属性为rectangle，那么Fill前的rectangle和点都可以去掉。 左右两个括号都是必要的，它表示一个属性的名称。中间的点意味着要先获取第一个括号的属性，也就是设置动画的对应对象，然后进入到其对象模型中，此处是Color。官网上还给出了其它示例： (UIElement.RenderTransform).(TranslateTransform.X) 应用到RenderTransform上，并创建TranslateTransform的X值的动画 (Shape.Fill).(GradientBrush.GradientStops)[0].(GradientStop.Color) 应用到Fill上，并在LinearGradientBrush的GradientStop内创建Color的动画，这里方括号内的数字表示索引，表示集合中的一项，索引从0开始 (UIElement.RenderTransform).(TransformGroup.Children)[3].(TranslateTransform.X) 应用到RenderTransform上，并创建TranslateTransform 我们还注意到，动画中还有From和To属性，顾名思义，From表示动画的开始值，To表示结束值。 如果没有定义From值，那么动画起始值为该对象属性的当前值。 如果想要设置一个和起始值相对的结束值，建议使用By属性。 动画在这3个属性中至少应该设置一个，否则动画便不会更改值，且这3个属性也无法同时存在。 我们还可以用设置AutoReverse属性为真以使动画才结束后自动进行反向播放，但反向播放完后不会再继续播放。 设置RepeatBehavior属性为“1x”表示动画的播放次数，或者也可以直接设为“Forever”，让其永远播放。 如果动画较多的情况下，我们哈可以设置BeginTime来使不同的动画错开播放。 关键帧动画 什么是关键帧动画？ 关键帧动画建立在上文的情节提要动画概念智商，它令动画沿着一条时间线来逐步达到多个目标值，也就是说如果要让上文的Fill属性从Blue变化到Lime之间还可以令其先变化到Red或Orange等。 更为巧妙的是，你可以同时指定不同的属性来制作复杂的动画。 如果稍微会一点Flash，对于关键帧的概念肯定没有问题。 1.线性关键帧 我们为动画设置一个KeyTime来表示间隔的时间戳，例如我们可以设置4个时间戳为：KeyTime=”0:0:0”、”0:0:2”、”0:0:8”、”0:0:9”，可以看到动画在中间部分时跳跃性非常之大。但其动画都是缓慢变化的，因为这是线性的，还有一种另外一种关键帧它会让动画在时间戳上产生突变而不是渐变，这就是离散式关键帧（就像概率论中的离散型和连续型一样）。 2.样条关键帧 其主要通过KeySpline属性来建立过渡，例如KeySpline=”0.1,0.1 0.7.0.8”，这里有两个点，分别对应贝塞尔曲线的第一个控制点和第二个控制点，描述了动画的加速情况。关于贝塞尔曲线，建议大家看看维基百科，在图形化编程中非常常用。 3.缓动关键帧 这种模式就更加高级了，它由多个预定义好的数学公式来控制。以下是的缓动函数列表来源于网络： BackEase：动画开始在指定路径上运动前稍微收缩动画的运行。 BounceEase：创建回弹效果。 CircleEase：使用圆函数创建加速或减速的动画。 CubicEase：使用函数 f(t) = t3 创建加速或减速的动画。 ElasticEase：创建一个动画，模拟弹簧的来回振荡运动，直到它达到停止状态。 ExponentialEase：使用指数公式创建加速或减速的动画。 PowerEase：使用公式 f(t) = tp 创建加速或减速的动画，其中 p 等于 Power 属性。 QuadraticEase：使用函数 f(t) = t2 创建加速或减速的动画。 QuarticEase：使用函数 f(t) = t4 创建加速或减速的动画。 QuinticEase：使用函数 f(t) = t5 创建加速或减速的动画。 SineEase：使用正弦公式创建加速或减速的动画。 绘制图形 Rectangle 我们开篇先介绍一个之前用过，也是比较简单的Rectangle。简单的矩形就只用定义长和宽了，但如果要有圆角的话呢，用RadiusX和RadiusY就好。那么RadiusX和RadiusY到底是什么呢？看看下图就知道了。 < Rectangle Fill = "Yellow" Width = "300" Height = "200" Stroke = "Blue" StrokeThickness = "10" RadiusX = "80" RadiusY = "40" /> 和Rectangle类似，Border也可以创建矩形，而且后者还可以有自对象以及会自动调整大小，前者只能有固定的大小哦。 Ellipse 看到这个名字大家应该都知道是什么意思吧，如果要定义成圆的话让Height和Width属性相等即可。 那童鞋们都知道ProgressRing是由6个Ellipse组成的吗，RadioButton也是由2个同心的Ellipse组成的哦。 < Ellipse Fill = "Blue" Height = "200" Width = "350" /> Polygon Polygon则显得比较自由，只需要定义出各个顶点，它就会将这些点连接起来。那么我们可能会有疑问，需不需要确定图形的起始点和终点呢？答案是不用的，因为Polygon会自动将终点和起始点连接起来（它会假设图形是闭合的）。 < Polygon Fill= "Green" Points = "0,0,100,0,100,100,0,100 " /> 如果要在后台C#文件中来写的话呢，原本的Point则由PointCollection来定义所有点后添加到一起。 Line Line的使用也比较简单，但有一点要注意，必须设置好Stroke和StrokeThickness的属性值，否则Line就不会显示出来。原因很简单，因为它是直线。 < Line Stroke = "Red" StrokeThickness = "10" X1 = "100" Y1 = "0" Y2 = "400" X2 = "400" /> Path 最后上台的自然是最厉害的啦，先上图。 < Path Stroke = "Gold" StrokeThickness = "7" Data = "M 0,0 C 100,200 50,200 40,150 H 200 V 100 " /> 前两个属性用过多次了，Data却还挺复杂的。这里有3个命令，M、C、H和V。如果按英文来记可能会容易些吧，分别是：Move、Control、Horizontal和Vertical。 那么，重头戏来了，先看图^_^ 接着上代码。 < Path Stroke = "Black" StrokeThickness = "1" Fill = "red" > < Path.Data > < GeometryGroup > < RectangleGeometry Rect = "5,5 180,10" /> < RectangleGeometry Rect = "5,5 95,180" /> < RectangleGeometry Rect = "90,175 95,180" /> < RectangleGeometry Rect = "5,345 180,10" /> < EllipseGeometry Center = "95, 180" RadiusX = "20" RadiusY = "30" /> < PathGeometry > < PathGeometry.Figures > < PathFigureCollection > < PathFigure IsClosed = "true" StartPoint = "50,50" > < PathFigure.Segments > < PathSegmentCollection > < BezierSegment Point1 = "100,180" Point2 = "125,100" Point3 = "150,50" /> </ PathSegmentCollection > </ PathFigure.Segments > </ PathFigure > < PathFigure IsClosed = "true" StartPoint = "40,310" > < PathFigure.Segments > < PathSegmentCollection > < BezierSegment Point1 = "90,180" Point2 = "115,250" Point3 = "140,310" /> </ PathSegmentCollection > </ PathFigure.Segments > </ PathFigure > </ PathFigureCollection > </ PathGeometry.Figures > </ PathGeometry > </ GeometryGroup > </ Path.Data > </ Path > 这张图花了我好久时间呢，希望大家也都会画，虽然作用不大，不过花着玩玩也不错。 我在图上大概加了一些标注啦，另外RectangleGeometry的Rect属性有2个值，后者是相对于前者增加的长度哦。 最难的部分是BezierSegment，也就是贝赛斯曲线，其中StartPoint和Point3分别为起点和终点，而Point1和Point2不是路径哟，只是给曲线的一个参考偏移方向。具体大家可以上维基百科看看。 画笔与图像 画笔想必大家都不陌生，这里系统的介绍一下好了。先来介绍纯色画笔。 纯色画笔 最简单的纯色画笔就是已经定义好名字的啦，比如Red和Green这种，据说一共有256种已命名的，所以基本已经够用啦。XAML解析器会自动将这些颜色名称链接到Color结构。 还有就是传说中的十六进制颜色值，它可以定义精确的24位颜色值，其中有8位用于SolidColorBrush。如下代码所示的，alpha=”FF”，红色=”55”，绿色=”00”，蓝色=”88”。 < Rectangle Width = "200" Height = "100" Fill = "#FF550088" /> 还有一种称为属性元素语法。具体用法如下，其中Opacity就是透明度咯。 < Rectangle Width = "200" Height = "100" > < Rectangle.Fill > < SolidColorBrush Color = "Yellow" Opacity = "0.3" /> </ Rectangle.Fill > </ Rectangle > 渐变画笔 除了纯色画笔外，还有渐变画笔。小时候学PhotoShop的时候最喜欢渐变画笔了。 LinearGradientBrush会沿着一条称为渐变轴直线来进行渐变以绘制一个区域。我们还是拿Rectangle来做示例。 < Rectangle Width = "200" Height = "100" > < Rectangle.Fill > < LinearGradientBrush StartPoint = "0,0" EndPoint = "1,1" > < GradientStop Color = "Green" Offset = "0.0" x:Name = "GradientStop1" /> < GradientStop Color = "Blue" Offset = "0.25" x:Name = "GradientStop2" /> < GradientStop Color = "Wheat" Offset = "0.7" x:Name = "GradientStop3" /> < GradientStop Color = "Yellow" Offset = "0.75" x:Name = "GradientStop4" /> < GradientStop Color = "Gold" Offset = "1.0" x:Name = "GradientStop5" /> </ LinearGradientBrush > </ Rectangle.Fill > </ Rectangle > 通过改变StartPoint和EndPoint的属性值可以创建各种渐变哦，比如垂直和水平方向的渐变，还可以颠倒渐变方向，甚至还可以加快渐变速度呢。 直接添加图片 除了用着两种画笔外，还可以直接将图片添加进来呢。 < Ellipse Height = "100" Width = "200" > < Ellipse.Fill > < ImageBrush ImageSource = "9327.jpg" /> </ Ellipse.Fill > </ Ellipse > 效果如下咯，主要是有一张合适的图片啦。 既然用到了ImageBrush，那就来看看Image和ImageBrush的区别好了。前者主要用来呈现图像，后者则为其他对象绘制为一个图像。 Stretch属性 对于Image，我们可以来拉伸图像，也就是Stretch属性： None：图像不经过拉伸。如果源图像比所留给Image的区域大，那么就会被剪切。 Uniform：按照纵横比来缩放图像。 UniformToFill：按照纵横比来填满所有区域，这意味着可能会有一部分不可见。 Fill。因为不保留纵横比而填满屏幕，所以图像部分全部可见，但会产生画面变形（失真）。 具体效果见下图（来源于网络）。 Clip属性 用Clip属性可以对图像进行剪裁，Rect属性在上一篇博客中用过许多次，前2个值为起始点的X轴和Y轴坐标，后2个值为终点的X轴和Y轴坐标。 < Image Source= "9327.jpg" > < Image . Clip > <RectangleGeometry Rect= "10,10,100,100" /> </ Image . Clip > </ Image > Image和ImageBrush能处理的图像格式有如下几种： JPEG XR 图标（ICO） 位图（BMP） 图像交换格式（GIF） 联合图像专家组（JPEG） 可移植网络图像（PNG） 标记图像文件格式（TIEF） 3D透视效果 原图如下： 首先是布局代码： < Grid > < Image Name = "Image1" Source = "ms.png" > </ Image > < Button Height = "50" BorderThickness = "2" Click = "btnClick1" Width = "100" Content = "Add X" Margin = "34,0,226,40" VerticalAlignment = "Bottom" HorizontalAlignment = "Stretch" /> < Button Height = "50" BorderThickness = "2" Click = "btnClick2" Width = "100" Content = "Add Y" Margin = "146,0,128,37" VerticalAlignment = "Bottom" HorizontalAlignment = "Stretch" /> < Button Height = "50" BorderThickness = "2" Click = "btnClick3" Width = "100" Content = "Add Z" Margin = "243,0,31,37" VerticalAlignment = "Bottom" HorizontalAlignment = "Stretch" /> </ Grid > 这里我通过点击按钮让X、Y、Z旋转，当然你也可以设定一个定时器，这样就可以让他一直旋转了。 public sealed partial class MainPage : Page { private double x = 0 ; private double y = 0 ; PlaneProjection p = new PlaneProjection(); public MainPage () { this .InitializeComponent(); } private void btnClick1 ( object sender, RoutedEventArgs e) { p.RotationX += 9.0 ; Image1.Projection = p; } private void btnClick2 ( object sender, RoutedEventArgs e) { p.RotationY += 4.0 ; Image1.Projection = p; } private void btnClick3 ( object sender, RoutedEventArgs e) { p.RotationZ += 2.0 ; Image1.Projection = p; } } 效果图： 实战：用UserControl来绘制时钟 首先你需要添加一个User Control文件，如图： 整个文件我都列了出来： < UserControl x:Class = "App86.MyUserControl1" xmlns = "http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x = "http://schemas.microsoft.com/winfx/2006/xaml" xmlns:local = "using:App86" xmlns:d = "http://schemas.microsoft.com/expression/blend/2008" xmlns:mc = "http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable = "d" Height = "389.396" Width = "403.221" > < UserControl.Resources > < Storyboard x:Name = "clockStoryboard" > < DoubleAnimation x:Name = "hourAnimation" Storyboard.TargetName = "hourHandTransform" Storyboard.TargetProperty = "Angle" Duration = "12:0:0" RepeatBehavior = "Forever" To = "360" /> < DoubleAnimation x:Name = "minuteAnimation" Storyboard.TargetName = "minuteHandTransform" Storyboard.TargetProperty = "Angle" Duration = "1:0:0" RepeatBehavior = "Forever" To = "360" /> < DoubleAnimation x:Name = "secondAnimation" Storyboard.TargetName = "secondHandTransform" Storyboard.TargetProperty = "Angle" Duration = "0:1:0" RepeatBehavior = "Forever" To = "360" /> </ Storyboard > </ UserControl.Resources > < Grid x:Name = "LayoutRoot" Background = "White" Loaded = "SetAndStartClock" > < Ellipse x:Name = "shadowEllipse" Fill = "#FF00000A" HorizontalAlignment = "Left" Height = "330" Margin = "36,37,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "330" Opacity = "0.3" /> < Ellipse x:Name = "outerRimEllipse" HorizontalAlignment = "Left" Height = "330" Margin = "29,31,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "330" > < Ellipse.Fill > < LinearGradientBrush EndPoint = "0.816,0.888" MappingMode = "RelativeToBoundingBox" StartPoint = "0.184,0.112" > < GradientStop Color = "Black" Offset = "0" /> < GradientStop Color = "Silver" Offset = "0.731" /> </ LinearGradientBrush > </ Ellipse.Fill > </ Ellipse > < Ellipse x:Name = "bevelEllipse" HorizontalAlignment = "Left" Height = "290" Margin = "50,51,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "290" > < Ellipse.Fill > < LinearGradientBrush EndPoint = "0.816,0.888" MappingMode = "RelativeToBoundingBox" StartPoint = "0.184,0.112" > < GradientStop Color = "#FF2F2F32" Offset = "0" /> < GradientStop Color = "#FFB6B6B6" Offset = "0.731" /> < GradientStop Color = "#FFE4E5F4" Offset = "1" /> </ LinearGradientBrush > </ Ellipse.Fill > </ Ellipse > < Ellipse x:Name = "faceEllipse" HorizontalAlignment = "Left" Height = "270" Margin = "60,62,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "270" Fill = "Black" /> < Ellipse x:Name = "centerEllipse" Fill = "Black" HorizontalAlignment = "Left" Height = "30" Margin = "180,182,0,0" Stroke = "#FF57F010" VerticalAlignment = "Top" Width = "30" StrokeThickness = "8" /> < Rectangle x:Name = "secondHand" Fill = "#FFF11600" HorizontalAlignment = "Left" Height = "80" Margin = "193,93,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "5" RenderTransformOrigin = "0.45,1.3" > < Rectangle.RenderTransform > < RotateTransform x:Name = "secondHandTransform" /> </ Rectangle.RenderTransform > </ Rectangle > < Rectangle x:Name = "minuteHand" Fill = "#FF3BF006" HorizontalAlignment = "Left" Height = "80" Margin = "191,92,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "9" RenderTransformOrigin = "0.45,1.3" > < Rectangle.RenderTransform > < RotateTransform x:Name = "minuteHandTransform" /> </ Rectangle.RenderTransform > </ Rectangle > < Rectangle x:Name = "hourHand" Fill = "#FF20F017" HorizontalAlignment = "Left" Height = "66" Margin = "190,105,0,0" Stroke = "Black" VerticalAlignment = "Top" Width = "11" RenderTransformOrigin = "0.45,1.4" > < Rectangle.RenderTransform > < RotateTransform x:Name = "hourHandTransform" /> </ Rectangle.RenderTransform > </ Rectangle > </ Grid > </ UserControl > 如你看到的那样，一开始是样式资源，它是一个Storyboard，这里设置了3个指针的走法，都是旋转360度且一直循环。 后面则是相关的Rectangle等，当然了，这些不可能一次性写完，你得慢慢测试才可以。 VS的优势在于你可以拖动控件，以后有机会我再写一篇介绍如何使用Blend的博客，这里就不详细说明了。 在MyUserControl1.xaml.cs文件中，写一个方法： private void SetAndStartClock(object sender, RoutedEventArgs routedEventArgs) { System .DateTime currentDate = DateTime .Now ; double hourangle = (((float)currentDate .Hour ) / 12 ) * 360 + currentDate .Minute / 2 ; double minangle = (((float)currentDate .Minute ) / 60 ) * 360 ; double secangle = (((float)currentDate .Second ) / 60 ) * 360 ; hourAnimation .From = hourangle ; hourAnimation .To = hourangle + 360 ; minuteAnimation .From = minangle ; minuteAnimation .To = minangle + 360 ; secondAnimation .From = secangle ; secondAnimation<

Recno:: 32
URL:: http://blog.csdn.net/nomasp/article/details/50310357

ParseText::
【UWP通用应用开发】文件选取器、获取文件属性、写入和读取、保存读取和删除应用数据 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【UWP通用应用开发】文件选取器、获取文件属性、写入和读取、保存读取和删除应用数据 标签： windows 应用 数据 app xaml 2015-12-15 09:01 575人阅读 评论 (0) 收藏 举报 分类： UWP （9） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 读取文件和文件夹名 这一节开始我们将陆续看到UWP通用应用是如何获取到文件及文件夹的属性等信息，以及如何写入和读取数据等，当然了最重要的还是如何保存读取和删除应用的数据。 在Windows上读取文件名、文件夹名 首先我们在XAML中定义一个Button和TextBlock，将读取文件/文件夹名的过程写在前者的click事件中，后者则用来显示文件信息。 < Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < StackPanel Orientation = "Horizontal" > < Button Name = "btnGetName" Width = "200" Height = "100" Content = "读取文件名" Click = "btnGetName_Click" /> < TextBlock Name = "textBlockFileName" Width = "500" Height = "300" FontSize = "30" Margin = "12" /> </ StackPanel > </ Grid > 以下这段代码，首先通过StorageFolder类读取图片库，然后使用异步的方式将图片库的文件和文件夹信息载入相应的List中。新建一个StringBuilder用以保存这些文件的信息，在这里只是使用了文件/文件夹的Name属性，但属性还有很多，比如Path属性。最后再将这些获取到的信息赋值给TextBlock即可。 private async void btnGetName_Click ( object sender, RoutedEventArgs e) { StorageFolder pictureFolder = KnownFolders.PicturesLibrary; IReadOnlyList<StorageFile> pictureFileList = await pictureFolder.GetFilesAsync(); IReadOnlyList<StorageFolder> pictureFolderList = await pictureFolder.GetFoldersAsync(); StringBuilder picutreFolderInfo = new StringBuilder(); foreach (StorageFile f in pictureFileList) { picutreFolderInfo.Append(f.Name+ "\n" ); } foreach (StorageFolder f in pictureFolderList) { picutreFolderInfo.Append(f.Name+ "\n" ); } textBlockFileName.Text = picutreFolderInfo.ToString(); } 注意要在方法名前面加上async哦。还有要在清单文件中声明我们的应用要使用图片库哦，一会在Windows Phone中也一样。 在Windows Phone上读取文件名、文件夹名 后台代码不用做任何修改，只需把XAML代码修改修改以适应屏幕即可~ < Grid > < StackPanel Orientation = "Vertical" > < Button Name = "btnGetName" Width = "150" Height = "70" HorizontalAlignment = "Center" Content = "读取文件名" Click = "btnGetName_Click" /> < TextBlock Name = "textBlockFileName" Width = "300" Height = "300" FontSize = "30" Margin = "12" TextWrapping = "Wrap" /> </ StackPanel > </ Grid > 读取文件名的其他方法 private async void btnGetName_Click ( object sender, RoutedEventArgs e) { StorageFolder picutureFolder = KnownFolders.PicturesLibrary; StringBuilder pictureFolderInfo = new StringBuilder(); IReadOnlyList<IStorageItem> pictureFileItem = await picutureFolder.GetItemsAsync(); foreach ( var i in pictureFileItem) { if (i is StorageFolder) pictureFolderInfo.Append(i.Name + "\n" ); else pictureFolderInfo.Append(i.Name + "\n" ); } textBlockFileName.Text = pictureFolderInfo.ToString(); } 文件选取器 使用文件选取器保存文件 就我个人而言，还是非常喜欢使用文件选取器的，因为能够用自己的代码来调用系统的各种弹框。 在这个示例中，首先在XAML中添加一个Button和一个TextBlock，分别命名为btnSaveFile和tBlockSaveInfo。对于这个保存文件这个操作在后台的Click事件中就可以轻易完成了。 private async void btnSaveFile_Click ( object sender, RoutedEventArgs e) { FileSavePicker saveFile = new FileSavePicker(); saveFile.SuggestedStartLocation = PickerLocationId.DocumentsLibrary; // 显示在下拉列表的文件类型 saveFile.FileTypeChoices.Add( "批处理文件" , new List< string >() { ".bat" }); // 默认的文件名 saveFile.SuggestedFileName = "SaveFile" ; StorageFile file = await saveFile.PickSaveFileAsync(); if (file!= null ) { // 在用户完成更改并调用CompleteUpdatesAsync之前，阻止对文件的更新 CachedFileManager.DeferUpdates(file); string fileContent = "@echo off \n dir/s \n pause" ; await FileIO.WriteTextAsync(file, fileContent); // 当完成更改时，其他应用程序才可以对该文件进行更改。 FileUpdateStatus updateStatus = await CachedFileManager.CompleteUpdatesAsync(file); if (updateStatus==FileUpdateStatus.Complete) { tBlockSaveInfo.Text = file.Name + " 已经保存好了。" ; } else { tBlockSaveInfo.Text = file.Name + " 保存失败了。" ; } } else { tBlockSaveInfo.Text = "保存操作被取消。" ; } } 代码中的下拉列表的文件类型就是如下所示这个样子哟。 大部分的内容我都已经通过注释的方式添加到代码中了，至于fileContent的那段代码到底是什么意思，大家试试就知道了，我感觉蛮有意思的。 3行代码列出硬盘上所有文件及文件夹 如果大家试过打开这个bat文件，有没有觉得有趣呢？ 更厉害的是，我们刚才所写的代码可以在Windows Phone上不经修改而直接使用。我的Lumia 638已经刷上了Windows 10预览版，大家可以瞧瞧，全新的资源管理器。 使用文件选取器打开文件 和用文件选取器保存文件相类似，打开文件的逻辑都差不多。这个示例中同样在XAML中定义一个名为btnOpenFile的Button和一个名为tBlockOpenInfo的TextBlock。 private async void btnOpenFile_Click ( object sender, RoutedEventArgs e) { FileOpenPicker openFile = new FileOpenPicker(); openFile.SuggestedStartLocation = PickerLocationId.DocumentsLibrary; openFile.ViewMode = PickerViewMode.List; openFile.FileTypeFilter.Add( ".txt" ); openFile.FileTypeFilter.Add( ".docx" ); openFile.FileTypeFilter.Add( ".pptx" ); // 选取单个文件 StorageFile file = await openFile.PickSingleFileAsync(); if (file != null ) { tBlockOpenInfo.Text = "你所选择的文件是： " + file.Name; } else { tBlockOpenInfo.Text = "打开文件操作被取消。" ; } // 选择多个文件 //IReadOnlyList<StorageFile> fileList = await openFile.PickMultipleFilesAsync(); //StringBuilder fileOpenInfo = new StringBuilder(); //if(fileList!=null) //{ // foreach( StorageFile f in fileList) // { // fileOpenInfo.Append(f.Name + "\n"); // } // tBlockOpenInfo.Text = "你所选择的文件是： "+"\n"+ fileOpenInfo.ToString(); //} //else //{ // tBlockOpenInfo.Text = "打开文件操作被取消。"; //} } 我已经将选取多个文件的代码也列了出来，只需要取消注释即可。像ViewMode和FileTypeFilter这种属性，看看名字应该都知道了吧。重在实践。 在手机上也是通用的，刚才我试过了，成功进入了资源管理器，不过没能打开文件。应该是因为预览版的原因，这个预览版连Office都被移除了，估计会在下一版中添加通用版的Office应用。 写入和读取 准备工作 在XAML中添加一个TextBlock用于显示相关信息，添加一个Button来使用它的Click事件，当然了，最后分别创建2个。 创建文件和读取文件 1.实例化StorageFolder类 我们的文件不可能让其随意保存在计算机/手机中的任何一个地方，应该先确定它的文件夹，对吧？ 在新的Windows 8中，微软开启了Windows上的App时代，下载的软件再也不能随意安装到任何地方了，而是由操作系统统一放到一块叫做“独立存储”的地方。这也是出于安全的考虑。用过Windows Phone 8的朋友应该更加清楚了。 那么下面这行代码的LocalFolder究竟在哪里呢？ StorageFolder folder = Windows .Storage .ApplicationData .Current .LocalFolder ; 下图中的文件，就是我当前所写的App。（补充一条哦，一开始我装了Win8后，下载了一个游戏，模拟类的，有金币呀什么的，后来我找到这个App的文件，将数据改了之后金币就哗哗的啦。当然了，对于其他单机而言这个完全不值一提，但App的数据，相信还有很多人没有改过吧。） 那么这张图中的红方框的文件夹就是LocalFolder啦，下面还有一个存储漫游文件的文件夹。 不论是读取文件还是写入文件，都得先确定一个文件夹哦。 2.实例化StorageFile 确定了文件夹，就得确定文件咯。对于创建文件而言，执行以下代码。既然用到了异步，在函数上加上async是必不可少的咯，这一点我们在前面讲到过。后面的ReplaceExisting属性是指的，如果该文件（名）已经存在了，则替换它。 StorageFile file = await folder .CreateFileAsync ( "New Document.txt" , CreationCollisionOption .ReplaceExisting ) ; 那么对于读取文件呢，就直接读取好啦。 StorageFile file = await folder.GetFileAsync( "sample.txt" ); 3.创建和读取文件 将文本写入文件按照如下代码，将文件名和文本内容（字符串）。 await FileIO.WriteTextAsync(file, "Write text to file." ); 读取文件也是类似的。 string text = await FileIO.ReadTextAsync( file ); 我们还可以将这个读取的字符串传递给前面定义的TextBlock来加以调试。以下是完整的代码。 // 创建文件 StorageFolder folder = Windows .Storage .ApplicationData .Current .LocalFolder ; StorageFile file = await folder .CreateFileAsync ( "New Document.txt" , CreationCollisionOption .ReplaceExisting ) ; await FileIO .WriteTextAsync (file, "Write text to file." ) ; // 2 从文本读取文件 StorageFolder folder = Windows .Storage .ApplicationData .Current .LocalFolder ; StorageFile file = await folder .GetFileAsync ( "sample.txt" ) ; string text = await Windows .Storage .FileIO .ReadTextAsync (file) ; tBlockReadInfo .Text = text ; 使用缓冲区将字节写入到文件或从文件读取字节 1.实例化StorageFolder类 同上。 2.实例化StorageFile 同上。 3.将字节写入到文件 a.建立缓冲区 var buffer = Windows .Security .Cryptography .CryptographicBuffer .ConvertStringToBinary ( "There's buffer ...... " , Windows .Security .Cryptography .BinaryStringEncoding .Utf 8) ; b.将缓冲区中的字节写入到文件 await Windows .Storage .FileIO .WriteBufferAsync (file, buffer) ; 4.从文件读取字节 a.将文件加载到缓冲区 var buffer = await Windows .Storage .FileIO .ReadBufferAsync (file) ; b.实例化DataReader，读取缓冲区 DataReader dataReader = Windows .Storage .Streams .DataReader .FromBuffer (buffer) ; c.从DataReader对象中读取字符串 string text = dataReader.ReadString(buffer.Length); 使用流将文本写入文件或从文件读取文本 1.实例化StorageFolder类 同上。 2.实例化StorageFile 同上。 3.新建流，并异步地将file打开，使用可读写的方式 var stream = await file .OpenAsync (Windows .Storage .FileAccessMode .ReadWrite ) ; 4.将文本写入到文件 a.使用using using ( var writeStream = stream . GetOutputStreamAt( 0 )) { ... ... } b.（在using语句的花括号内）创建DataWriter对象，并调用DataWriter.WriteString方法，将文本写入到writeStream中 DataWriter dataWriter = new DataWriter(writeStream); dataWriter.WriteString( "Stream is a good thing." ); c.将文本保存到文件中，并通过StoreAsync和FlushAsync方法存储和关闭流 await dataWriter.StoreAsync(); await writeStream.FlushAsync(); 5.从文件读取文本 a.获取该流的size var size = stream.Size; b.使用using using ( var readStream = stream . GetOutputStreamAt( 0 )) { ... ... } c.（在using语句的花括号内）创建DataWriter对象，并调用LoadAsync方法，最后调用ReadString即可。最后还可以将信息输出到TextBlock中。 DataReader dataReader = new DataReader(readStream); uint uintBytes = await dataReader.LoadAsync(( uint )size); string text = dataReader.ReadString(uintBytes); tBlockReadInfo.Text = text; 获取文件属性 这一节来看看获取文件属性吧，可以获取到文件名、类型、最近访问时间等等属性。 创建Button和TextBlock 下面这段代码呢，都很简单。 < Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < StackPanel Orientation = "Horizontal" HorizontalAlignment = "Center" VerticalAlignment = "Center" > < Button Width = "200" Height = "70" Name = "btnGetProp" Content = "获取文件属性" Click = "btnGetProp_Click" /> < TextBlock Name = "tBlockProp" Margin = "12" Width = "480" FontSize = "30" /> </ StackPanel > </ Grid > </ Page > 在Click事件中，先获取到图片库，当然了，你可以获取其他地方，我电脑上的库文件中，就只有文档库和图片库有文件了。然后创建一个文件查询，最后将这些文件都赋给files。这里的var可谓是非常的强大啊。实例化一个StringBuilder对象来辅助输出信息那真是太完美不过了，我们在前面也常用到它。 var folder = KnownFolders .PicturesLibrary ; var fileQuery = folder .CreateFileQuery () ; var files = await fileQuery .GetFilesAsync () ; StringBuilder fileProperties = new StringBuilder() ; for (int i = 0 ; i < files.Count; i++) { StorageFile file = files[i] ; fileProperties .AppendLine ( "File name: " + file .Name ) ; fileProperties .AppendLine ( "File type: " + file .FileType ) ; BasicProperties basicProperties = await file .GetBasicPropertiesAsync () ; string fileSize = string .Format ( "{0:n0}" , basicProperties .Size ) ; fileProperties .AppendLine ( "File size: " + fileSize + " bytes" ) ; fileProperties .AppendLine ( "Date modified: " + basicProperties .DateModified ) ; fileProperties .AppendLine ( " " ) ; } tBlockProp .Text = fileProperties .ToString () ; 这样一来就完成对Name、FileType、Size和DateModified属性的获取，但还有一类属性，则比较难以获取，它们就是“扩展属性”。 List< string > propertiesName = new List< string >(); propertiesName.Add( "System.DateAccessed" ); propertiesName.Add( "System.FileOwner" ); IDictionary< string , object > extraProperties = await file.Properties.RetrievePropertiesAsync(propertiesName); var propValue = extraProperties[dateAccessedProperty]; if (propValue != null ) fileProperties.AppendLine( "Date accessed: " + propValue); propValue = extraProperties[fileOwnerProperty]; if (propValue != null ) fileProperties.AppendLine( "File owner: " + propValue); 最后将fileProperties传递给TextBlock即可。 tBlockProp. Text = fileProperties. ToString (); 最后调试App，就会像下图一样了。 但是如你所见，文件名太长了却无法自动换行，而且数据也显示不完整。改改XAML中的TextBlock即可。TextWrapping属性设置为Wrap，则可以换行；将TextBlock添加到ScrollViewer内则会显示出一个滚动条。 < Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < StackPanel Orientation = "Horizontal" HorizontalAlignment = "Center" VerticalAlignment = "Center" > < Button Width = "200" Height = "70" Name = "btnGetProp" Content = "获取文件属性" Click = "btnGetProp_Click" /> < ScrollViewer > < TextBlock Name = "tBlockProp" Margin = "12" Width = "480" FontSize = "30" TextWrapping = "Wrap" /> </ ScrollViewer > </ StackPanel > </ Grid > 保存、读取、删除应用数据 在前面的几节中，都是关于数据的，这方面的内容其实还有很多很多，省略掉一部分后，也还是有很多。这一节是很重要的一部分，它关于如何保存和读取数据。 先来看看一个大概的背景吧，我这里写的很简单啦。 保存的内容就是这四个框框里填写的数据咯。先上XAML代码。 < Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}" > < StackPanel Orientation = "Horizontal" HorizontalAlignment = "Center" VerticalAlignment = "Center" > < StackPanel Orientation = "Vertical" > < Rectangle Name = "recRed" Width = "200" Height = "200" Fill = "Red" /> < Rectangle Name = "recGreen" Width = "100" Height = "400" Fill = "Green" /> </ StackPanel > < StackPanel Orientation = "Vertical" > < StackPanel Orientation = "Horizontal" > < StackPanel Orientation = "Vertical" > < TextBlock Text = "红色矩形的长" FontSize = "25" Margin = "12" Width = "150" Height = "50" /> < TextBlock Text = "红色矩形的宽" FontSize = "25" Margin = "12" Width = "150" Height = "50" /> < TextBlock Text = "绿色矩形的长" FontSize = "25" Margin = "12" Width = "150" Height = "50" /> < TextBlock Text = "绿色矩形的宽" FontSize = "25" Margin = "12" Width = "150" Height = "50" /> </ StackPanel > < StackPanel Orientation = "Vertical" > < TextBox Name = "tBoxRedHeight" FontSize = "25" Width = "150" Height = "50" Margin = "12" /> < TextBox Name = "tBoxRedWidth" FontSize = "25" Width = "150" Height = "50" Margin = "12" /> < TextBox Name = "tBoxGreenHeight" FontSize = "25" Width = "150" Height = "50" Margin = "12" /> < TextBox Name = "tBoxGreenWidth" FontSize = "25" Width = "150" Height = "50" Margin = "12" /> </ StackPanel > </ StackPanel > < StackPanel Orientation = "Horizontal" HorizontalAlignment = "Center" VerticalAlignment = "Center" > < Button Width = "150" Height = "70" Name = "btnSaveAppData" Click = "btnSaveAppData_Click" Content = "保存应用数据" /> < Button Width = "150" Height = "70" Name = "btnReadAppData" Click = "btnReadAppData_Click" Content = "读取应用数据" /> </ StackPanel > </ StackPanel > </ StackPanel > </ Grid > 单个设置 先来看看单个设置呗，下面就是代码咯。 Windows .Storage .ApplicationDataContainer localSettings = Windows .Storage .ApplicationData .Current .LocalSettings ; Windows .Storage .StorageFolder localFolder = Windows .Storage .ApplicationData .Current .LocalFolder ; public MainPage() { this .InitializeComponent () ; } private void btnSaveAppData_Click(object sender, RoutedEventArgs e) { localSettings .Values [ "RectangleRedHeight" ] = tBoxRedHeight .Text ; localSettings .Values [ "RectangleRedWidth" ] = tBoxRedWidth .Text ; localSettings .Values [ "RectangleGreenHeight" ] = tBoxGreenHeight .Text ; localSettings .Values [ "RectangleGreenWidth" ] = tBoxGreenWidth .Text ; } private void btnReadAppData_Click(object sender, RoutedEventArgs e) { Object objRectangleRedHeight = localSettings .Values [ "RectangleRedHeight" ] ; Object objRectangleRedWidth = localSettings .Values [ "RectangleRedWidth" ] ; Object objRectangleGreenHeight = localSettings .Values [ "RectangleGreenHeight" ] ; Object objRectangleGreenWidth = localSettings .Values [ "RectangleGreenWidth" ] ; recRed .Height = double .Parse (objRectangleRedHeight .ToString ()) ; recRed .Width = double .Parse (objRectangleRedWidth .ToString ()) ; recGreen .Height = double .Parse (objRectangleGreenHeight .ToString ()) ; recGreen .Width = double .Parse (objRectangleGreenWidth .ToString ()) ; } 首先定义了两个全局变量，如果看过前面几篇文章，这个应该就非常清楚了。顾名思义，第一个是用来保存本地设置的，第二个则是用来访问本地文件夹的。这里是单个设置地进行保存的，后面还有2种方式。那么就来调试吧，注意在点击了保存数据按钮之后把App关掉哦，关掉之后再加载，这样才算是保存了应用数据嘛，你说对不对呢？ 以下就是我的测试结果了。 复合设置 我们的设计都不用变，后台代码修改如下。 Windows .Storage .ApplicationDataContainer localSettings = Windows .Storage .ApplicationData .Current .LocalSettings ; Windows .Storage .StorageFolder localFolder = Windows .Storage .ApplicationData .Current .LocalFolder ; public MainPage() { this .InitializeComponent () ; } private void btnSaveAppData_Click(object sender, RoutedEventArgs e) { Windows .Storage .ApplicationDataCompositeValue compositeSettings = new ApplicationDataCompositeValue() ; compositeSettings[ "RectangleRedHeight" ] = tBoxRedHeight .Text ; compositeSettings[ "RectangleRedWidth" ] = tBoxRedWidth .Text ; compositeSettings[ "RectangleGreenHeight" ] = tBoxGreenHeight .Text ; compositeSettings[ "RectangleGreenWidth" ] = tBoxGreenWidth .Text ; localSettings .Values [ "RectangleSettings" ] = compositeSettings ; } private async void btnReadAppData_Click(object sender, RoutedEventArgs e) { Windows .Storage .ApplicationDataCompositeValue compositeSettings = (Windows .Storage .ApplicationDataCompositeValue )localSettings .Values [ "RectangleSettings" ] ; if (compositeSettings == null) { Windows .UI .Popups .MessageDialog messageDialog = new Windows .UI .Popups .MessageDialog ( "你好像没有保存任何应用数据哦！" ) ; await messageDialog .ShowAsync () ; } else { recRed .Height = double .Parse (compositeSettings[ "RectangleRedHeight" ] .ToString ()) ; recRed .Width = double .Parse (compositeSettings[ "RectangleRedWidth" ] .ToString ()) ; recGreen .Height = double .Parse (compositeSettings[ "RectangleGreenHeight" ] .ToString ()) ; recGreen .Width = double .Parse (compositeSettings[ "RectangleGreenWidth" ] .ToString ()) ; } } 使用ApplicationDataCompositeValue 会创建一个复合设置，通过代码所示方式即可添加数据，最后会将其添加到localSettings中。 读取数据的时候，同样是先在localSettings中通过键值对的方式来取出这个复合设置。如果该设置为空，就会调用MessageDialog控件弹窗通知没有保存数据。对于这个控件，可以访问这里： 【万里征程——Windows App开发】控件大集合2 。如果复合设置存在则将他们分别进行类型转换后复制给相应的矩形的属性。 在容器中存放数据 在容器存放数据其实也就这么回事啦，无非就是先创建一个容器，然后如果创建成功了，就在其中添加相应的数据即可。 至于加载数据，在这里我使用了一个bool变量来检查容器是不是已经创建好了，如果创建好了就可以将相应的数据取出然后赋值了，如果没有的话则一样挑出弹窗。 Windows .Storage .ApplicationDataContainer localSettings = Windows .Storage .ApplicationData .Current .LocalSettings ; Windows .Storage .StorageFolder localFolder = Windows .Storage .ApplicationData .Current .LocalFolder ; public MainPage() { this .InitializeComponent () ; } private void btnSaveAppData_Click(object sender, RoutedEventArgs e) { Windows .Storage .ApplicationDataContainer containerSettings = localSettings .CreateContainer ( "RecSettingsContainer" , Windows .Storage .ApplicationDataCreateDisposition .Always ) ; if (localSettings .Containers .ContainsKey ( "RecSettingsContainer" )) { localSettings .Containers [ "RecSettingsContainer" ] .Values [ "RectangleRedHeight" ] = tBoxRedHeight .Text ; localSettings .Containers [ "RecSettingsContainer" ] .Values [ "RectangleRedWidth" ] = tBoxRedWidth .Text ; localSettings .Containers [ "RecSettingsContainer" ] .Values [ "RectangleGreenHeight" ] = tBoxGreenHeight .Text ; localSettings .Containers [ "RecSettingsContainer" ] .Values [ "RectangleGreenWidth" ] = tBoxGreenWidth .Text ; } } private async void btnReadAppData_Click(object sender, RoutedEventArgs e) { bool hasContainerSettings = localSettings .Containers .ContainsKey ( "RecSettingsContainer" ) ; if(hasContainerSettings) { recRed .Height = double .Parse (localSettings .Containers [ "RecSettingsContainer" ] .Values [ "Re

Recno:: 33
URL:: http://blog.csdn.net/nomasp/article/details/50310843

ParseText::
【UWP通用应用开发】集成搜索、粘贴板以及设置共享源和共享目标 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【UWP通用应用开发】集成搜索、粘贴板以及设置共享源和共享目标 标签： 搜索 共享 粘贴板 UWP 应用 2015-12-15 09:45 567人阅读 评论 (0) 收藏 举报 分类： UWP （9） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 在应用中集成搜索 上一节是关于如何添加应用设置和帮助，这一篇讲的是和设置类似的搜索。 So…… Let’s do it ! 先从简单的页面布局开始，想想我们需要什么，一个带搜索事件的Button，还需要一些TextBlock来提示用户，核心部分自然是一个GridView咯。 < Grid Background = "Wheat" > < Grid.RowDefinitions > < RowDefinition Height = "Auto" /> < RowDefinition /> </ Grid.RowDefinitions > < StackPanel Grid.Row = "0" Orientation = "Vertical" > < Button Grid.Row = "0" Name = "btnSearch" VerticalAlignment = "Center" HorizontalAlignment = "Left" Content = "搜索" FontFamily = "华文行楷" Click = "btnSearch_Click" Margin = "12" FontSize = "34" Foreground = "Red" /> < StackPanel Orientation = "Horizontal" > < TextBlock Text = "搜索关键词" Foreground = "Green" FontSize = "28" Margin = "12" /> < TextBlock FontSize = "28" Foreground = "Green" Name = "tBlockKeyword" Margin = "12" /> </ StackPanel > </ StackPanel > < GridView Grid.Row = "1" Margin = "12" x:Name = "gridView" > < GridView.ItemsPanel > < ItemsPanelTemplate > < WrapGrid Orientation = "Horizontal" /> </ ItemsPanelTemplate > </ GridView.ItemsPanel > < GridView.ItemTemplate > < DataTemplate > < TextBlock Text = "{Binding}" FontSize = "24" Foreground = "Pink" FontFamily = "楷体" /> </ DataTemplate > </ GridView.ItemTemplate > </ GridView > </ Grid > 既然界面完成了，就该去后台捣鼓咯。搜索的核心在于SearchPane，所以先来实例化它。为了简化，我们就将待搜索的内容设置为一串字符串数组好了，当然了，初始化数组的方式大家随意就好了。 SearchPane searchPane = null ; string [] exampleStr = new string [ 100 ]; public void InitExampleStr () { Random ran = new Random(); int exNumber; for ( int i= 0 ;i< 100 ;i++) { exNumber = ran.Next( 1000 , 9999 ); exampleStr[i] = exNumber.ToString(); } } 当用户在搜索框中输入的内容发生了更改时就会触发searchPane_QueryChange事件。 当用户在完成输入后按下Enter键或者点击旁边的搜索确认按钮后就会触发searchPane_QuerySubmitted事件。 void searchPane_QueryChanged(SearchPane sender, SearchPaneQueryChangedEventArgs args) { this .tBlockKeyword .Text = args .QueryText ; } void searchPane_QuerySubmitted(SearchPane sender, SearchPaneQuerySubmittedEventArgs args) { string key = args .QueryText ; var result = exampleStr .Where (s => s .Contains (key)) .ToArray () ; this .gridView .ItemsSource = result ; } 然后我们还需要这两个事件在OnNavigatedTo中绑定以及在OnNavigatedFrom中解绑。 protected override void OnNavigatedTo (NavigationEventArgs e) { this .searchPane.QuerySubmitted += searchPane_QuerySubmitted; this .searchPane.QueryChanged += searchPane_QueryChanged; } protected override void OnNavigatedFrom (NavigationEventArgs e) { this .searchPane.QuerySubmitted -= searchPane_QuerySubmitted; this .searchPane.QueryChanged -= searchPane_QueryChanged; } 然后我们需要点击Button控件来调出系统的搜索框，一行代码就足以搞定了。如果不想点击按钮也是可以得哦，可以让用户直接在键盘输入而调出搜索框呢。 private void btnSearch_Click ( object sender, RoutedEventArgs e) { this .searchPane.Show(); } this .searchPane.ShowOnKeyboardInput = true ; 最后别忘了将他们都放到MainPage()中哦， public MainPage () { this .InitializeComponent(); searchPane = SearchPane.GetForCurrentView(); InitExampleStr(); this .searchPane.PlaceholderText = "请输入关键字" ; this .searchPane.ShowOnKeyboardInput = true ; } 所以说，总的代码是这样的。 SearchPane searchPane = null ; string [] exampleStr = new string [ 100 ]; public MainPage () { this .InitializeComponent(); searchPane = SearchPane.GetForCurrentView(); InitExampleStr(); this .searchPane.PlaceholderText = "请输入关键字" ; this .searchPane.ShowOnKeyboardInput = true ; } public void InitExampleStr () { Random ran = new Random(); int exNumber; for ( int i= 0 ;i< 100 ;i++) { exNumber = ran.Next( 1000 , 9999 ); exampleStr[i] = exNumber.ToString(); } } protected override void OnNavigatedTo (NavigationEventArgs e) { this .searchPane.QuerySubmitted += searchPane_QuerySubmitted; this .searchPane.QueryChanged += searchPane_QueryChanged; } protected override void OnNavigatedFrom (NavigationEventArgs e) { this .searchPane.QuerySubmitted -= searchPane_QuerySubmitted; this .searchPane.QueryChanged -= searchPane_QueryChanged; } void searchPane_QueryChanged(SearchPane sender, SearchPaneQueryChangedEventArgs args) { this .tBlockKeyword.Text = args.QueryText; } void searchPane_QuerySubmitted(SearchPane sender, SearchPaneQuerySubmittedEventArgs args) { string key = args.QueryText; var result = exampleStr.Where(s => s.Contains(key)).ToArray(); this .gridView.ItemsSource = result; } private void btnSearch_Click ( object sender, RoutedEventArgs e) { this .searchPane.Show(); } } 在清单文件中声明你需要使用“Search”功能后就可以开始调试咯。 大家肯定都用的音乐播放器肯定都会在搜索框下面给出一些建议吧，或者大家常用的地图等App。 那么我们就对前面的代码进行更新就好啦。 下面这段代码呢，就是根据用户的输入来显示建议列表的方法咯。 void searchPane_SuggestionsRequested(SearchPane sender, SearchPaneSuggestionsRequestedEventArgs args) { var deferralSeg= args .Request .GetDeferral () ; var q = from i in exampleStr where i .Contains (args .QueryText ) select i ; var res = q .Take (suggestionLen) .ToArray () ; foreach (var item in res) { args .Request .SearchSuggestionCollection .AppendQuerySuggestion (item) ; } deferralSeg .Complete () ; } 这篇博客，使用大量LINQ技术，如果不太懂的话可以看看这里。 【LINQ技术】扩展特性和LINQ操作符 ： http://blog.csdn.net/nomasp/article/details/45461517 使用搜索建议的最大好处在于我们可以选择并非自己输入的内容，这个功能就由下面这段代码提供动力支持。 void searchPane_ResultSuggestionChosen(SearchPane sender, SearchPaneResultSuggestionChosenEventArgs args) { sender .TrySetQueryText (args .Tag ) ; var q = from t in exampleStr where t .Contains (args .Tag ) select t ; this .gridView .ItemsSource = q .ToArray () ; } 我们还可以对前面的searchPane_QuerySubmitted函数做如下修改。 void searchPane_QuerySubmitted(SearchPane sender, SearchPaneQuerySubmittedEventArgs args) { //var q = from extStr in exampleStr // where extStr .Contains (args .QueryText ) // select extStr ; //this .gridView .ItemsSource = q .ToArray () ; string key = args .QueryText ; var result = exampleStr .Where (s => s .Contains (key)) .ToArray () ; this .gridView .ItemsSource = result ; } 最后还需要将他们添加到OnNavigatedTo和OnNavigatedFrom方法中。 protected override void OnNavigatedTo (NavigationEventArgs e) { this .searchPane.QuerySubmitted += searchPane_QuerySubmitted; this .searchPane.QueryChanged += searchPane_QueryChanged; this .searchPane.SuggestionsRequested += searchPane_SuggestionsRequested; this .searchPane.ResultSuggestionChosen += searchPane_ResultSuggestionChosen; } protected override void OnNavigatedFrom (NavigationEventArgs e) { this .searchPane.QuerySubmitted -= searchPane_QuerySubmitted; this .searchPane.QueryChanged -= searchPane_QueryChanged; this .searchPane.SuggestionsRequested -= searchPane_SuggestionsRequested; this .searchPane.ResultSuggestionChosen -= searchPane_ResultSuggestionChosen; } 然后调试就会是这个效果咯。 使用粘贴板 记得智能手机刚出来那会比较火的一个概念“能够复制粘贴的手机就是智能手机”。现在看来，这不过是个老掉牙的功能了，但实际用处却是非常强大的，那么现在我们就来试试怎么做到这个功能。 粘贴板的英文名叫做Clipboard，这也是它的类名了。 新建工程这种就不说了，在XAML中代码如下： < Grid Background = "{StaticResource ApplicationPageBackgroundThemeBrush}" > < Grid Margin= "12" HorizontalAlignment= "Left" VerticalAlignment= "Top" Width= "500" Height= "500" > < Grid .RowDefinitions> <RowDefinition Height= "Auto" /> <RowDefinition Height= "*" /> </ Grid .RowDefinitions> < Button Grid . Row = "0" Name= "btnClip" Margin= "0,3,0,16" Content= "粘贴" FontSize = "32" Click= "btnClip_Click" IsEnabled= "False" /> <ScrollViewer Name= "scrollView" Grid . Row = "1" Visibility= "Collapsed" > <TextBlock Margin= "12" Name= "tBlockClipboard" FontSize = "35" Foreground= "Gainsboro" TextWrapping= "Wrap" /> </ScrollViewer> </ Grid > </ Grid > 在后台代码中写上这么一个方法： void Clipboard_ContentChanged( object sender, object e) { DataPackageView pv = Clipboard.GetContent(); if (pv.Contains(StandardDataFormats.Text)) { btnClip.IsEnabled = true ; } } StandardDataFormats是标准数据格式，这里判断它是否是Text，如果是的话则让前面的Button按钮可用（之前设为不可用，以灰色显示）。 标准数据格式有Bitmap,HTML,RTF,StorageItems,Text,Uri等。 然后在按钮的Click事件中写如下代码： private async void btnClip_Click ( object sender, RoutedEventArgs e) { var txt = await Clipboard.GetContent().GetTextAsync(); tBlockClipboard.Text = txt; } 这里我们使用了Clipboard类的GetContent()方法，用于在剪切板中取出DataPackageView对象数据；类似的还有SetContent()，用于把数据存入剪切板中。还有Clear事件来清空剪切板，Flush事件把数据从源写入到剪切板，并且在应用程序退出后依然保留在剪切板中。还有ContentChanged事件在剪切板中存储的数据内容发生变化时自动激活以达到监听剪切板内容变化的效果。 protected override void OnNavigatedTo (NavigationEventArgs e) { Clipboard.ContentChanged += Clipboard_ContentChanged; } protected override void OnNavigatedFrom (NavigationEventArgs e) { Clipboard.ContentChanged -= Clipboard_ContentChanged; } void Clipboard_ContentChanged( object sender, object e) { DataPackageView pv = Clipboard.GetContent(); if (pv.Contains(StandardDataFormats.Text)||pv.Contains(StandardDataFormats.Bitmap)) { btnClip.IsEnabled = true ; } } 大家可以试试，已经完成了，但我们可以做的更多，不是吗？ 完整的代码如下: < Grid Background = "{StaticResource ApplicationPageBackgroundThemeBrush}" > < Grid Margin= "12" HorizontalAlignment= "Left" VerticalAlignment= "Top" Width= "500" Height= "500" > < Grid .RowDefinitions> <RowDefinition Height= "Auto" /> <RowDefinition Height= "*" /> </ Grid .RowDefinitions> < Button Grid . Row = "0" Name= "btnClip" Margin= "0,3,0,16" Content= "粘贴" FontSize = "32" Click= "btnClip_Click" IsEnabled= "False" /> <ScrollViewer Name= "scrollView" Grid . Row = "1" Visibility= "Collapsed" > <TextBlock Margin= "12" Name= "tBlockClipboard" FontSize = "35" Foreground= "Gainsboro" TextWrapping= "Wrap" /> </ScrollViewer> < Image x:Name= "imgClicpboard" Grid . Row = "1" Margin= "5" Stretch= "Uniform" Visibility= "Collapsed" /> </ Grid > </ Grid > public sealed partial class MainPage : Page { public MainPage () { this .InitializeComponent(); } protected override void OnNavigatedTo (NavigationEventArgs e) { Clipboard.ContentChanged += Clipboard_ContentChanged; } protected override void OnNavigatedFrom (NavigationEventArgs e) { Clipboard.ContentChanged -= Clipboard_ContentChanged; } void Clipboard_ContentChanged( object sender, object e) { DataPackageView pv = Clipboard.GetContent(); if (pv.Contains(StandardDataFormats.Text)||pv.Contains(StandardDataFormats.Bitmap)) { btnClip.IsEnabled = true ; } } private async void btnClip_Click ( object sender, RoutedEventArgs e) { scrollView.Visibility = Visibility.Collapsed; imgClicpboard.Visibility = Visibility.Collapsed; tBlockClipboard.Text = " " ; imgClicpboard.Source = null ; DataPackageView pv = Clipboard.GetContent(); if (pv.Contains(StandardDataFormats.Text)) { scrollView.Visibility = Visibility; var txt = await Clipboard.GetContent().GetTextAsync(); tBlockClipboard.Text = txt; } else if (pv.Contains(StandardDataFormats.Bitmap)) { imgClicpboard.Visibility = Visibility; var bmp = await Clipboard.GetContent().GetBitmapAsync(); Windows.UI.Xaml.Media.Imaging.BitmapImage bitMap = new Windows.UI.Xaml.Media.Imaging.BitmapImage(); bitMap.SetSource( await bmp.OpenReadAsync()); this .imgClicpboard.Source = bitMap; } } } 现在它还可以复制图片了哦~ 设置共享（共享源和共享目标） 上一节简单介绍了通过粘贴板来共享数据，这一节将会添加更为强大的功能哦。 以下就是大概的样式了，随便看看就好了，这都不是重点。 < Grid Background = "AliceBlue" > < Grid .RowDefinitions> <RowDefinition Height= "auto" /> <RowDefinition /> <RowDefinition Height= "auto" /> </ Grid .RowDefinitions> <TextBlock Grid . Row = "0" FontSize = "25" Foreground= "Red" Text = "共享源示例" Margin= "12" /> <ScrollViewer Grid . Row = "1" Margin= "14" VerticalScrollMode= "Auto" HorizontalScrollMode= "Disabled" > <StackPanel> <StackPanel Orientation= "Horizontal" > < RadioButton x:Name= "radioBtnText" Foreground= "Aqua" FontWeight = "Bold" FontSize = "22" Content= "共享文本" Checked= "OnChecked" GroupName= "g" Tag= "text" /> < RadioButton x:Name= "radioBtnImg" Foreground= "Aqua" FontWeight = "Bold" FontSize = "22" Content= "共享图像" Margin= "12,0,0,0" Checked= "OnChecked" GroupName= "g" Tag= "image" /> < RadioButton x:Name= "radioBtnFile" Foreground= "Aqua" FontWeight = "Bold" FontSize = "22" Content= "共享文件" Margin= "12,0,0,0" Checked= "OnChecked" GroupName= "g" Tag= "file" /> </StackPanel> <StackPanel Name= "stackPText" Visibility= "Collapsed" Margin= "8" > <TextBlock Text = "共享文本" FontSize = "25" /> <TextBlock Foreground= "Gold" FontSize = "25" Text = "输入要共享的内容" /> < TextBox x:Name= "tBlockText" Foreground= "Gold" /> </StackPanel> <StackPanel Name= "stackPImg" Visibility= "Collapsed" Margin= "8" > <TextBlock Text = "共享图像" FontSize = "25" /> <TextBlock Foreground= "Gold" FontSize = "25" Text = "共享以下图片" /> < Image Width= "600" Height= "400" Stretch= "UniformToFill" HorizontalAlignment= "Left" Margin= "1,5,0,5" Source= "Assets/SpaceNeedle1.jpg" /> </StackPanel> <StackPanel Name= "stackPFile" Visibility= "Collapsed" Margin= "8" > <TextBlock Text = "共享文件" FontSize = "28" /> <TextBlock Foreground= "Gold" FontSize = "25" Text = "选择要共享的文件" /> <StackPanel> < Button Content= "选择文件" Click= "OnPickFile" /> <TextBlock x:Name= "tBlockFile" Foreground= "Gold" FontSize = "24" /> </StackPanel> </StackPanel> </StackPanel> </ScrollViewer> < Button Grid . Row = "2" Name= "btnShare" Margin= "12" Content= "确定共享" FontSize = "35" FontFamily = "隶书" Foreground= "Azure" Background = "Black" Click= "btnShare_Click" /> </ Grid > 这里通过3个StackPanel的“显示“与”隐藏“来达到在一个位置显示3个界面的功能，然后在后台通过以下方法更改Visibility属性。 private void OnChecked(object sender, RoutedEventArgs e) { RadioButton rbtn = sender as RadioButton ; if (rbtn != null) { string tag = rbtn .Tag .ToString () ; switch (tag) { case "text" : this .stackPText .Visibility = Windows .UI .Xaml .Visibility .Visible ; this .stackPImg .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; this .stackPFile .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; break ; case "image" : this .stackPText .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; this .stackPImg .Visibility = Windows .UI .Xaml .Visibility .Visible ; this .stackPFile .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; break ; case "file" : this .stackPText .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; this .stackPImg .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; this .stackPFile .Visibility = Windows .UI .Xaml .Visibility .Visible ; break ; default: this .stackPText .Visibility = Windows .UI .Xaml .Visibility .Visible ; this .stackPImg .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; this .stackPFile .Visibility = Windows .UI .Xaml .Visibility .Collapsed ; break ; } } } 以下是核心代码，通过RadioButton的选择来共享不同的内容。这里没有进行try、catch异常检测，但在实际工程中则是必要的，因为如果你不共享任何内容而点击共享按钮你就知道了…… void MainPage_DataRequested(DataTransferManager sender, DataRequestedEventArgs args) { var deferral = args .Request .GetDeferral () ; if (radioBtnText .IsChecked == true) { args .Request .Data .Properties .Title = "共享文本" ; args .Request .Data .Properties .Description = "共享你输入的文本数据。" ; args .Request .Data .SetText (this .tBlockText .Text ) ; } else if (radioBtnImg .IsChecked == true) { args .Request .Data .Properties .Title = "共享图像" ; args .Request .Data .Properties .Description = "共享以下图片。" ; args .Request .Data .SetBitmap (Windows .Storage .Streams .RandomAccessStreamReference .CreateFromUri (new Uri( "ms-appx:///Assets/SpaceNeedle1.jpg" ))) ; } else if (radioBtnFile .IsChecked == true) { args .Request .Data .Properties .Title = "共享文件" ; args .Request .Data .Properties .Description = "共享你选择的文件。" ; var file = this .tBlockFile .Tag as Windows .Storage .StorageFile ; List<IStorageItem> files = new List<IStorageItem>() ; files .Add (file) ; args .Request .Data .SetStorageItems (files) ; } deferral .Complete () ; } 选择文件的方法我们在前面也都介绍过了，直接贴代码…… private async void OnPickFile(object sender, RoutedEventArgs e) { Windows .Storage .Pickers .FileOpenPicker picker = new Windows .Storage .Pickers .FileOpenPicker () ; picker .FileTypeFilter .Add ( ".mp3" ) ; picker .FileTypeFilter .Add ( ".jpg" ) ; picker .FileTypeFilter .Add ( ".png" ) ; picker .FileTypeFilter .Add ( ".docx" ) ; picker .FileTypeFilter .Add ( ".pptx" ) ; picker .FileTypeFilter .Add ( ".txt" ) ; Windows .Storage .StorageFile file = await picker .PickSingleFileAsync () ; if (file != null) { this .tBlockFile .Text = file .Path ; this .tBlockFile .Tag = file ; } } 当然了，记得下面这些操作…… protected override void OnNavigatedTo (NavigationEventArgs e) { DataTransferManager.GetForCurrentView().DataRequested += MainPage_DataRequested; } protected override void OnNavigatedFrom (NavigationEventArgs e) { DataTransferManager.GetForCurrentView().DataRequested -= MainPage_DataRequested; } 最后就是共享确认按钮了，一行代码搞定。 private void btnShare_Click ( object sender, RoutedEventArgs e) { DataTransferManager.ShowShareUI(); } 以上这个App，你将需要共享的数据从这里发出，也叫共享源，但共享到哪里了呢？ 看到”共享图像“和”共享以下图片“想起来刚才的两行代码了么？这两个属性就用在了这里。 args .Request .Data .Properties .Title = "共享文本" ; args .Request .Data .Properties .Description = "共享你输入的文本数据。" ; 我们当然可以将数据共享到邮件、OneNote里，但如果你是要写一个自己的接收共享数据的应用呢，如何来写？ 接下来就来写另一个App咯，也就是上图中的App49了。首先在清单文件中做如下操作，当然了，具体要添加哪些东西大家自己看着办就好了。 然后添加一个XAML页面来接收数据，因为你不可能只让你的APP专门用来接收数据咯，所以就不建议在MainPage中写了。 在新页面中大概做一下页面布局，我的布局通常来说都不是很美观的…… < Grid Background = "{StaticResource ApplicationPageBackgroundThemeBrush}" > < Grid .RowDefinitions> <RowDefinition Height= "*" /> <RowDefinition Height= "100" /> </ Grid .RowDefinitions> < Grid x:Name= "gridText" Margin= "24" Visibility= "Collapsed" Grid . Row = "0" > <StackPanel> <TextBlock FontSize = "25" Foreground= "Red" Text = "接收到的文本：" /> <TextBlock FontSize = "30" Foreground= "Pink" FontWeight = "Bold" x:Name= "tbText" Margin= "8" /> </StackPanel> </ Grid > < Grid x:Name= "gridImg" Margin= "25" Visibility= "Collapsed" Grid . Row = "0" > <StackPanel> <TextBlock FontSize = "25" Foreground= "Red" Text = "接收到的图像：" /> < Image x:Name= "img" Margin= "12" Wid

Recno:: 34
URL:: http://blog.csdn.net/nomasp/article/details/50319677

ParseText::
日常小记：C++中的log10函数 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 日常小记：C++中的log10函数 标签： c语言 namespace mint log10 算法 2015-12-15 19:32 517人阅读 评论 (0) 收藏 举报 分类： C++ （8） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 今天有同学问我C++中有没有什么简单的办法可以求出两个数相加的和的位数，然后就有了如题的那种方法。 log10(100)的返回值就是2，log(999)的返回值是二点几，不过如果你把返回值定位int型它就会自动转换成2了。 #include<iostream> #include<cmath> using namespace std ; int main(){ int a,b; while ( cin >>a>>b){ a= log10 (a+b)+ 1 ; cout <<a<<endl; } return 0 ; } 初次之外还有log2()等函数，用log10l()和log10f()还可以满足不同的精度。 这样一来就不用用许多个for循环来解决了，虽然这一篇毕竟简单（毕竟水，逃……），不过希望可以帮到初学编程的朋友。 上一篇 【UWP通用应用开发】集成搜索、粘贴板以及设置共享源和共享目标 下一篇 【UWP通用应用开发】使用Toast通知与动态磁贴 顶 1 踩 0 我的同类文章 C++ （8） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577524次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 35
URL:: http://blog.csdn.net/nomasp/article/details/50349119

ParseText::
【UWP通用应用开发】使用Toast通知与动态磁贴 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【UWP通用应用开发】使用Toast通知与动态磁贴 标签： xml 应用 实例 class 2015-12-18 08:32 697人阅读 评论 (0) 收藏 举报 分类： UWP （9） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 使用Toast通知示例 前面我们使用了MessageDialog来作为弹窗，这里来介绍一个更加高大上的Toast通知。 Toast通知本质上动力是由XML来提供的，一开始我还不相信不知道XML原来有这么大的威力。现在就来看看和Toast相关的知识。 1）实例化ToastNotification类。 ToastNotification toast1 = new ToastNotification(xdoc); 2）使用ToastNotificationManager来管理Toast通知，包括添加、展示、移除、获取通知等等。 ToastNotificationManager.CreateToastNotifier(). Show (toast1); 3）在第一步中的xdoc就是一段XML数据，它从何而来呢？ XmlDocument xdoc = new XmlDocument(); 4）上一步代码实例化了一个XML，但是它没有数据呀，数据从哪来呢？ xdoc .LoadXml (txtXML .Text ) ; 5）这段代码就将一段Text导入了XML中。而Text数据有很多种获取方式。在下文中自然会提到。 Toast的XML模板有许多，我们可以直接来获取它们。用枚举和强大的var即可。 var items = Enum.GetNames( typeof (ToastTemplateType)); 那么就正式开工了，因为重复的属性太多了我就大概设置了2个Style资源。 <Page.Resources> < Style TargetType= "TextBlock" x:Key= "StyleHeaderTextBlock" > < Setter Property = "FontSize" Value = "40" /> < Setter Property = "FontFamily" Value = "华文琥珀" /> < Setter Property = "Foreground" Value = "HotPink" /> < Setter Property = "Margin" Value = "12" /> </ Style > < Style TargetType= "Button" x:Key= "StyleToastButton" > < Setter Property = "Width" Value = "180" /> < Setter Property = "Height" Value = "50" /> < Setter Property = "Background" Value = "Aqua" /> < Setter Property = "FontSize" Value = "21" /> < Setter Property = "Margin" Value = "12" /> < Setter Property = "Content" Value = "显示Toast通知" /> </ Style > </Page.Resources> 下面是第一部分用于生成Toast通知。 <StackPanel Orientation= "Vertical" Grid . Column = "0" Margin= "12" > <TextBlock Text = "生成Toast通知" Style = "{StaticResource StyleHeaderTextBlock}" /> <StackPanel Orientation= "Horizontal" HorizontalAlignment= "Left" > <TextBlock FontSize = "24" Foreground= "Wheat" Text = "请选择一个模板：" VerticalAlignment= "Center" /> <ComboBox Name= "comboBoxToast" Foreground= "Green" Width= "275" SelectionChanged= "comboBoxToast_SelectionChanged" /> </StackPanel> < TextBox Foreground= "Green" x:Name= "txtXML" HorizontalAlignment= "Left" Width= "500" Height= "400" Header= "模板XML：" TextWrapping= "Wrap" FontSize = "24" /> < Button Name= "btnShowToast1" Click= "btnShowToast1_Click" Style = "{StaticResource StyleToastButton}" /> </StackPanel> 后台代码也蛮容易的，利用上面讲的就好了。 public MainPage () { this .InitializeComponent(); var items = Enum.GetNames( typeof (ToastTemplateType)); this .comboBoxToast.ItemsSource = items; } private void comboBoxToast_SelectionChanged ( object sender, SelectionChangedEventArgs e) { string tempt = ((ComboBox)sender).SelectedItem as string ; if (! string .IsNullOrEmpty(tempt)) { ToastTemplateType template = (ToastTemplateType)Enum.Parse( typeof (ToastTemplateType), tempt); XmlDocument xdoc = ToastNotificationManager.GetTemplateContent(template); txtXML.Text = xdoc.GetXml(); } } private void btnShowToast1_Click ( object sender, RoutedEventArgs e) { if (txtXML.Text == "" ) return ; XmlDocument xdoc = new XmlDocument(); xdoc.LoadXml(txtXML.Text); ToastNotification toast1 = new ToastNotification(xdoc); ToastNotificationManager.CreateToastNotifier().Show(toast1); } 模板是这样用的…… 在src中填入图片的路径也可以在Toast中显示图像哦，赶紧试试吧…… 接下来是第二段啦，和前面的很是类似…… < StackPanel Orientation = "Vertical" Grid.Column = "1" > < TextBlock Text = "更改Toast通知的提示音" Style = "{StaticResource StyleHeaderTextBlock}" /> < TextBlock Margin = "12" Text = "请输入Toast消息内容：" FontSize = "24" /> < TextBox Margin = "12" Height = "50" x:Name = "txtMesaage" /> < TextBlock Margin = "12" FontSize = "24" Text = "请选择一种提示声音：" /> < ComboBox Margin = "12" Height = "50" x:Name = "comboBoxAudio" Width = "400" HorizontalAlignment = "Left" > < ComboBoxItem IsSelected = "True" > ms-winsoundevent:Notification.Default </ ComboBoxItem > < ComboBoxItem > ms-winsoundevent:Notification.IM </ ComboBoxItem > < ComboBoxItem > ms-winsoundevent:Notification.Mail </ ComboBoxItem > < ComboBoxItem > ms-winsoundevent:Notification.Reminder </ ComboBoxItem > < ComboBoxItem > ms-winsoundevent:Notification.Looping.Alarm </ ComboBoxItem > < ComboBoxItem > ms-winsoundevent:Notification.Looping.Call </ ComboBoxItem > </ ComboBox > < StackPanel Orientation = "Horizontal" > < CheckBox x:Name = "checkBoxLoop" Margin = "12" Content = "循环播放" /> < CheckBox x:Name = "checkBoxSilent" Margin = "12" Content = "静音" /> </ StackPanel > < Button Name = "btnShowToast2" Click = "btnShowToast2_Click" Style = "{StaticResource StyleToastButton}" /> </ StackPanel > 上面代码中的“ms-winsoundevent:Notification.Default”都是填到src中的用于设置声音，还可以在loop、silent中设置是否循环以及是否静音，那到底该怎么用呢？应该将这些属性全部都填入到XML中。 xmlContent = string.Format( " < toast duration = '{0}' > " + " < visual > " + " < binding template = 'ToastText01' > " + " < text id = '1' > {1} </ text > " + " </ binding > " + " </ visual > " + " < audio src = '{2}' loop = '{3}' silent = '{4}' /> " + " </ toast > ", toastDuration, msg, audioSrc, isLoop, isSilent ); 上面用的xmlContent也要先定义出来，一开始设置为Empty就好。 string xmlContent = string . Empty ; isLoop和isSilent属性都可以借助于三目运算符在CheckBox中获取来。 string isLoop = checkBoxLoop.IsChecked == true ? "true" : "false" ; string audioSrc = (comboBoxAudio.SelectedItem as ComboBoxItem).Content.ToString(); string toastDuration = checkBoxLoop.IsChecked == true ? "long" : "short" ; string isSilent = checkBoxSilent.IsChecked == true ? "true" : "false" ; 当然，考虑得更加周到些，用户可以在还没有输入通知内容就点了显示Toast通知按钮，对此用三目运算符也是极好的选择。 string msg = txtMesaage. Text == "" ? "你还没有输入Toast通知的内容呢……" : txtMesaage. Text ; 这些准备工作都写好了以后呢就该设置Toast通知了，和上面的Toast1类似哦，大家试试。 可是这些通知都没有时间性可言，因为有时候我们需要定在一个时间来执行Toast通知。这自然也是可以实现的。 先作如下界面设计。 <StackPanel Orientation= "Vertical" Grid . Column = "2" > <TextBlock Text = "计划时间显示Toast通知" Style = "{StaticResource StyleHeaderTextBlock}" /> <StackPanel Orientation= "Horizontal" Height= "60" > <TextBlock FontSize = "28" Text = "计划在" VerticalAlignment= "Center" /> < TextBox Name= "tBoxTime" FontSize = "28" Width= "60" Height= "45" VerticalAlignment= "Center" /> <TextBlock FontSize = "28" Text = "秒后显示Toast通知" VerticalAlignment= "Center" /> </StackPanel> < Button Name= "btnShowToast3" Click= "btnShowToast3_Click" Style = "{StaticResource StyleToastButton}" /> </StackPanel> 后台代码如下。 private async void btnShowToast3_Click(object sender, RoutedEventArgs e) { int toastTime ; try { toastTime = int .Parse (tBoxTime .Text .ToString ()) ; XmlDocument xdoc = ToastNotificationManager .GetTemplateContent (ToastTemplateType .ToastText 01) ; var txtnodes = xdoc .GetElementsByTagName ( "text" ) ; txtnodes[ 0 ] .InnerText = "你好，这是一条定时为" +toastTime .ToString ()+ "秒的Toast消息。" ; ScheduledToastNotification toast3 = new ScheduledToastNotification(xdoc, DateTimeOffset .Now .AddSeconds (toastTime)) ; ToastNotificationManager.CreateToastNotifier().AddToSchedule(toast3); } catch (Exception ex) { Windows .UI .Popups .MessageDialog messageDialog = new Windows .UI .Popups .MessageDialog (ex .Message ) ; await messageDialog .ShowAsync () ; } } 在这个小程序中因为侧重于讲解定时而非Toast的通知样式，因此就选用了比较简单的ToastText01模板。而后找出Text节点，并向该节点写入内容。最后就是创建Toast通知了。 ScheduledToastNotification toast3 = new ScheduledToastNotification(xdoc, DateTimeOffset .Now .AddSeconds (toastTime)) ; 同样为了防止用户没有在TextBox中输入时间或输入了错误格式的时间比如“5秒”而做了try、catch异常检测。当然了，在实际产品中，这里可就要做得更加完美了，时间用TextBox来输入并不是一件好事，而应用我们前面介绍的TimePicker。 给这3段程序来张全家福吧~ 使用动态磁贴示例 动态磁贴是什么，相信大家用了这么久的Windows 8/8.1/10早就非常了解了吧。 像什么小磁贴、中磁贴、宽磁贴、大磁贴，还有这里的应用商店Logo等，大家在下面根据不同的分辨率选择合适的图片就好啦。 下面来做一个更新磁贴页面的功能，这是页面XML部分。 < StackPanel Margin = "12" > < StackPanel Orientation = "Horizontal" > < TextBlock FontSize = "28" Text = "选择模板：" VerticalAlignment = "Center" /> < ComboBox x:Name = "comboBoxTile" Width = "400" SelectionChanged = "comboBoxTile_SelectionChanged" /> </ StackPanel > < TextBox x:Name = "textBoxXML" TextWrapping = "Wrap" FontSize = "22" Header = "XML文档" Width = "420" Height = "320" HorizontalAlignment = "Left" Margin = "12" /> < Button Name = "btnTile" Content = "更新磁贴" Click = "btnTile_Click" Style = "{StaticResource StyleToastButton}" /> </ StackPanel > 在后台代码的Main函数中，获取TileTemplateType枚举并绑定到ComboBox上。 var itemsTile = Enum.GetNames( typeof (TileTemplateType)); this .comboBoxTile.ItemsSource = itemsTile; 下面的代码和前面的Toast真的非常类似，所以我才把这两节连在一起来写了。Button按钮的Click事件中，和之前一样建一个XML，然后加载到TileNotification类的实例中。最后就是TileUpdateManager类，也就是磁贴更新。 private void btnTile_Click ( object sender, RoutedEventArgs e) { if ( this .textBoxXML.Text == "" ) return ; XmlDocument xdoc = new XmlDocument(); xdoc.LoadXml( this .textBoxXML.Text); TileNotification tileNotifi = new TileNotification(xdoc); TileUpdateManager.CreateTileUpdaterForApplication().Update(tileNotifi); } private void comboBoxTile_SelectionChanged ( object sender, SelectionChangedEventArgs e) { TileTemplateType tileTemplate = (TileTemplateType)Enum.Parse( typeof (TileTemplateType), this .comboBoxTile.SelectedItem as string ); XmlDocument xdoc = TileUpdateManager.GetTemplateContent(tileTemplate); this .textBoxXML.Text = xdoc.GetXml(); } 当然了，如果你的APP不满足于一个磁贴，你也可以创建第二个磁贴哟！ 依旧和Toast通知的XML类似，它也有好多属性的…… Arguments：使用该字符串参数在通过次要磁贴启动应用程序时会传递给Application类的OnLaunched方法，这样一来应用程序就可以根据传入的参数来执行特定的操作。 BackgroundColor：设置磁贴的背景色。 DisplayName和ShortName：设置显示在磁贴上的文本。 Logo等：设置磁贴的图标，用Uri。 ForegroundText：磁贴上文本的颜色，可用的选项有深色、浅色等。 TileID：设置磁贴的唯一标识ID，创建新磁贴前用SecondaryTile.Exists判断是否已经存在。 在添加第二磁贴的Button的Click事件中： private async void btnCreateTile ( object sender, RoutedEventArgs e) { if (SecondaryTile.Exists(textTileID.Text)) { textBlockMsg.Text= "该ID磁贴已经存在" ; return ; } Uri uriImg= new Uri( "ms-appx:///Assests/uriImg.png" ); …… …… // 创建第二磁贴 SecondaryTile secTile= new SecondaryTile(); this .Tag=secTile; secTile.DisplayName=textBlockDisplayName.Text; secTile.TileID=textBlockID.Text; secTile.Arguments= "second" ; // 在后面有用到 // 设置图标 secTile.VisualElements.BackgroundColor=Windows.UI.Colors.Gold; …… …… bool r= await secTile.RequestCreateAsync(); textBlockMsg.Text=r == true ? "磁贴创建成功啦." : "磁贴创建失败了哎." ; // 返回测试结果 如果希望点击第二磁贴导航到特定的页面，就需要重写该页面的OnNavigatedTo方法。 preteced async override void OnNavigatedTo(NavigationEventArgs e) { if (e.Parameter is Windows.ApplicationModel.Activation.LaunchActivatedEventArgs) { var arg=e.Parameter as Windows.ApplicationModel.Activation.LaunchActivateEventArgs; …… } } if (rootFrame.Content== null ) { if (e.Arguments== "second" ) rootFrame.Navigate( typeof (OtherPage),e); else rootFrame.Navigate( typeof (MainPage)); } 这里的参数”second”就是上面设置那个Arguments哦，它的作用就在于这里呢。 上一篇 日常小记：C++中的log10函数 下一篇 【万字总结】图解堆算法、链表、栈与队列（多图预警） 顶 5 踩 2 我的同类文章 UWP （9） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577545次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1)

Recno:: 36
URL:: http://blog.csdn.net/nomasp/article/details/50349172

ParseText::
【万字总结】图解堆算法、链表、栈与队列（多图预警） - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【万字总结】图解堆算法、链表、栈与队列（多图预警） 标签： 算法 链表 栈 数据结构 二叉树 2015-12-18 08:40 4709人阅读 评论 (6) 收藏 举报 分类： Algorithm （30） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 堆算法 什么是堆 堆 （heap），是一类特殊的数据结构的统称。它通常被看作一棵树的数组对象。在队列中，调度程序反复提取队列中的第一个作业并运行，因为实际情况中某些时间较短的任务却可能需要等待很长时间才能开始执行，或者某些不短小、但很重要的作业，同样应当拥有优先权。而堆就是为了解决此类问题而设计的数据结构。 二叉堆 是一种特殊的堆，二叉堆是完全二叉树或者近似完全二叉树，二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。 当父节点的键值总是大于任何一个子节点的键值时为 最大堆 ，当父节点的键值总是小于或等于任何一个子节点的键值时为 最小堆 。 为了更加形象，我们常用带数字的圆圈和线条来表示二叉堆等，但其实都是用数组来表示的。 如果根节点在数组中的位置是1，第n个位置的子节点则分别在2n和2n+1位置上。 如下图所描的，第2个位置的子节点在4和5，第4个位置的子节点在8和9。所以我们获得父节点和子节点的方式如下： PARENT( i ) 1 return 小于或等于 i / 2 的最大整数 LEFT-CHILD( i ) 1 return 2 i RIGHT-CHILD( i ) 1 return 2 i + 1 假定表示堆的数组为 A ，那么 A . l e n g t h 通常给出数组元素的个数， A . h e a p − s i z e 表示有多少个堆元素存储在该数组中。这句话略带拗口，也就是说数组 A [ 1... A . l e n g t h ] 可能都有数据存放，但只有 A [ 1... A . h e a p − s i z e ] 中存放的数据才是堆中的有效数据。毫无疑问 0 ≤ A . h e a p − s i z e ≤ A . l e n g t h 。 最大堆除了根以外所有结点i都满足： A [ P A R E N T ( i ) ] ≥ A [ i ] 。 最小堆除了根以外所有结点i都满足： A [ P A R E N T ( i ) ] ≤ A [ i ] 。 一个堆中结点的高度是该结点到叶借点最长简单路径上边的数目，如上图所示编号为4的结点的高度为1，编号为2的结点的高度为2，树的高度就是3。 包含n个元素的队可以看作一颗完全二叉树，那么该堆的高度是 Θ ( l g n ) 。 通过MAX-HEAPIFY维护最大堆 程序中，不可能所有的堆都天生就是最大堆，为了更好的使用堆这一数据结构，我们可能要人为地构造最大堆。 如何将一个杂乱排序的堆重新构造成最大堆，它的主要思路是： 从上往下，将父节点与子节点以此比较。如果父节点最大则进行下一步循环，如果子节点更大，则将子节点与父节点位置互换，并进行下一步循环。注意父节点要与两个子节点都进行比较。 如上图说描述的，这里从结点为2开始做运算。先去 l 为4， r 为5，将其与父节点做比较，发现左子节点比父节点更大。因此将它们做交换，设4为最大的结点，并继续以结点4开始做下一步运算。 因此可以给出伪代码如下： MAX-HEAPIFY( A ,i) 1 l=LEFT-CHILD(i) 2 r=RIGHT-CHILD(i) 3 if l<= A .heap-size and A [l]> A [i] 4 largest=l 5 else 6 largest=i 7 if r<= A .heap-size and A [r]> A [largest] 8 largest=r 9 if largest != i 10 exchange A [i] with A [largest] 11 MAX-HEAPIFY( A ,largest) 在以上这些步骤中，调整A[i]、A[l]、A[r]的关系的时间代价为 Θ ( 1 ) ，再加上一棵以i的子节点为根结点的子树上运行MAX-HEAPIFY的时间代价（注意此处的递归不一定会发生，此处只是假设其发生）。因为每个子节点的子树的大小至多为 2 n / 3 （最坏情况发生在树的底层恰好半满的时候）。因此MAX-HEAPIFY过程的运行时间为： T ( n ) ≤ T ( 2 n / 3 ) + Θ ( 1 ) 也就是： T ( n ) = O ( l g n ) 通过BUILD-MAX-HEAP构建最大堆 前面我们通过自顶向下的方式维护了一个最大堆，这里将通过自底向上的方式通过MAX-HEAPIFY将一个 n = A . l e n g t h 的数组 A [ 1... n ] 转换成最大堆。 回顾一下上面的图示，其总共有9个结点，取小于或等于9/2的最大整数为4，从4+1，4+2，一直到n都是该树的叶子结点，你发现了么？这对任意n都是成立的哦。 因此这里我们就要从4开始不断的调用MAX-HEAPIFY(A,i)来构建最大堆。 为什么会有这一思路呢？ 原因是既然我们知道了哪些结点是叶子结点，从最后一个非叶子结点（这里是4）开始，一次调用MAX-HEAPIFY函数，就会将该结点与叶子结点做相应的调整，这其实也就是一个递归的过程。 图示已经这么清晰了，就直接上伪代码咯。 BUILD-MAX-HEAP(A) 1 A. heap- size = A. length 2 for i =小于或等于 A. length / 2 的最大整数 downto 1 3 MAX-HEAPIFY(A, i ) 通过HEAPSORT进行堆排序算法 所谓的堆排序算法，先通过前面的BUILD-MAX-HEAP将输入数组 A [ 1... n ] 建成最大堆，其中 n = A . l e n g t h 。而数组中的元素总在根结点 A [ 1 ] 中，通过把它与 A [ n ] 进行互换，就能将该元素放到正确的位置。 如何让原来根的子结点仍然是最大堆呢，可以通过从堆中去掉结点n，而这可以通过减少 A . h e a p − s i z e 来间接的完成。但这样一来新的根节点就违背了最大堆的性质，因此仍然需要调用MAX-HEAPIFY(A,1)，从而在 A [ 1... n − 1 ] 上构造一个新的最大堆。 通过不断重复这一过程，知道堆的大小从 n − 1 一直降到2即可。 上图的演进方式主要有两点： 1）将 A [ 1 ] 和 A [ i ] 互换， i 从 A . l e n g t h 一直递减到2 2）不断调用MAX-HEAPIFY(A,1)对剩余的整个堆进行重新构建 一直到最后堆已经不存在了。 HEAPSORT( A ) 1 BUILD-MAX-HEAP( A ) 2 for i= A .length downto 2 3 exchange A [ 1 ] with A [i] 4 A .heap-size= A .heap-size- 1 5 MAX-HEAPIFY( A , 1 ) 优先队列 下一篇博文我们就会介绍大名鼎鼎的快排，快速排序啦，欢迎童鞋们预定哦~ 话说堆排序虽然性能上不及快速排序，但作为一个尽心尽力的数据结构而言，其可谓业界良心呐。它还为我们提供了传说中的“优先队列”。 优先队列（priority queue）和堆一样，堆有最大堆和最小堆，优先队列也有最大优先队列和最小优先队列。 优先队列是一种用来维护由一组元素构成的集合S的数据结构，其中每个元素都有一个相关的值，称之为关键字（key）。 一个最大优先队列支持一下操作： M A X I M U M ( S )

Recno:: 37
URL:: http://blog.csdn.net/nomasp/article/details/50359787

ParseText::
【万字总结】快速排序详解与各种线性时间排序对比 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 【万字总结】快速排序详解与各种线性时间排序对比 标签： 快速排序 归并排序 排序算法 分治算法 插入排序 2015-12-19 21:27 766人阅读 评论 (4) 收藏 举报 分类： Algorithm （30） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 什么是快速排序 快速排序简介 快速排序（英文名：Quicksort，有时候也叫做划分交换排序）是一个高效的排序算法，由Tony Hoare在1959年发明（1961年公布）。当情况良好时，它可以比主要竞争对手的归并排序和堆排序快上大约两三倍。这是一个 分治算法 ，而且它就在 原地排序 。 所谓原地排序，就是指在原来的数据区域内进行重排，就像插入排序一般。而归并排序就不一样，它需要额外的空间来进行归并排序操作。为了在线性时间与空间内归并，它不能在线性时间内实现就地排序，原地排序对它来说并不足够。而快速排序的优点就在于它是原地的，也就是说，它很 节省内存 。 引用一张来自维基百科的能够非常清晰表示快速排序的示意图如下： 快速排序的分治思想 由于快速排序采用了 分治算法 ，所以： 一、分解：本质上快速排序把数据划分成几份，所以快速排序通过选取一个关键数据，再根据它的大小，把原数组分成两个子数组：第一个数组里的数都比这个主元数据小或等于，而另一个数组里的数都比这个主元数据要大或等于。 二、解决：用递归来处理两个子数组的排序。 （也就是说，递归地求上面图示中左半部分，以及递归地求上面图示中右半部分。） 三、合并：因为子数组都是原址排序，所以不需要合并操作，通过上面两步后数组已经排好序了。 所以快速排序的主要思想是 递归与划分 。 如何划分 当然最重要的是它的复杂度是线性的，也就是 Θ ( n ) 个划分的子程序。 Partition( A ,p,q) // A [p,..q] 1 x= A [p] // pivot= A [p] 主元 2 i=p 3 for j=p+ 1 to q 4 do if A [j]<=x 5 then i=i+ 1 6 exch A [i]<-> A [j] 7 exch A [p]<-> A [i] 8 return i // i pivot 这就是划分的伪代码，基本的结构就是一个for循环语句，中间加上了一个if条件语句，它实现了对子数组 A [ p . . . q ] 的原址排序。 刚开始时 i 等于 p ， j 等于 p + 1 。在这个循环中查找i下标的数据，如果它比 x 大，那就将其存放到“>=x”区域并将 j 加1后进行下一次循环。而如果它比 x 小，那就要做些动作来维持循环不变量了。将 i 的下标加1后将下标i对应的数据和下标j所对应的数据互换位置。然后再移动区域的界限并开始下一次循环。 那么这个算法在n个数据下的运行时间大约是 O ( n ) ，因为它几乎把每个数都比较了一遍，而每个步骤所需的时间都为 O ( 1 ) 。 上面这幅图详细的描述了Partition过程，每一行后也加了注释。 将递归的思想作用于划分上 有了上面这些准备工作，再加上分治的思想实现快速排序的伪代码也是很简单的。 Quicksort( A ,p,q) 1 if p<q 2 then r=Partition( A ,p,q) 3 Quicksort( A ,p,r- 1 ) 4 Quicksort( A ,r+ 1 ,q) 为了排序一个数组A的全部元素，初始调用时 Q u i c k s o r t ( A , 1 , A . l e n g t h ) 。 快速排序的算法分析 相信通过前面的诸多实践，大家也发现了快速排序的运行时间依赖于Partition过程，也就是依赖于划分是否平衡，而归根结底这还是由于输入的元素决定的。 如果划分是平衡的，那么快速排序算法性能就和归并排序一样。 如果划分是不平衡的，那么快速排序的性能就接近于插入排序。 怎样是最坏的划分 1）输入的元素已经排序或逆向排序 2）每个划分的一边都没有元素 也就是说当划分产生的两个子问题分别包含了n-1个元素和0个元素时，快速排序的最坏情况就发生了。 T ( n ) = T ( 0 ) + T ( n − 1 ) + \Theta(n) = Θ ( 1 ) + T ( n − 1 ) + Θ ( n ) = Θ ( n − 1 ) + Θ ( n ) = Θ ( n 2 ) 这是一个 等差级数 ，就和插入排序一样。它并不比插入排序快，因为当同样是输入元素已经逆向排好序时，插入算法的运行时间为 Θ ( n ) 。但快速排序仍旧是一个优秀的算法，这是因为在平均情况下它已经很高效。 我们为最坏情况画一个递归树。 这是一课高度不平衡的递归树，图中左边的那些 T ( 0 ) 的运行时间都为 Θ ( 1 ) ，而总共有n个。 所以算法的中运行时间为： T ( n ) = Θ ( n ) + Θ ( n 2 ) = Θ ( n 2 ) 最坏划分的算法分析 通过上面的图示我们知道了在最坏情况下快速排序的复杂度是 Θ ( n 2 ) ，但以图示的方式并不是一种严谨的证明方式，我们应该使用代入法来证明它。 当输入规模为n时，时间 T ( n ) 有如下递归式： T ( n ) = m a x      0 ≤ r ≤ n − 1 ( T ( r ) + T ( n − r − 1 ) ) + Θ ( n ) 除去主元后，在Partition函数中生成的两个子问题的规模的和为n-1，所以r的规模才是0到n-1。 假设 T ( n ) ≤ c n 2 成立，其中c为常数这个大家都知道的。于是上面的递归式为： T ( n ) ≤ m a x      0 ≤ r ≤ n − 1 ( c r 2 + c ( n − r − 1 ) 2 ) + Θ ( n ) ≤ c ∗

Recno:: 38
URL:: http://blog.csdn.net/nomasp/article/details/50376050

ParseText::
nomasp的2015博客之星投票总结 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 nomasp的2015博客之星投票总结 标签： 博客 总结 投票 回顾 展望 2015-12-22 01:29 610人阅读 评论 (8) 收藏 举报 分类： TechLife （7） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 通过这次投票我学到了很多。 很久之前 我几乎没在CSDN写过个人的感触这种东西，因为感觉这是一个开放的平台，并不想去像流水账一样去记录自己的琐事，至于为何会写这一篇后文会有提到。 因此这篇文章也不仅仅是投票的总结，也包含了很久之前的事情。忽然想到如果评委们看到了这篇文章，发现我才大三，会不会给我扣很多分叻；不过还是得写，因为难得在线上总结一次，当然得真诚。 进了大学才知道编程这东西，军训结束就加入了社联科技部以及计算机协会，毕竟还是想当技术宅。大一上学期唯一的专业课就是C++了，前面几章都像模像样的学了，后面几章因为课时不够老师上课很赶，我也没来得及看。年底有创新杯，于是开始学了C#以及WP的开发，来年写了两个很简陋的APP在学校弄了个奖。然而，并没有什么用，因为获奖的APP是通过微软的工具生成的，一行代码不用写。后面都发生了什么我也不想赘述下去，总而言之，我根本不知道要学什么，该怎么学。 所以，这是我写博客的初衷之一， 希望能够给予刚踏进大学的童鞋对专业方向的指导 。因为回头想想，我走了太多的弯路，浪费了很多的时间。我一直都想着以后工作几年了可以回学校在计协给同学们上一届非常系统的导论课。 在”二本“的大前提下，我相信还是超过了不少人的，而上文也说了我浪费了很多时间，这其中的原因是 不玩网游 ，从来不玩有点夸张，不过网游（只玩过CF）三年只玩过不超过10局。 大一暑假写了一个WP平台的2048小游戏，加入了两个全新的玩点：不规则的面板以及同时操作2个面板，且都上线了。虽然意义不大，不过也算是体会到了整个流程，甚至试着加入了广告，当然，仅仅是为了学习如何用广告SDK。 踏入CSDN 虽然大一就在用CSDN，不过在这里有所分享还是在大二年底。当时又是一届创新杯，我试图使用OpenCV写一个相机程序到WP平台，因为OpenCV在WP上的支持不完善以及C++我不太会用的原因导致项目再次失败。不过在学习OpenCV的过程中，看到了浅墨（毛星云）的博客，MVP的光环深深的震撼了我。后来也跟着写了一些博客，最后觉得当时的ID太low，今年年初换了新ID。 经一位学长介绍了《计算机程序的构造和解释》这本书，在此之前看过一阵子田春翻译的Common Lisp，对函数式编程充满了强烈的兴趣和感情——至今唯一让我可以通宵看书码字的语言。于是有了现在的ID，nomasp。寒假在家刷SICP上的题目，刷了接近两百道的样子； 每题都成了博客，就这样反复发博客才养成了坚持写博的好习惯 ，只要CSDN不倒相信我会一直写下去，即便倒了也会在个人博客里写下去。 《黑客与画家》作者说LISP就像一个宗教，的确，学习的时候就可以明显感受到，自己就像语言的一员；在LISP社区的一次提问，关于丘奇计数，没想到大家称其为祖师爷。我最喜欢的是Lambda、流，还有很多先进的特性，比如惰性求值、可编程。以后还会继续深入这一领域。 问过一些同学为什么不写博客，得到了3个答复：坚持不下来、不知道写什么以及水平不够。我的观点是， 量变产生质变 。小时候字很丑，六年级语文老师让我每天抄课文，800字，我抄了整整一年；即便是冬天，我也在火炉旁边抄完了。有次博客中因为公式不好输入只好手写，评论区有人说我字挺好，就是当年的坚持。不知道写什么是因为没有用心去想，无论是上课笔记还是课后总结不都可以吗？水平不够，记得春晚上有个小品中针对城市乡镇问题的一句话，大意是哪个人往上3代不是在农村，往上4代、5代呢；这里也是一样，哪个程序员往前倒退5年、10年不是菜鸟呢。同样的，也不用担心文章水平不够，毕竟阳春白雪和下里巴人都有其各自的消费群体。 发现新世界 后来在写Windows App开发的博客，因为大二下学期后来要考试了没能完成当初计划的章节内容有些遗憾了。期间申请通过了博客专家，认识了很多很多大神。在最近的投票过程中，我发现有些人抱怨CSDN不好种种；而我觉得， 有些东西，只有用心付出了才会得到回报 ，当然真心付出了却也不计回报了；这不是和 越努力越幸运 一个道理么。 圈子也不再只是学校那么小了，有读者发邮件了，有读者加QQ了，我也都逐个热心回应。后来发现论坛在招募版主，于是试着申请了小版主，很多问题我还没有遇到过也无从解答，能解答的包括上网自己搜一遍也都好好解答了。其后还申请了微软的MSP，这又让我了全国各地更多的童鞋们，他们也帮我投了不少票。 投票总结 因为前期了解过，知道去年有10个名额的入围奖，所以想试试能不能入围。可能因为我比较积极，10号早上喊了几个同学帮我投票当时还是第一。不过早有预想，没错，仅仅花了一小会时间洪洋大神就超过了一大截，事实证明早起的虫儿被鸟吃。后来排名跌跌撞撞稳定在了六七名，至于最后为什么成了第四，一是因为前面有人离开了，二是因为大家的鼎力支持。 今天就有人在博客评论区问我人气从哪来，大神有自己的粉丝和同事，而菜鸟有自己的朋友和同学，正如前面举的阳春白雪与下里巴人一般。 投票期间也看了很多博主的博客，除却技术外，貌似我和读者交流明显少很多。其中的原因主要就是我不太想把CSDN博客当作日记，不留名和姓，只是希望有人在需要的时候通过搜索引擎搜到我的博客解决了问题就好。想不清是哪位，记得对方记录了很多大学的日常，也许等我毕业了可以好好的总结一下留一下有益的给大家作为参考指导吧。为了更好的交流，我也换了真人未PS的照片以及建立了多个QQ群。 总有些意外的事情会发生 ，没想到票数能进前十，更没想到票数居然会出现一样的情况。结束后有朋友发消息过来说恭喜，我只好各个解释投票只占比50%。其实我很慌。一方面，放平了心态接受生活中已发生以及即将发生的一切；另一方面，为投票也花了不少时间，至少天天都盯着票数看。 展望 最近最担心的事情有两个，一个是这个大赛结果，另一个就是创新杯的项目了。此前都很恐惧网络，很少有这方面的，顶多是一些API的。而这次，我计划将项目整个搬到微软的Azure上，再写Android和UWP的App，团队还需要写一个Chrome插件以及设计精致的图标和视频广告以迎接这个比赛。3个月的时间能不能完成这些呢，我很期待，也很紧张。但是，我真的很喜欢这个项目，从最初只有一个功能（调用OneNote的API）以及一个目的（学习Android练手）到现在完成的两个功能（其中一个功能找遍整个中文网络没有找到解决方案，等完善好了开源出来），再到规划的跨平台以及更多创意的设计构思，简直就像是我培育的孩子，这也是我喜欢写软件的原因，因为它能够不断的更新和进化。希望它能够顺利且按时被我完成并上线。 大学以来脑袋明显反应慢了，听说这是因为学的东西多了，也许吧，和电脑一样。算法还是得通过反复的习题来学习和巩固，继续坚持AOJ以及LeetCode。除了刷题以外，控制以后发博客的数量，提高质量，完成真正高水准的文章，花更多时间支持开源。 还是用初中备战中考时写的座右铭来结尾： 脚踏实地，全力以赴！ 完成时间 2015/12/22 - 1：28 第一次修改 2015/12/22 - 1：44 修改了错别字 上一篇 【万字总结】快速排序详解与各种线性时间排序对比 下一篇 一种巧妙的反转字符串的方法及思考过程 顶 10 踩 0 我的同类文章 TechLife （7） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577535次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 39
URL:: http://blog.csdn.net/nomasp/article/details/50379810

ParseText::
一种巧妙的反转字符串的方法及思考过程 - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 一种巧妙的反转字符串的方法及思考过程 标签： string namespace 需求 反转 reverse 2015-12-22 14:37 476人阅读 评论 (0) 收藏 举报 分类： C++ （8） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 如题，需求是反转字符串，当然啦方法是有很多的，这种我觉得蛮有意思的^_^ #include <string> #include <iostream> using namespace std ; int main() { string s; cin >>s; for ( int i = s.size(); i--; ) { cout <<s[i]; } cout <<endl; return 0 ; } Input : abc Output : cba 这段代码的特点是 i − − 是放在了判断语句中，起初我不是很能理解，不过根据输出断定了是i等于0的时候就退出了循环。经过打断点来测试，证实了这个猜测。 为了证实这个猜想，我继续写了两段简短的代码。 #include <string> #include <iostream> using namespace std ; int main() { string s; cin >> s; for ( int i = s.size(), j = s.size() - 1 ; i--, j--;) { cout << s[i] << " " << s[j]; } cout << endl; return 0 ; } Input : abc Output : c bb a 最终的状态是： i = 1, j = 0 另一段代码是： #include <string> #include <iostream> using namespace std ; int main() { string s; cin >> s; for ( int i = s.size(), j = s.size() - 1 ; j--, i--;) { cout << s[i] << " " << s[j]; } cout << endl; return 0 ; } Input : abc Output : c bb a （输出这部分后程序崩溃） 最终的状态是： j = -1, i = 0 第一段代码表明自减操作有返回值，且就是这个变量的值；那么为什么第二段代码中j减到0之后还会继续减少呢，之所以继续减少是因为循环还在走，之所以循环没有退出是因为这里的逗号运算符的结果取最后一个。 还有一个小细节，我不是很清楚，因为很少在实际码字中用过，那就是判断中是因为0才停止的，那么负数呢？也就是说负数直接类型转换是true还是false呢。 #include <iostream> using namespace std ; int main() { if (- 1 ) cout << "t" ; else cout << "f" ; return 0 ; } Output : t 紧接着我又尝试了在C#中的情况，这里无法自动将int转换成bool，只得写了一个方法。 class Program { static void Main( string [] args) { string s; s = Console.ReadLine(); for ( int i = s.Length; isBool(i--);) { Console.Write(s[i]); } Console.WriteLine(); } static bool isBool( int n) { if (n > 0 ) return true ; else return false ; } } Input : abc Output : cba 总而言之，好吧我承认很Easy，不过其过程却是充满了乐趣，就喜欢这种假装探索的感觉。Bye…… 上一篇 nomasp的2015博客之星投票总结 下一篇 LeetCode 292 Nim Game（Nim游戏） 顶 2 踩 2 我的同类文章 C++ （8） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577541次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 40
URL:: http://blog.csdn.net/nomasp/article/details/50389513

ParseText::
LeetCode 292 Nim Game（Nim游戏） - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 LeetCode 292 Nim Game（Nim游戏） 标签： 函数 游戏 leetcode nim 算法 2015-12-23 20:24 633人阅读 评论 (0) 收藏 举报 分类： LeetCode （41） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 翻译 你正在和你的朋友们玩下面这个Nim游戏：桌子上有一堆石头，每次你从中去掉1-3个。谁消除掉最后一个石头即为赢家。你在取出石头的第一轮。 你们中的每一个人都有着聪明的头脑和绝佳的策略。写一个函数来确定对于给定的数字是否你可以赢得这场比赛。 例如，如果堆中有4个石头，那么你永远也无法赢得比赛：无论你移除了1、2或3个石头，最后一个石头都会被你的朋友所移除。 原文 You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1 , 2 , or 3 stones you remove, the last stone will always be removed by your friend. 分析 题目一开始不是很理解，因为朋友如果有2个、3个、多个的情况是完全不一样的呐，后来仔细一看原文第一句 w i t h y o u r f r i e n d ，发现只是和1个朋友玩游戏。 于是我设定了一个判断条件 bool yourTrun = true ; 后面巴拉巴拉写了一堆代码全错…… 加上一天的劳累我开始趴着睡觉了，脑子里还在回想。忽然发现： 1 - true 2 - true 3 - true 4 - false 5 - true 6 - true 7 - true 8 - false 然后抬起头重新写了一遍： bool canWinNim( int n) { if ((n - 1 ) % 4 == 0 || (n - 2 ) % 4 == 0 || (n - 3 ) % 4 == 0 ) return true ; else return false ; } 哇，通过了，感觉整理整理： bool canWinNim( int n) { return (n - 1 ) % 4 == 0 || (n - 2 ) % 4 == 0 || (n - 3 ) % 4 == 0 ; } 继续整理，原来这么简单呐： bool canWinNim( int n) { return n % 4 != 0 ; } 忽然就不困了。^_^ 代码 class Solution { public : bool canWinNim ( int n) { return n % 4 != 0 ; } }; 上一篇 一种巧妙的反转字符串的方法及思考过程 下一篇 LeetCode 258 Add Digits（数字相加，数字根） 顶 0 踩 0 我的同类文章 LeetCode （41） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577540次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 41
URL:: http://blog.csdn.net/nomasp/article/details/50392541

ParseText::
LeetCode 258 Add Digits（数字相加，数字根） - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 LeetCode 258 Add Digits（数字相加，数字根） 标签： leetcode 算法 digits add c 2015-12-24 10:17 651人阅读 评论 (0) 收藏 举报 分类： LeetCode （41） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 翻译 给定一个非负整型数字，重复相加其所有的数字直到最后的结果只有一位数。 例如： 给定sum = 38，这个过程就像是：3 + 8 = 11，1 + 1 = 2，因为2只有一位数，所以返回它。 紧接着： 你可以不用循环或递归在O(1)时间内完成它吗？ 原文 Given a non-negative integer num , repeatedly add all its digits until the result has only one digit. For example: Given num = 38 , the process is like: 3 + 8 = 11 , 1 + 1 = 2. Since 2 has only one digit, return it . Follow up: Could you do it without any loop/recursion in O( 1 ) runtime? 分析 其实我并不会写，循环和递归都不能用……我还能怎么办呐。 然后看了LeetCode上给的提示，看了维基百科的一篇文章：Digital root。 有了这个的话，就很容易了；具体这个公式的细节，大家自己参看维基吧，因为篇幅过长就不翻译了。 代码 class Solution { public : int floor ( int x) { return (x - 1 ) / 9 ; } int addDigits( int num) { return num - 9 * floor (num); } }; 上一篇 LeetCode 292 Nim Game（Nim游戏） 下一篇 LeetCode 104 Maximum Depth of Binary Tree（二叉树的最大深度） 顶 0 踩 0 我的同类文章 LeetCode （41） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577532次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 42
URL:: http://blog.csdn.net/nomasp/article/details/50393082

ParseText::
LeetCode 104 Maximum Depth of Binary Tree（二叉树的最大深度） - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 LeetCode 104 Maximum Depth of Binary Tree（二叉树的最大深度） 标签： path 二叉树 leetcode 2015-12-24 11:02 633人阅读 评论 (0) 收藏 举报 分类： LeetCode （41） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 翻译 给定一个二叉树，找出它的最大深度。 最大深度是指的从根节点一直到最远的叶节点中所有的节点数目。 原文 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int dfs (TreeNode* root) { if (root == NULL) return 0 ; return 1 + max(dfs(root->left), dfs(root->right)); } int maxDepth(TreeNode* root) { return dfs(root); } }; 上一篇 LeetCode 258 Add Digits（数字相加，数字根） 下一篇 LeetCode 237 Delete Node in a Linked List（在链表中删除节点） 顶 1 踩 0 我的同类文章 LeetCode （41） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577525次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 43
URL:: http://blog.csdn.net/nomasp/article/details/50401873

ParseText::
LeetCode 237 Delete Node in a Linked List（在链表中删除节点） - nomasp - 博客频道 - CSDN.NET nomasp Some people die at 20 and aren't buried until 80. 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 LeetCode 237 Delete Node in a Linked List（在链表中删除节点） 标签： 函数 链表 leetcode list node 2015-12-25 10:58 241人阅读 评论 (0) 收藏 举报 分类： LeetCode （41） 作者同类文章 X 版权声明：本文为 nomasp柯于旺 原创文章，未经许可严禁转载！欢迎访问我的博客：http://blog.csdn.net/nomasp 翻译 给定一个访问节点的路径，写一个函数去删除在一个单向链表中除尾部以外的节点。 假设这个链表是 1 -> 2 -> 3 -> 4 ，并且你被给予了第 3 个值为 3 的节点，那么在调用你的函数之后这个链表应该变为 1 -> 2 -> 4 。 原文 Write a function to delete a node (except the tail) in a singly linked list , given only access to that node. Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3 , the linked list should become 1 -> 2 -> 4 after calling your function. 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode (ListNode* node) { if (node == NULL) {} else { ListNode* tmp = node->next; node->val = tmp->val; node->next = tmp->next; delete tmp; } } }; 上一篇 LeetCode 104 Maximum Depth of Binary Tree（二叉树的最大深度） 顶 1 踩 0 我的同类文章 LeetCode （41） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 NoMasp 访问： 577523次 积分： 12837 等级： 积分：12837 排名： 第505名 原创： 413篇 转载： 0篇 译文： 11篇 评论： 561条 Notice： ^ nomasp 博客导航 ^ 欢迎您访问我的更多博客文章 《 nomasp 博客导读 》 点击此处即可轻松导航喔 感谢您的支持，希望我的博客对您有所帮助 转载请联系本人 ^ 个人信息 ^ * 邮箱： kinhiox#gmail.com * 备用邮箱： nomasp#outlook.com * CSDN 博客专家、论坛版主 * 微软MSP Billboard * 欢迎入群交流 * 【UWP开发交流群】 523310660 * 【Android开发交流群】 303295519 * 【算法交流群】 376079805 微博 博客专栏 UWP通用应用开发 文章：6篇 阅读：9475 Android 开发 文章：6篇 阅读：5733 LeetCode 文章：27篇 阅读：18469 算法 文章：10篇 阅读：42943 万里征程——Windows App开发 文章：37篇 阅读：86176 欧拉工程 文章：0篇 阅读：0 OpenCV归纳 文章：5篇 阅读：14524 Scheme归纳 文章：13篇 阅读：45166 SICP练习 文章：151篇 阅读：179579 文章分类 nomasp 博客导读 (1) Algorithm (31) Books (2) C (1) C++ (9) C# (5) CampusLife (1) Data Structures (9) Fun (9) Git+Github (2) HTML5 (0) IT-Talk (7) Learning World (1) Mathematics (1) Music (1) OpenCV (6) OpenXML (1) Project Euler (9) Scheme & SICP (14) SICP Exercise (151) TCP/IP (3) TechLife (8) Useful gadgets (18) Windows 10 (30) WPF (4) Android Errors (5) Android Notes (11) Windows App (10) Linux Notes (5) LeetCode (42) Android (9) Java (3) UWP (10) Kinect (0) AOJ and POJ (5) 文章存档 2015年12月 (30) 2015年11月 (20) 2015年10月 (19) 2015年09月 (35) 2015年07月 (13) 2015年06月 (28) 2015年05月 (48) 2015年04月 (43) 2015年03月 (92) 2015年02月 (97) 阅读排行 【算法】1 由插入排序看如何分析和设计算法 (9405) 【算法】5 传说中的快排是怎样的 (7875) 怎样学习一门编程语言 (7072) 好玩的WPF第三弹：颤抖吧，地球！消失吧，地球！ (7048) nomasp 博客导读：UWP、Android、Algorithm、Lisp (6637) 【算法】4 五张图带你体会堆算法 (5690) 【SICP归纳】1 过程和代换模型 (5574) 【Scheme归纳】3 比较do, let, loop (5313) 【SICP归纳】2 高阶函数和数据抽象 (5112) 【万里征程——Windows App开发】页面布局和基本导航 (5006) 最新评论 【万字总结】图解堆算法、链表、栈与队列（多图预警） NoMasp : @superleexpert:可以加群以后一起刷LeetCode呐 【万字总结】图解堆算法、链表、栈与队列（多图预警） superleexpert : 详细且深入，又看了几篇LeeCode，学习学习！ 图论算法 有图有代码 万字总结 向前辈致敬 NoMasp : @turbo_mars_yang:哈哈 欢迎加入我博客侧边栏中的算法交流群来一块刷题呐 图论算法 有图有代码 万字总结 向前辈致敬 turbo_mars_yang : 收了收了！恰逢学数据结构的东西，很多东西都讲的通俗易懂，很受用！ nomasp的2015博客之星投票总结 NoMasp : @erlian1992:你的图标新换的么？ID我见过……共勉啦！ nomasp的2015博客之星投票总结 erlian1992 : 看了楼主这些，觉得自己差的好远，自己还的努力。 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @wu2304211:有的 【算法】1 由插入排序看如何分析和设计算法 NoMasp : @CaidChen:可以加群交流喔 nomasp的2015博客之星投票总结 yamorn : @yamorn:good nomasp的2015博客之星投票总结 yamorn : @yamorn:good

Recno:: 44
URL:: http://blog.csdn.net/qing_gee/article/details/47036247

ParseText::
ftp530 没有权限 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 ftp530 没有权限 标签： ftp 530 没有权限 2015-12-25 13:41 821人阅读 评论 (0) 收藏 举报 分类： IT技术 （7） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 出现ftp530 没有权限的错误，其实就是用户名和密码不正确，但是很多时候，我都恍惚觉得自己的用户名密码没有改动过，因为一直是保存的状态，但可能的情况是，你有很多台ftp server，显然你更改过密码和用户名，只是你自己不记得了，在这种犯2的情况下，你只会痛心疾首，此刻你需要做的就是 重新建一遍用户名和密码 ，包括fileZilla这样的客户端，以及FTP xlight这样的服务端。 错误原因见如下： 状态: 不安全的服务器，不支持 FTP over TLS。 命令: USER ftpuser111 响应: 331 需要密码 ftpuser111 命令: PASS ***** ***** ** 响应: 530 没有权限 错误: 严重错误： 无法连接到服务器 解决办法就是 重新建一遍用户名和密码 。 上一篇 There is no getter for property named '*' in 'class java.lang.String'之源码分析 顶 0 踩 0 我的同类文章 IT技术 （7） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157822次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 45
URL:: http://blog.csdn.net/qing_gee/article/details/47122227

ParseText::
There is no getter for property named '*' in 'class java.lang.String'之源码分析 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 There is no getter for property named '*' in 'class java.lang.String'之源码分析 标签： getter property class string sql 2015-12-25 12:36 703人阅读 评论 (3) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ There is no getter for property named '*' in 'class java.lang.String' ，此错误之所以出现，是因为mybatis在对 parameterType="String" 的sql语句做了限制，假如你使用 <when test="username != null"> 这样的条件判断时，就会出现该错误，不过今天我们来刨根问底一下 。 一、错误再现 想要追本溯源，就需要错误再现，那么假设我们有这样一个sql查询： < select id = "getRiskMember" resultMap = "BaseResultMap" parameterType = "String" > < include refid = "selectMember" /> < choose > < when test = "username != null" > and username = #{username} </ when > < otherwise > and safetylevel > 1 </ otherwise > </ choose > </ select > parameterType="String" ，这一点是必须得，参数类型必须是string。 该sql对应的mapper class中对应的方法为 List<Member> getRiskMember(String username); ，也就是说，传递的参数名为username，正常情况下，这样的配置合情合理。 <when test="username != null"> ，你有一个对应的test判断语句，也可能是if。 那么这个时候，项目运行该查询语句时，就会抛出 There is no getter for property named 'username' in 'class java.lang.String' 错误！ 二、解决办法 当然了，如果你没有时间来看源码分析实例的话，我想先告诉你解决办法，免得你被问题困扰。解决办法很简单，你只需要把 <when test="username != null"> 修改为 <when test="_parameter!= null"> 就好了，其他地方不需要改动（也就是说 and username = #{username} 不需要改动为 and username = #{_parameter} ），修改后的sql语句如下： < select id = "getRiskMember" resultMap = "BaseResultMap" parameterType = "String" > < include refid = "selectMember" /> < choose > < when test = "_parameter != null" > and username = #{username} </ when > < otherwise > and safetylevel > 1 </ otherwise > </ choose > </ select > 三、源码分析 当然了，如果你有时间的话，看一看源码分析，或者自己动手尝试一下，我相信你一定会大有所获！ ①、准备源码包 你需要这样两个文件，具体怎么下载我就不多说了，如果你需要的话，也可以加群120926808： mybatis-3.2.3-sources.jar mybatis-spring-1.2.2-sources.jar 当然了，你项目中对应的lib包也是相应的版本。 然后，我们把对应的源码进行反编译，生成对应的source，使用的工具是jd-gui.exe。 紧接着，我们来看看如何关联源码包，见下图： 我已经加载好了，如果是首次的话，可点击edit，在弹出的提示框中选择上一步保存的zip文件。 ②、测试用例 准备好源码包后，我们来写一个测试用例，直接main方法就可以，当然了项目不同，方法自然不同，简单的如下所示： public static void main (String[] args) throws IOException { SpringUtils.getSpringContext(); MemberMapper mapper = SpringUtils.getBeansByClassType(MemberMapper.class); mapper.getRiskMember( "00010001" ); } 我们在 mapper.getRiskMember("00010001"); 这行打上断点。 ③、debug调试 直接运行main方法，在断点处F5，进入到MapperProxy.java public Object invoke (Object proxy, Method method, Object[] args) throws Throwable { if (Object.class.equals(method.getDeclaringClass())) { return method.invoke( this , args); } final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); } 可以尾随debug进入到MapperMethod.java private <E> Object executeForMany (SqlSession sqlSession, Object[] args) { List<E> result; Object param = method.convertArgsToSqlCommandParam(args); if (method.hasRowBounds()) { RowBounds rowBounds = method.extractRowBounds(args); result = sqlSession.<E>selectList(command.getName(), param, rowBounds); } else { result = sqlSession.<E>selectList(command.getName(), param); } // issue #510 Collections & arrays support if (!method.getReturnType().isAssignableFrom(result.getClass())) { if (method.getReturnType().isArray()) { return convertToArray(result); } else { return convertToDeclaredCollection(sqlSession.getConfiguration(), result); } } return result; } 进入到该方法后，可以一直调试到 result = sqlSession.<E>selectList(command.getName(), param); 该行代码。此时，你需要按住ctrl键，同时点击鼠标左键，见下图： 在弹出框中选择open implementation，然后进入到DefaultSqlSession.java public <E> List<E> selectList (String statement, Object parameter) { return this .selectList(statement, parameter, RowBounds.DEFAULT); } 在 return this.selectList 行上打上断点，然后按F8快捷键进入到该方法继续调试，（限于篇幅，省略步骤，后续文章中使用…代替）、直到你进入到CachingExecutor.java public <E> List<E> query (MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { BoundSql boundSql = ms.getBoundSql(parameterObject); CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); } tips：猫腻就在 BoundSql boundSql = ms.getBoundSql(parameterObject); 这行代码的执行过程中。 （…）（省略步骤，个人调试过程中请注意。） 直到你进入到DynamicContext.java类时 public DynamicContext (Configuration configuration, Object parameterObject) { if (parameterObject != null && !(parameterObject instanceof Map)) { MetaObject metaObject = configuration.newMetaObject(parameterObject); bindings = new ContextMap(metaObject); } else { bindings = new ContextMap( null ); } bindings.put(PARAMETER_OBJECT_KEY, parameterObject); bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId()); } 此时，你不妨wait a moment，翻看一下该类的整体代码，你会发现： public static final String PARAMETER_OBJECT_KEY = "_parameter" ; public static final String DATABASE_ID_KEY = "_databaseId" ; 这里有两个常量，当然了，但看此处，也许你会发现 "_parameter" 这个关键字，但这时还说明不了什么，你且记住 bindings.put(PARAMETER_OBJECT_KEY, parameterObject); ，同时对 ContextMap bindings 对象留有一点印象。 key1 ：_parameter （…）（省略步骤，个人调试过程中请注意。） 然后，我们进入MixedSqlNode.java public boolean apply (DynamicContext context) { for (SqlNode sqlNode : contents) { sqlNode.apply(context); } return true ; } 该apply方法就非常有意思了，xml里配置的sql语句，会通过该方法转换为标准的sql（称之为标准，是值这形成的sql语句就是能够执行预处理sql查询的字符串），你不妨慢一点执行该循环语句。 第二次循环的时候，你就可以看到sql的雏形了，那么请继续。 （…）（省略步骤，个人调试过程中请注意。） 直到你发现， sqlNode的类型为ChooseSqlNode ，此时，你是否已经能联想到以下内容： < choose > < when test = "_parameter != null" > 事情开始变得明朗起来，真好。 （…）（省略步骤，个人调试过程中请注意。） 继续调试，直到你进入到ExpressionEvaluator.java public boolean evaluateBoolean (String expression, Object parameterObject) { Object value = OgnlCache.getValue(expression, parameterObject); if (value instanceof Boolean) return (Boolean) value; if (value instanceof Number) return ! new BigDecimal(String.valueOf(value)).equals(BigDecimal.ZERO); return value != null ; } expression的值为 username != null parameterObject的值为 {_parameter=00010001, _databaseId=null} 以上两个参数之间好像有点关系，但离源泉处还差那么几步，请继续。 紧接着，我们进入到OgnlCache.java public static Object getValue (String expression, Object root) { try { return Ognl.getValue(parseExpression(expression), root); } catch (OgnlException e) { throw new BuilderException( "Error evaluating expression '" + expression + "'. Cause: " + e, e); } } 进入到OgnlCache.java private static Object parseExpression (String expression) throws OgnlException { try { Node node = expressionCache.get(expression); if (node == null ) { node = new OgnlParser( new StringReader(expression)).topLevelExpression(); expressionCache.put(expression, node); } return node; } catch (ParseException e) { throw new ExpressionSyntaxException(expression, e); } catch (TokenMgrError e) { throw new ExpressionSyntaxException(expression, e); } } key2 ： 1. parseExpression(expression) 的类型为Node，其值为 username != null 。 2. root的类型为 DynamicContext$ContextMap (id=41) ，其值为 {_parameter=00010001, _databaseId=null} （…）（省略步骤，个人调试过程中请注意。） 当再继续执行的话，就回到了DefaultSqlSession.java public <E> List<E> selectList (String statement, Object parameter, RowBounds rowBounds) { try { MappedStatement ms = configuration.getMappedStatement(statement); List<E> result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); return result; } catch (Exception e) { throw ExceptionFactory.wrapException( "Error querying database. Cause: " + e, e); } finally { ErrorContext.instance().reset(); } } 此时错误已经抛出了，见下图 到了这，异常是找到怎么抛出了，但整体看上来，好像又缺点什么，没错，由于eclipse中无法再看到 Ognl.getValue(parseExpression(expression), root); ，所以就会造成困扰，我们通过反编译工具，可以看到getValue方法。 public static Object getValue (Object tree, Object root) throws OgnlException { return getValue(tree, root, null ); } public static Object getValue (Object tree, Map context, Object root) throws OgnlException { return getValue(tree, context, root, null ); } public static Object getValue (Object tree, Map context, Object root, Class resultType) throws OgnlException { OgnlContext ognlContext = (OgnlContext)addDefaultContext(root, context); Object result = ((Node)tree).getValue(ognlContext, root); if (resultType != null ) { result = getTypeConverter(context).convertValue(context, root, null , null , result, resultType); } return result; } 此时再结合key2给出的内容，我们可以知道，要在 {_parameter=00010001, _databaseId=null} 匹配到porperty为 username 的值是不可能的啦，这样的话，程序就会抛出 org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'username' in 'class java.lang.String' 错误了！ 该不该搁下重重的壳，寻找哪里到底有蓝天──周杰伦《蜗牛》 本文出自:【 沉默王二的博客 】 上一篇 wysiwyg富文本数据如何保存到mysql 下一篇 ftp530 没有权限 顶 1 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157839次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 46
URL:: http://blog.csdn.net/qing_gee/article/details/49306323

ParseText::
你不得不读的书籍清单 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 你不得不读的书籍清单 标签： 程序员 不得不读 书籍 2015-12-16 17:15 10877人阅读 评论 (64) 收藏 举报 分类： 北洋杂录 （9） 作者同类文章 X 书籍 （20） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 你不得不读的书籍清单，岁月如梭，转眼间2015年将要过去，本篇博文也就将告一段落！毕竟年复一年的累加下去，本篇文章可能会导致加载失败（笑，自嘲），约吗？让我们来年再战！ 我承认，无论什么行业的书都琳琅满目，如果你要想在芸芸众书中找出一本对研发技术有所提高、对问题有所解决、对生活状态有所改善、对工作方式有所转变之类的书，那绝对不是一件容易的事。 以下列出的书籍没有先后顺序，全凭我一时感觉。当然我会说出欣赏这本书的起因，不过为了给你一点建议，对其槽点，我可不会惜字如金！ 编号 封面 书名 分类 18 java编程思想（第四版） 研发编程 《计算机科学丛书：Java编程思想（第4版）》赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在BruceEckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。 请允许我扯一点题外话（这篇文章好像一贯这样的风格）。 大学行将毕业的时候，我就在淘宝上买了一本《java编程思想》，5年前的事了，不晓得是不是第四版，管他呢，也无法考核了，因为从苏州回洛阳的时候，把此书奉献给一位朋友了，不知道他是否珍惜这本赠书，否则我将为他感到汗颜。2015年4月份再次在京东上下单，又“装腔作势”的买了一本，买的时候十分爽快，觉得大可为我所用，定不辜负作者所托，然而，终究是让人失望了，直到前天被我翻阅，此书一直在寂寞的犄角旮旯中安静的待着。 再次读的时候，一种从未读过的感觉油然而生，可真是奇了怪了，大言不惭的说自己已经从事java编程数载的话，似乎有点不好意思说的出口了。这正是这本书的魅力，让我重新开始审视自己，审视我所从事的java编程，自己到底是否合格。答案显而易见，不合格！ “笔耕不辍”的又写了三篇关于读书的心得和尝试： java吸血鬼数字 操作符 万物皆对象 如果你看了诸如此三篇的文章，没有骂我王二是个瞎逼程序员的话，我都有点寝食难安。 好了好了，如果你是一名java工程师，这本书不得不读，当然了，你如果读过就算了，苦笑。 这本书厚啊，再加上是技术书籍（技术书籍本身就枯燥），无论原作者Bruce如何努力，读这样的书，如果不抱着一颗“必死”的决心，实难短时间内读完，我现在第四章才刚读完。 编号 封面 书名 分类 17 当我谈跑步时我谈些什么 社会人文 本书是村上春树第一本只写自己的书。如这般围绕一个主题，从正面书写自己，几乎从未有过。在长达四分之一个世纪里，日日都坚持跑步，各色各样的思绪从心底涌起……从夏威夷的考爱岛到马萨诸塞的剑桥，从日本村上市参加铁人三项赛，到踏上希腊马拉松长跑古道，他，永远奔跑。 没错，这次推荐的是《当我谈跑步时我谈些什么》，村上春树写的，非常有文艺气质的一本书，读起来就像微风佛面一样，很自然，很亲切。 说来惭愧，我总是念不好“村上春树”，100次中有90次念做“树上村树”，并非有意冒犯作者，只是作者的名字确实有些拗口，关于这一点就此打住，多谈会带来指责之声。我总以为村上春树获得了“诺贝尔文学奖”，但百度了一下，似乎是没有，这一点真让我诧异，我们知道小李子（泰坦尼克号号男主角）入围奥斯卡最佳男主角N多次，正所谓“春花秋月何时了，提名知多少？”，村上春树就被戏称为诺贝尔文学界的莱昂纳多！ 这本书我读了两章，我已经有一种要买跑步机的冲动，奈何家小容不下，如果非要容下，且得耗一番心思布局，家用跑步机这玩意确实要占用一大块面积，思前想后，终于还是没有决定要买，不过这个念想会持续一段时间。也许再多读两章，我就悄悄的买了。 诚如村上春树所说，我可能还没有爱上跑步这件事，如果我情愿去做，即使有雾霾，没有跑步机，我也会想办法去跑步。否则的话，即使买了跑步机，若“束之高阁”，那就适得其反了。最近几天，偶感风寒，嗓子发炎冒火，这更让我想念锻炼，想念打篮球的日子，或者跑步的日子，总归是有一些身体锻炼，方能保持健康。 扯了这么多题外话，请见谅。《当我谈跑步时我谈些什么》这本书确属良品，你不得不读！ 虽然只读了两章，但对作者的故事感同身受，想象着自己是那个跑步者，那个写作的人，哎，该说说这本书的缺憾呢，说什么好呢，我只能说“书太薄了，舍不得读完啊”，这样冠冕堂皇的理由，真有些力不从心。 编号 封面 书名 分类 16 微管理，给你一个技术团队，你该怎么管 项目管理 讲述创业团队、程序员、技术人员如何管，技术转向管理、互联网思维管理如何做 这本书对王二回到洛阳后的职业生涯有着转折点的纪念意义！为什么这么说呢，不是为这本书戴什么高帽子，确实有货： 王二回到洛阳时，还不怎么写博客，在ITEYE上只发表过寥寥数篇，都可以追溯到远古时代了。后来领导开始以身作则的把原创博客作为绩效考核的一项评分，到这份上，王二作为一名积极向上的好员工（说白了，最重要的是能工资能多拿几十块钱），写博客势在必行。 以下为了陈述是我自己的真人真事，就由第三人称转为第一人称。 这就为我在后来拿到这本书的奖品埋下了伏笔， 《微管理，给你一个技术团队，你该怎么管》章节试读感悟 ，这篇文章万分荣幸的获得了赠书，大姑娘坐花轿──头一回，拿到这本书后，前前后后左左右右读了好几次，觉得受用极了，还推荐给了领导，他花钱去买了一本（当时感觉自己也获得了领导的认可，乐呵着呢）。 这是回到洛阳后，读的第一本书，之后买书，写博客就一发不可收拾，我想这本书的意义也就值得纪念了！ 以上这些话算不得上是荐言，但又算什么呢，这就是王二写作的风格。至于这本书为什么不得不读，看书名就知道了，不用王二来证明，作为团队的管理者，懂得一些论调还是必须得，诸如： 木桶理论──决定桶的容量不是最长的那块板，而是最短的那块。 作坊式团队需要互补。 当然，最重要的是，杨立东这本书，写作风格非常棒，各种典故，让我觉得作者学问杠杠的，不过听人说，这家伙学过莎士比亚文学，好吧，看看窗外的风景吧，大风吹走了雾霾，蓝蓝的天啊！ 我在CSDN上也发表了几篇读书札记，如 微管理：给你一个技术团队，你该怎么管札记-高效团队的三驾马车 ，不过说实话，到现在我忘的差不多了，看到这句话，你也许就会骂我，这推荐个屁呢，但原因在我，我的团队人员就两个人，一个我，一个同事，还需要什么管理，所以呢，读这本书，你需要一个团队来让你管。 编号 封面 书名 分类 15 追风筝的人 社会人文 快乐大本营高圆圆感动推荐，奥巴马送给女儿的新年礼物。为你，千千万万遍！ 机缘巧合，就买了一本《追风筝的人》。我是一个没有自主思想的人，随波逐流已经成为我的生活习惯，买书也没有什么选择性，全凭推荐序言，别人说好，我就买。当然了，说书不好的人也推荐不了书！ 书看到一半的时候，我又去看了这部同名小说的电影，当然遗憾的是，当我看到哈桑被性侵的地方，就快进了，你知道，一但快进了，就预示着我心烦意乱了，那也意味着电影将不再完整，也没有继续看下去的劲头了。 看翻译的小说，我有一个贱毛病，总是对译者的用词挑三拣四，总觉得翻译的太过枯燥无味，很明显，这本书超出了我的意料，我竟然读完了。 阿富汗也是一个多灾多难的国家，在没有发生战争之前，那儿的人民生活得很幸福，追风筝的大赛上，孩子们脸上也洋溢着笑容，为他们的各自的胜利努力着，奔跑着。然而战争爆发后，一切都变了，为了生存，一切都变得那么艰难，痛苦。 我们的国家也遭受了灾难，鸦片战争爆发到改革开放结束，历史上的那段岁月，伤害始终萦绕着我们，挥之不去！最近看了一部电视，郭宝昌导演的《大宅门》，主人公白景琦的一生也在朝代的更迭中跌宕起伏，这和《追风筝的人》主人公所经历的世事都有着惊人的相似之处！ 这本书的推荐，我觉得我写得很烂。准备动笔的时候，思絮飘飞，待到动笔的时候，樯橹灰飞烟灭。但即使我写的不好，我也觉得这本书，你不得不读！ 书中最虐心的无非就是哈桑被性侵的那段描写，我读书的时候总由不得去想象那个画面，更糟糕的是，哈桑的孩子最后也成为了坏蛋的奴役，真没有比这个更糟糕的了！所以我本来是不喜欢这本书的，但有朋友又向我推荐了这本书，我想抛去这个糟糕，书中的故事还是值得去读的。 编号 封面 书名 分类 14 黄金时代 社会人文 她要讨论的事是这样的：虽然所有的人都说她是一个破鞋，但她以为自己不是的。因为破鞋偷汉，而她没有偷过汉。虽然她丈夫已经住了一年监狱，但她没有偷过汉。在此之前也未偷过汉。所以她简直不明白，人们为什么要说她是破鞋。如果我要安慰她，并不困难。我可以从逻辑上证明她不是破鞋。如果陈清扬是破鞋，即陈清扬偷汉，则起码有一个某人为其所偷。如今不能指出某人，所以陈清扬偷汉不能成立。但是我偏说，陈清扬就是破鞋，而且这一点毋庸置疑。 呦，看，王二这家伙开始推荐 王小波 的作品了，真是难得难得啊！ 是的，没错，其实王二这个称呼就是从《黄金时代》这本书上来的，我这样赤裸裸的剽窃了他在书中的称呼，确实觉得自己翅膀硬了些！ 其实吧，我真的应该承认我自己不喜欢干“程序猿”这一行，尤其是我特别喜欢读“社会人文”这类书，而对“研发编程”的书冷淡许多，这也就是为什么，在我推荐的书籍里，似乎“社会人文”的书偏多一些。 在一年前，对于王小波这个名字，我知之甚少，说白了，就是压根不知道这样一位大作家，好吧，说出来这句话，我就感觉我出卖了王二，也就是我，我不应该承认自己的无知。既然事已至此，我觉得还是稍微透露一下，为什么我会知道王小波，进而去读他的书。 还是《 一个人的书房 》，这个听书平台，不知不觉的就让我爱上她，并开始不断收听其出品的读书节目，这其中就包括了和王小波有关的两本书《沉默的大多数》、《就想开间小小咖啡馆》，好吧，关于这两本书，我就不多说了，嘻嘻，为了下次（也可能是下下次，等我了解了它们）我细致的推荐它们。 《黄金时代》，到目前为止，我只看了第一章“黄金时代”（已完）、第二章“三十而立”（未完），第一章写男主人和女主人之间关于破鞋的事情，第二章写男主人与几个女角关于出国未就的纠缠故事。好吧，我觉得让我来总结到底写了什么，真是难为了我，毕竟，我这个王二，在文学水平上和王小波的“ 王二 ”相距甚远，至于有多远，我保持沉默！ 这本书，我觉得也不得不读！ 要想吐槽这本书，真是难了点，不过幸好，我现在是胡说八道的 “王二” ，那就姑且挤一点出来吧，这本书里关于“伟大友谊”的描述有点多，如果你是女生读者的话，可要犹抱琵琶半遮面，倘若你是男生的话，我觉得，你可以为你的想象插上翅膀，尽情的享受那种心领神会的感觉吧！ 编号 封面 书名 分类 13 高性能mysql 研发编程 “只要你不敢以MySQL专家自诩，又岂敢错过这本神书？” 其实吧，这是我第二遍写《高性能mysql》的推荐，那第一遍呢？第一遍被我一个手贱的关闭按钮给夭折了！又没有打草稿，还得重新整理，嗬，真无（you）趣！ 作为一名26岁的挨踢人王二，也就是我，在5年多的职业生涯中，在头4年，对mysql都是一知半解，当然了，这一年多来，也还不曾到达了哪种高深的境界，但，至少，也总结了几篇相关的mysql技术文档，且让我来“王婆卖瓜自卖自夸”一下： mysql之死锁 mysql配置 mysql：提升性能的最关键参数 mysql：配置参数优化建议 高性能mysql札记：事务 其实吧，在同事的眼里，以前的王二是一个好大喜功的小青年。确实，这要是放在5年前，我认为能总结出来这几篇文章，我一定不会认为是《高性能mysql》给了我灵感，给了我帮助。但是，现在的我显然不会了，这几年的风吹雨打，我已经摇身一变，成为一个有涵养的程序猿啦。 所以，你看，依据我的经验，《高性能mysql》不仅仅能够让你深层次的去了解mysql的ACID、存储引擎innodb的好处，她还教会你做人，哈哈，如何学会感恩，所以，我觉得这本书，你不得不读！ 其实不知道是第几遍读《高性能mysql》了，虽然每次读都会有新的知识熔进我的脑壳里，但每次读，都会略过很多篇幅，因为这些知识，我可能一时半会儿用不到，即使绞尽脑汁学了，时间久了，也难免忘记。 编号 封面 书名 分类 12 乖，摸摸头 社会人文 《乖，摸摸头》是一本让读者时而含泪微笑，时而掩卷长思的奇书。 《乖，摸摸头》会让你触碰那些你或许永远都不会去体会的生活，认识那些你或许永远都无法结交的人。 就像大冰说的那样：不要那么孤独，请相信，这个世界上真的有人在过着你想要的生活 大冰，如果你还不知道他，我想你还是去度娘一下吧，反正我的记忆当中，关于他的介绍，我就觉得不像是生活在人世间的家伙！我能怎么说，“主持人”、“作家”、“旅行者”… 算了，我觉得我肯定没有度娘介绍的好！ @大冰 谁知道你能看到这条微博不，我可是照住你说得方法发的微博！ 书草草读了一遍，别打我，是草草，希望静下心来读第二遍，我26了，不想着去什么说走就走的旅行⊙▽⊙ 作为一个程序猿，兢兢业业撸着代码，只求有一个温饱的家庭，好吧，竟然有字数限制！ 这是我昨天晚上在新浪微博上发的，请别笑我，我也知道，这家伙肯定不会关注我的，我发的这个心情，他自然是看不到的。看不到又如何，我就是这么多此一举！ 昨天在看“成子”和“豆儿”的爱情故事，尤其是写豆儿妈妈在生下豆儿18天后就离开人世的情节，差点没有把眼泪流出来，是的，我就是这么容易伤感！ 当然，还有，大冰这家伙竟然主持了“叶世荣”的婚礼，我，简直不太敢相信这件事，我一直觉得他肯定在说大话。想想beyond中，除了灵魂 黄家驹 ，也就叶世荣让我最为怀念。 真的，第一次感觉到原来人还可以这样 肆意妄为 的活着，然而，这终究不会是我的世界，然而我确实羡慕这样的人生，足够精彩，足够精彩，足够精彩！ 《乖，摸摸头》，幸好我只看了这一本书，如果我把他其余两本书《他们最幸福》、《阿弥陀佛么么哒》也看了的话，我觉得我会有说走就走的冲动！所以，这本书，即使你是程序员，也不得不读！ 这几行绿色的字，要写槽点，我真是不知道说什么好，总有那么几本书，让你无法说出它的不好。好吧，我还是遵守约定吧，”欲加其罪，何患无辞“嘛，这本书的故事离我们大多数人的生活都太遥不可及，所以读完后，千万不要一时冲动，脱离了现有的生活轨迹！ 编号 封面 书名 分类 11 解忧杂货店 社会人文 东野圭吾倍受欢迎作品 不是推理小说 却更扣人心弦 中文版销量突破100万册 获2014年度中国影响力图书大奖 今天连续推荐两本”社会人文“方面的书，我其实是挺担心的，为什么呢？ 因为我怕暴漏出我的本性，其实，要不要告诉你们呢？其实 ——– 我内心并不喜欢做一名程序猿！好吧，好吧，我就这么快的吐露了心声，真不敢相信，自己好想再假装一段时间，毕竟我的职业真的是一名程序猿，很多大师都说，如果内心不喜欢做程序员，就要选择离开这个行业，做自己喜欢做的事情，可是我究竟想做什么呢？反正到目前为止，我真心不知道！（笑，如果你想笑，就尽管笑吧！哈哈哈） 言归正传，是吧，好的，马上就峰回路转！ 我之前就写过 解忧杂货店札记：回答在牛奶箱里 、 解忧杂货店札记：深夜的口琴声 两篇《解忧杂货店》的札记，感触挺多的，前前后后看完一遍，说实话，感觉自己的智商有点不太够用（笑，再笑，哈哈）。从第一篇“深夜的口琴声”到最后一篇“来自天上的祈祷”，故事人物都在紧密连接，我还专门搜罗了一下人物关系图，我真心不知道作者怎么把他们关联起来的，究竟是在什么状态下才能创作出这样的作品！ 每一篇都让人身临其境，我不止一次幻想着书中的场景：破烂不堪的浪失杂货店、鱼腥味十足的鱼店（好吧，我承认我忘记了叫什么名字了）、被大火烧焦的一片狼藉的孤儿院（我依然想不起来叫什么名字，隐隐约约想起一个字，但还是不确定）等等。 我必须说，日本人果然还是从我们中华文明中偷走了文化精萃，又或者是李盈春翻译的太好，我觉得这一本书的作者真心不像是一个日本人，而更像是一位精通汉语的中国人，直到现在，书中的个别字眼，如：“杵”、“欠身”、“喃喃”…，更让我倍感受用，因为如果我能用这样的文字写一篇文章，我觉得自己就是一个作家（对，我就是这么理解的）！ 介绍我就不多说了，你可以去看看我的读书札记，2015年5月份写的 解忧杂货店札记：深夜的口琴声 ， 解忧杂货店札记：回答在牛奶箱里 会更早。那时候自己的写作水平还很烂，很臭，希望你不会介意。因为，这本书，你不得不读（怎么样，这个理由说的够不够牵强附会）！ 又到吐槽的时候了，真痛苦，今天这是怎么了哦，这两本书，真真切切的让我说不出来什么不好！但同样的，我必须遵守规则，槽点还是必须要说的，请原谅我的刻板！这本书的人物关系真心一个复杂，幸好，“东野圭吾”这家伙真的是写推理小说的，不然我真是会怀疑自己智商的。 编号 封面 书名 分类 10 effective java 研发编程 “我很希望10年前就拥有这本书。可能有人认为我不需要任何java方面的书籍，但是我需要这本书”—–java之父 詹姆斯高斯林 当你看到书的封皮上印着java之父的话，你认为这本书需要不需要读呢？！答案如果是否定的，我觉得你可能不是学java的（哈哈，据我所猜想，就，也只能是这个原因啦）。 本篇文章发表后，还是受到不少朋友喜欢的，虽然有两个可恶的家伙踩了我两脚，并且也没有留下反对意见，但是，注意，是但是，我觉得这篇文章会细水长流，还是为为很多朋友带来参考意见的。 newsisyphus3天前 19:19发表 [回复] 写的不错，能不能有时间谈谈JAVA方面学习的方向，最近在学习JAVA，希望能给点建议！ 有个朋友想让我给点java的建议，这可让我有点惭愧了，我自认为自己的编程水平一般般（虽然我内心是极不承认这个观点的），给别人提供学习建议的事，我一直觉得非常高大上，非常有荣誉感，而我真的不够格（我还是不太承认这个观点的，哈哈）。不过，我觉得《effective java》这本书是值得一学的，不过，说实话，基于各种原因，我目前只读到第四章“类和接口”。 当然了，业界对这本书的评价也是很高的，那么我就不罗嗦了，这本书不得不读！ 当然了，我看这本书的感觉并不是很好，可能真的是我水平有限，或者我本质上的确是不喜欢编程的，我在读的过程中容易走神，书中的例子也尝试去做，但是还是很苦涩，这一定程度上影响了我的读书学习进度，对于java初学者来说，或许是有点不容易上手的。 编号 封面 书名 分类 9 浪潮之巅 社会人文 一个企业的发展与崛起，绝非有个领导强人即可达成。任何的决策、同期的商业环境，都在都影响着企业的兴衰。《浪潮之巅》不只是一本历史书，除了讲述科技顶尖企业的发展规律，对于华尔街如何左右科技公司，以及金融风暴对科技产业的冲击，也多有着墨。此外，这本书也着力讲述很多尚在普及或将要发生的，比如微博和云计算，以及对下一代互联网科技产业浪潮的判断和预测。因为在极度商业化的今天，科技的进步和商机是分不开的。 哈哈，又见面了，我决定暂时改变一下我的写作风格，自从读了Steve yegge的《程序员的呐喊》中毒颇深，深觉要在博文中增加和读者的交流，好了废话结束。 《浪潮之巅》一书，我好像是在订阅号上看到的，当时看完作者吴军先生的介绍，我，我，我的一种盲目崇拜之情就油然而生了，但是当时觉得这本书更像是一本历史书，对于我一个屌丝（貌似这个词以后要被整治，还是趁早多说两句吧）程序员，看这类书对我的薪水没有一点作用，没错，当时的我就是这么鼠目寸光。当然，故事到这里结束好像是有点早了，一个偶然的机会，静悄悄的获得了《极客头条》的赠书活动，我就在人民邮电出版社的“异步社区”中各种的扒拉，苦苦搜寻一本物有所值的书，经过两个多小时的“甄选”，我选择了《浪潮之巅》！ 拿到书后，她就成为了我睡前必读的书，现在已经翻阅到了《微软帝国》一章，心中感惑颇多，甚是欣慰。然而很遗憾，我只拿到了上册，下册没有拿到，我想双11我已经等不及要在某东上买下吴军的所有书了！ 到目前为止，我真心觉得作者的宏观真够大的，放眼望去，information technology的汪洋大海尽收眼底，而我呢，放眼窗外，只有层层的wumai（你懂的，我怕说多了被封锁博客）。所以呢，这本书，你不得不读了！ 本来这里是要吐槽的，但是我好像挺词穷的，不过，我还是会绞尽脑汁吐槽出了一点点的。这本书，是要教给我们透过现象看本质的，怎么去理解一个企业的兴衰成败。而我呢，也想通过此书，把控我们公司以后的发展轨迹，但是这本书给我的办法并不多（注：我目前还没看完，哈哈，这些话，你大可不必相信的）。 编号 封面 书名 分类 8 重构 改善既有代码的设计 研发编程 翻开书，局部变量是万恶之源。局部变量！？我非常愤怒的往下读。我要看看这家伙到底脑子是不是不正常。 接着一股恐惧袭上心头：他居然说的没错，有理有据。我最自豪的编程习惯（把中间值保存在局部变量里，作为简单的性能优化）显然是个坏习惯，书中明明白白的展示了这一点。 这本书接着告诉我，不要写注释。 以上这些话，是Steve yegge说的，当然正是他的介绍，让我对这本书重拾信心，之前由于翻看试读章节，发现自己不是很懂，感觉相当苦涩难懂，于是就搁置了，如今看来我真是害怕掌握知识，害怕学习，我知道自己错了，那么我接下来肯定是要去买这本书了，不得不读了。 也许是翻译的润色不够，也许本就苦涩，需要一点耐心和基础！ 编号 封面 书名 分类 7 无愁河的浪荡汉子·朱雀城 社会人文 《朱雀城》洋洋洒洒80万字，是《无愁河的浪荡汉子》的第一部。是以作者儿时的经历为蓝本创作的自传体小说。描写了黄永玉在湖南凤凰的童年生活和故乡风貌。小说最早发表于十几年前的《芙蓉》杂志，写到二十多万字，黄永玉搁笔。后来经作家李辉不断督促，黄永玉重新提笔续写，2009年在《收获》开始连载，续写字数长达50万之多。 能够了解到这本书，绝对是个缘分。我是《一个人的书房》的忠实粉丝，其上面发布的有声读物，绝对是一道有色有味的佳肴盛听，而这本书的朗读者“安德烈斯基”的声音浑厚而不失灵巧，书中的内容也让我受用不尽，反复听了几十遍，也觉得没有丝毫倦意。 而这本书的作者”黄永玉“老先生绝对够分量，90多岁的人了，耄耋之年的人了，却写出这般风趣的书，的确是个奇迹，而这位老先生最原始的身份是个 画家 ，而不是作家！这本书，我觉得不得不读了！ 看图片就能知道，这本书厚着呢，并且叙事风格老道，如果想要字字斟酌，需要花费一定的时间！ 编号 封面 书名 分类 6 程序员的修炼—从优秀到卓越 项目管理 写博客也一样。对于那些有抱负的博主们，我常常给他们这样一条重要建议：如果你新开了一个博客，在6个月之内别指望有人会去读它；如果你有那样的期待，我保证你会很失望。但是，如果你能够坚持一整年，并且每周能发布1-2篇高质量的博文，到那时候，也只有到那时候，你才可以寄希望于收获很小量的读者群。 这本书的作者是Jeff，翻译者是陆其明、杨溢。其内容都是Jeff的博文，但是按照了文章的类型进行了分类，内容通俗易懂，文如其题，就是通过作者的经验来告诉我们一个程序员在修炼过程中如何从优秀走向卓越。 我买这本书的缘由就是看了陆其明先生的博文，觉得翻译的确实不错，而我读书又不喜欢看电子书，于是就买了一本纸质的，前前后后看了两三遍，到现在虽然记忆中的并不是特别多，但是我觉得适合放在案头，闲暇之余就瞥几眼，里面的一些观点我很是认可，诸如上面提到写博客。 每个人最初写博客的起因肯定不同，而我是被迫写的，基于上司的要求，能够坚持下来，的确是因为爱上了写博客，虽然每篇的阅读量的确很少，文章质量也没有得到大多数人的认可，但是不求于名，只为心安，所以这本书，你也不得不读上一读。 这本书中章节都很简单实用，篇幅不长，但观点很多，如果记忆力不超群的话，看一遍留下的印象不够深，本来“书读百遍其义自见”，所以你可能需要多看几遍喽！ 编号 封面 书名 分类 5 程序员的呐喊 研发编程 亚马逊的主要语言中有两门非常啰嗦的语言C++和java，外加一门精炼的语言Perl。但是Perl正在遭受排挤，渐渐退出主流。我觉得这是因为Perl程序员可以用更少的人力完成和java/C++程序员同样的工作量，所以要是比人多的话，他们肯定是赢不了的。 能够拿到这本书，非常感谢@极客头条，也许是自己的努力，不经意间就获得了极客头条的赠书，当时还有一个T恤，很开心的穿了很久，觉得很得意。《程序员的呐喊》这本书到被我打入冷宫，可能是项目忙（但这个肯定是无聊的解释）的原因，一直没有机会翻阅，近几日读了读，感受只能用两个词来形容——–震惊！ Steve对java，对C++满腹牢骚，这让我感觉到自信受到了挑战，因为我就是一名java的程序员，并且只会Java。 后续我还看了《自由和保守》一节，于是在CSDN上相继发表了 我所经历的编程语言 、 崇尚自由，还是保守 两篇文章，尤其是第一篇，很多人就特别不满，觉得我盲目无知，竟然敢抨击C++不如Java，好吧，怨我了，谁让我被Steve说服了。 我是觉得，这本书的观点确实够犀利，如果你是一个固执己见的家伙，我觉得有必要来看看，大师眼中的世界是怎么样的，也许你就会有所领悟。所以，这本书，我觉得你也不得不读。 这本书美其名曰呐喊，说白了就是牢骚，不过大牛们发起牢骚也足够让你眼前一亮，每篇的篇幅都不短，是需要耐下来性子的，当然我有的时候感觉很多“废话”，不过看书总是要取其精华。 编号 封面 书名 分类 4 锋利的JQuery 研发编程 本书循序渐进对jquery的各种方法和使用技巧进行介绍，读者可以系统的掌握jquery中关于DOM操作、事件监听和动画效果、表单操作、AJAX以及插件方面的知识点，并结合每个章节后面的案例演示进行练习，从而掌握知识。 这本书我并没有完整的看完，很多时候都是用到jquery的时候从案边拿起来翻一翻，因为我毕竟是写服务端代码的，经常不在项目中运用的话，就容易忘记！ 这本书章节实例都很简单，如果稍微有基础编程的都可以学得来，但是又不乏一些灵巧的知识，诸如如果你想使用jquery获取一个DOM对象，如果想判断其是否为空，你该怎么做呢？ var dom = $( "#id" ); // 错误 if (dom) // 正确 if (dom.length > 0 ) 如果你想问我为什么，我觉得你还是去看看书比较好，当然我可不是出版商的代言人，也不是这本书的强烈追求者！好吧，如果你真的想知道，我还是告诉你吧！ 需要注意的是，$(“#id”)获取的永远是对象，即使没有这个元素。 还是那句话，这本书对于需要用到jquery的初级人员，是一本不错的选择，我认为有需要的，也是不得不读的。 当然了，如果你是前端的大牛了，我是觉得没有必要来买这本书了，毕竟jquery已经被很多人批评了，批评的人我相信都是有足够的理由的，虽然我觉得jquery还是挺方便的，但就 document.getElementById() 这一点，我就会选择使用jquery，好吧，我承认我就是一个水平不怎么样的编程人员（显然，这句话可信度并不高，哈哈）。 编号 封面 书名 分类 3 蒋介石自述上下册 社会人文 本书为蒋介石的个人自述言论集，书中虽然涉及蒋介石身世经历和政治军事活动，但笔墨着重于蒋介石谈孔孟、谈教育、说诗论文、修身养性等著述。是一本比较客观公正的蒋介石自述传记。与国内其他相关蒋介石的图书相比，本书在意识形态、政治方面对蒋介石基本没有误读或有意识的进行误导，从讲述蒋介石走下神坛，败走台湾下后的角度出发，力求客观、公正、真实地解读蒋介石其人。还原一个真实的蒋介石。 其实说这本书，我心里有些犯嘀咕，就在昨天2015年10月22日，我的博客就莫名其妙的被封了，我吓坏了，具体因为什么就不便多透露了，反正CSDN的管家是这样回复我的： 经查询，您的账号因中敏感信息被系统锁定，现已帮您解锁。 首先，再次声明，CSDN能够解锁，让我感激涕零。其次，我想说的是，推选这本书绝对是基于公平公正的原则，所以我引用了“某东”（为了打消我是个卖书，对于这一点，我可是极力避免）上的介绍语，我想表达的是，如果从一个人物上感受其人格魅力，对其言行举止有所了解，去真正的获取一些对我们人生有所帮助的认知，从而对我们的成长有所帮助。 这本书，我觉得就不便多说其内容，否则，万一有人再恶意举报我（我我我，真是怕再被封了，请原谅我的胆小怕事），我就冤死了！ 总之呢，这本书还是值得读的（我都不敢再使用“不得不读”这四个字，真是后怕）！ 这本书里面有不少好的修身养性的词句，并且对其母亲，他也是一个孝子，秉承了华夏子孙的优良传统。但是这本书看起来好像漫无目的，没有侧重，如果你是随意翻阅的话。当然了，看书必须是“心旷神怡”的状态，你才能发现其中的美好！ 编号 封面 书名 分类 2 人件 项目管理 作为管理者，我们很容易陷入一种典型的失败情境：习惯把人当做固定的模块来管理。 《人件》这本书相对于《人月神话》来说，更容易让你理解作者的观点（请注意，我可不是说人月神话的坏话，这本书稍候会做介绍），里面很简短的例子，更能让你将自己设身处地在作者的角色中，假如你正在走向管理者的岗位上！ 这本书我没有读完呢，我只读到第三部分，之前也在CSDN上发表了读书札记，然而随着时间的推移，或者项目的穿插，我不得不停止了这本书的研读。当然现在我还有重拾这本书，因为我觉得我的团队规模过小，目前只有两个人，导致很多方法我实施不了！ 不过，保持办公室的安静，不要做家具警察，不要让办公室处于黑暗状态等等的观点还是印入了我的脑海。 所以，《人件》也是你走向管理道路上不得不看的一本书！ 不过呢，这本书的观点很多，如果观点不能长期运用于项目管理中，很容易淡忘！况且管理对我们来说一门学问，也不是看了这本书就能够彻底的做一个好的管理者，把理论实践到团队中，才可能知道方法到底适不适合，所以，如果你想读这本书，建议你先有一片沃土，而不像我这么尴尬！ 编号 封面 书名 分类 1 代码整洁之道 研发编程 细节中自有天地，整洁成就卓越代码。 作为一个java出身的攻城狮，说实话，我应该惭愧，因为我拿到这本书的确有点晚，大概今年3月份我才买到这本书，并且很长时间把她束之高阁，好吧，现在说句sorry吧！ 代码整洁之道，给我最直接的印象就是，原来我曾经认为的很多“格言”都那么可笑！ 代码量和注释的完美比例是1:1！（曾经在江苏富士通的时候，我就是这么信以为真的，所以我会为每一个方法，每一个类，每一个分支等等都加上注释，以证明我的代码非常合理！好吧，读了代码整洁之道，你会幡然醒悟的） 一个方法尽量把你要做的任务完成！（看了代码整洁之道，我开始对我的代码进行重构，将尽可能重复的代码提炼出来，但是，这一点上我还做的很差劲！） … 当然，还有更多了！所谓“一屋不扫，何以扫天下”，你必须要从自身做起，对你的代码进行全方面的诊断，让其变得卓越。那么《代码整洁之道》，你就必须读一读了！ 想要改善代码，并非一朝一夕的事情，需要不断优化，再优化，方得要领。站在代码整洁的角度上来看，的确很多观点是正确的！我曾经也对方法名、字段名有着莫名的热恋，认为就应该如Robert所说，尽量名副其实，所以名字很长很长，但最近，我开始产生了怀疑，我是不是在走极端，过长的名字让整个文档看起来并不友好！所以请你注意了！ 另外这本书是基于java的优化，其他语言的，请注意了！ 经常不经意间就发现文章被扣到各式各样的网站上面，甚是可恶！ 那么人生何处不爬虫，爬虫请标 http://blog.csdn.net/qing_gee 见贤思齐焉，见不贤而内自省也！ 2015年的版本已结，期待2016年的书籍清单吧！ 上一篇 吸血鬼数字 下一篇 斐波那契数列 顶 55 踩 2 我的同类文章 北洋杂录 （9） 书籍 （20） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场

Recno:: 47
URL:: http://blog.csdn.net/qing_gee/article/details/49331543

ParseText::
wysiwyg富文本数据如何保存到mysql - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 wysiwyg富文本数据如何保存到mysql 标签： wysiwyg 富文本 保存 mysql 2015-12-24 14:45 1369人阅读 评论 (8) 收藏 举报 分类： Javaweb （32） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ bootstrap提供了一个叫 wysiwyg 的富文本组件，用来显示和编辑富文本数据，但如何将编辑后的数据保存到mysql数据库，却不得而知。另外，如何将mysql数据库中的数据显示到wysiwyg也不得而知，对于这两个问题，让我来告诉你解决方案！ 一、效果展示 首先，我们先来看看效果如何： 富文本中有一张图片，还有一个数字列表 我们可以看到编辑后的数据保存成功，以及保存后对应的展示。 二、富文本 度娘对于富文本的解释如下： 富文本格式（Rich Text Format, 一般简称为RTF）是由微软公司开发的跨平台文档格式。大多数的文字处理软件都能读取和保存RTF文档。RTF是Rich TextFormat的缩写，意即多文本格式。这是一种类似DOC格式（Word文档）的文件，有很好的兼容性，使用Windows“附件”中的“写字板”就能打开并进行编辑。RTF是一种非常流行的文件结构，很多文字编辑器都支持它。一般的格式设置，比如字体和段落设置，页面设置等等信息都可以存在RTF格式中，它能在一定程度上实现word与wps文件之间的互访。 如果说富文本不包含图片，我们可以使用普通的html转码方法，见标题四；如果富文本包含图片，普通的html转码已经满足不了我们了，就需要用到 jquery.base64.js ，见标题三。 那么同时，我们看一看mysql字段的定义： `description` longtext NOT NULL COMMENT '项目详细描述', 字段类型为longtext（LongText 最大长度4294967295个字元 (2^32-1)，虽然我也不知道到底有多大）。 三、jquery.base64 ①、引入jquery.base64.js <script type= "text/javascript" src= "${ctx}/components/jquery/jquery.base64.js" > </ script > 同时设置utf-8编码，确保中文不乱码. $.base64.utf8encode = true ; ②、富文本表单提交 var editor = "<input type='hidden' name='" + $ this .attr( "name" ) + "' value='" + $.base64.btoa($ this .html()) + "' />" ; 关键代码：将富文本对象的html值转换为base64，然后封装到表单form中。 详细见如下（一整个form提交的表单封装，参照与dwz框架）： /** * 带文件上传的ajax表单提交 * * @param {Object} * form * @param {Object} * callback */ function iframeCallback (form, callback) { YUNM.debug( "带文件上传处理" ); var $form = $(form), $iframe = $( "#callbackframe" ); // 富文本编辑器 $( "div.editor" , $form).each( function () { var $ this = $( this ); var editor = "<input type='hidden' name='" + $ this .attr( "name" ) + "' value='" + $.base64.btoa($ this .html()) + "' />" ; $form.append(editor); }); var data = $form.data( 'bootstrapValidator' ); if (data) { if (!data.isValid()) { return false ; } } if ($iframe.size() == 0 ) { $iframe = $( "<iframe id='callbackframe' name='callbackframe' src='about:blank' style='display:none'></iframe>" ) .appendTo( "body" ); } if (!form.ajax) { $form.append( '<input type="hidden" name="ajax" value="1" />' ); } form.target = "callbackframe" ; _iframeResponse($iframe[ 0 ], callback || YUNM.ajaxDone); } function _iframeResponse (iframe, callback) { var $iframe = $(iframe), $document = $(document); $document.trigger( "ajaxStart" ); $iframe.bind( "load" , function (event) { $iframe.unbind( "load" ); $document.trigger( "ajaxStop" ); if (iframe.src == "javascript:'%3Chtml%3E%3C/html%3E';" || // For // Safari iframe.src == "javascript:'<html></html>';" ) { // For FF, IE return ; } var doc = iframe.contentDocument || iframe.document; // fixing Opera 9.26,10.00 if (doc.readyState && doc.readyState != 'complete' ) return ; // fixing Opera 9.64 if (doc.body && doc.body.innerHTML == "false" ) return ; var response; if (doc.XMLDocument) { // response is a xml document Internet Explorer property response = doc.XMLDocument; } else if (doc.body) { try { response = $iframe.contents().find( "body" ).text(); response = jQuery.parseJSON(response); } catch (e) { // response is html document or plain text response = doc.body.innerHTML; } } else { // response is a xml document response = doc; } callback(response); }); } ③、富文本数据展示 $( '#editor' ).html($.base64.atob(description, true )); 通过base64对数据库中保存的html代码进行解码。 ④、wysiwyg组件 关于wysiwyg组件封装代码，我已上传到 CSDN的代码库 ，可详细参照。 四、普通html转码做法 function html_encode (str) { var s = "" ; if (str.length == 0 ) return "" ; s = str.replace( /&/g , "&gt;" ); s = s.replace( /</g , "&lt;" ); s = s.replace( />/g , "&gt;" ); s = s.replace( / /g , "&nbsp;" ); s = s.replace( /\'/g , "&#39;" ); s = s.replace( /\"/g , "&quot;" ); s = s.replace( /\n/g , "<br>" ); return s; } function html_decode (str) { var s = "" ; if (str.length == 0 ) return "" ; s = str.replace( /&gt;/g , "&" ); s = s.replace( /&lt;/g , "<" ); s = s.replace( /&gt;/g , ">" ); s = s.replace( /&nbsp;/g , " " ); s = s.replace( /&#39;/g , "\'" ); s = s.replace( /&quot;/g , "\"" ); s = s.replace( /<br>/g , "\n" ); return s; } 一般情况下，使用上面两个方法对html数据进行编码和解码，但是对于图片的保存却无能为力。 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 沉默王二的博客 】 上一篇 更改mysql数据库目录 下一篇 There is no getter for property named '*' in 'class java.lang.String'之源码分析 顶 3 踩 0 我的同类文章 Javaweb （32） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157819次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 48
URL:: http://blog.csdn.net/qing_gee/article/details/49886999

ParseText::
java把dbf文件写入远程2003服务器 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 java把dbf文件写入远程2003服务器 标签： java 文件写入 远程服务器 2015-11-17 14:21 701人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 重要的事情说三遍，有木有，java把dbf文件写入远程2003服务器，第一遍，第二遍，第三遍…够了，王二，还有完没有，赶紧点 需求 今天早晨，王二（也就是我）接到一个需求： 把行情的dbf库写入到远程windows server2003上！ 分析 之前，我就写过一篇 Java操作DBF文件数据库 ，但怎么把dbf写入到远程服务器上，这好像需要点什么。 于是我就去问度娘啊，看看有没有什么封装好的jar包之类的，好拿来用用。 折腾了一会关键字，终于找到了一篇 Java读写Windows共享文件夹 ，感谢博主的良苦用心啊，于是为博主点了一个赞。 拿来主义 第一步，下载JCIFS 网址： http://jcifs.samba.org/ 把jcifs-1.3.18.jar加入到项目jar包库中。 第二步，设置共享文件夹 ，当然需要设置用户名密码的 怎样让客户机访问windows2003服务器共享文件 第三步，demo ，先探探路通不通 public static void main (String[] args) { try { // 定义DBFWriter实例用来写DBF文件 DBFWriter writer = new DBFWriter(); writer.setCharactersetName( "GB2312" ); DBFField fields[] = new DBFField[ 1 ]; // S1 HQZQDM 证券代码 Char 6 fields[ 0 ] = new DBFField(); fields[ 0 ].setName( "S1" ); fields[ 0 ].setDataType(DBFField.FIELD_TYPE_C); fields[ 0 ].setFieldLength( 6 ); writer.setFields(fields); Object[] obj1 = new Object[ 1 ]; obj1[ 0 ] = "000001" ; writer.addRecord(obj1); String remoteUrl = "smb://abc:123@127.168.1.11/dbf/PENGBO.dbf" ; SmbFile smbFile = new SmbFile(remoteUrl); smbFile.connect(); //尝试连接 OutputStream fos = new BufferedOutputStream(smbFile.getOutputStream()); writer.write(fos); fos.close(); } catch (Exception e) { logger.error(e.getMessage()); logger.error(e.getMessage(), e); } } 注意remoteUrl smb:，不知道啥意思，应该是一种协议吧？王二，你这么一知半解，不好吧？额，那问问度娘吧 SMB(Server Message Block)是协议名，它能被用于Wap连接和客户端与服务器之间的信息沟通。 abc:123，你共享权限中指定的用户名和密码 127.168.1.11，自然是远程ip了 dbf，共享的文件夹 PENGBO.dbf，dbf文件名喽 第六，也没啥，如果上面5点没有说清楚，那么请私信王二，或者嘛，问度娘，美貌如花，有问必答？？？？ run一下 写到这应该算完结了吧，我觉得也是，可是王二偏要说再写点，好吧，我就应了自己吧！ 修葺 其实吧，写到上面这里，也确实算完了，无奈王二天生一颗追求完美的心，这面这段代码有点小遗憾， smbFile.connect(); //尝试连接 特别花费时间，而行情的dbf库实时刷新，这样肯定不行！ 那么需要做的就是，你看下面步骤，我决定放大招： 第一步，项目启动时初始化好远程连接 写一个DBFListener类吧 private static Logger logger = Logger.getLogger(DBFListener.class); private SmbFile smbFile = null ; private File file = null ; public void start () { try { if (Commonstants.remote_flag_dbf) { //需要远程写dbf String remoteUrl = "smb://" + Commonstants.username_dbf + ":" + Commonstants.password_dbf + "@" + Commonstants.path_info_dbf; smbFile = new SmbFile(remoteUrl); smbFile.connect(); logger.info( "dbf 远程连接启动成功！" ); } else { file = new File(Commonstants.path_info_dbf); logger.info( "dbf 本地文件创建成功！" ); } } catch (Exception e) { logger.error(e.getMessage()); logger.error(e.getMessage(), e); } } // 行情变化时，对行情进行写入 public void writeDBF (List<Quotation> dbfQuotations) { ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute( new Thread( new DBFThread(smbFile, dbfQuotations, file))); pool.shutdown(); logger.info( "dbf写入线程启动..." ); } 项目运行时，尝试连接远程dbf服务器 logger.info( "行情服务器开始连接dbf服务" ); int j = 1 ; DBFListener dbfListener = new DBFListener(); while ( true ) { try { dbfListener.start(); break ; } catch (Exception e) { logger.info( "5秒后开始尝试第" + (++j) + "次连接dbf服务，发生重连原因：" + e.getMessage()); try { Thread.sleep( 5000 ); } catch (InterruptedException e1) { logger.error(e1.getMessage(), e1); } } } DBFManager.setdbfListener(dbfListener); 第二步，模块化dbf操作 写一个dbf操作类DBFOperation public static void writeDBFByQuotation (SmbFile smbFile, List<Quotation> quotaionList, File file) { try { // 定义DBFWriter实例用来写DBF文件 DBFWriter writer = new DBFWriter(); writer.setCharactersetName( "GB2312" ); DBFField fields[] = new DBFField[ 30 ]; // S1 HQZQDM 证券代码 Char 6 fields[ 0 ] = new DBFField(); fields[ 0 ].setName( "S1" ); fields[ 0 ].setDataType(DBFField.FIELD_TYPE_C); fields[ 0 ].setFieldLength( 6 ); ... if (file!= null ) { FileOutputStream fos = new FileOutputStream(file); writer.write(fos); fos.close(); } if (smbFile != null ) { OutputStream fos = new BufferedOutputStream(smbFile.getOutputStream()); writer.write(fos); fos.close(); } 第三步，行情来时，写进去 dbfListener.writeDBF(dbfQuotations); logger.info( "写入DBF数据库结束" ); 这代码没法贴全，只好捡重要的贴出来，权当给一个参考。主要的思路就是，系统初始化就加载好SmbFile对象，然后对dbf写入进行封装，更灵活的应对远程写入还是本地写入，最后呢，行情刷新时能够启动线程写入，而不影响当前线程的性能。王二的编程能力很一般，虽然他老是不承认，没办法，谁让我就是王二呢？！ 相关文章 Java操作DBF文件数据库 王二语录 那么人生何处不爬虫，爬虫请标 http://blog.csdn.net/qing_gee 如果你能心无旁骛，专心致志地做好自己的事，做最好的自己，你就能在不知不觉中超越他人，跨越平庸的鸿沟，脱颖而出！—–写™的真好，可惜不是我王二写的！ 上一篇 mysql之修改表引擎 下一篇 沉默王二的黄金时代 顶 0 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157831次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 49
URL:: http://blog.csdn.net/qing_gee/article/details/49928473

ParseText::
沉默王二的黄金时代 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 沉默王二的黄金时代 标签： 沉默王二 黄金时代 程序员 2015-11-19 18:37 947人阅读 评论 (8) 收藏 举报 分类： 北洋杂录 （9） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 本来我是没有必要解释我为什么要写“沉默王二的黄金时代”的，因为我思故我在嘛，但想来我是一名程序猿，如果无缘无故的在这瞎扯这种人生题目，难免让人觉得我在无病呻吟。所以我打算讲一讲我写这篇文章的缘由，完了后讲我改名字叫沉默王二，然后讲王二的黄金时代，最后讲王二作为程序猿的何去何从。 缘由 其实缘由讲起来也容易，但如果按照“容易”的说法写这篇文字，可能就篇幅短了些，难免让人觉得我在博眼球（篇幅短也许就像穿得少—-王二注），这样不好，所以我要按照“不容易”的说法来写，那么请你一定要耐住性子（其实这是一种谦虚的说法，我还是能够让你 扒 出来内容的）。 我在CSDN发表了200多篇文章了，但是浏览量却上不来，这显然不是我想要的结果，为此我焦虑了很久很久，苦苦思索却不得要领。再加上没有高人指点一二，我实在是夜不能寐，食不下咽。 当然了，如果按照上面这个说法，那我写博客的目的就不够纯粹，带了很多功利性质，这样不好，容易被扣帽子，我可不愿意这样。所以我得总结，总结为什么我的博客浏览量不够，这可是我苦苦冥想出来的真理。 我的博客质量不过硬，这就像东施效颦一样，没有西施的那种闭月羞花、沉鱼落雁之美，何来倾国倾城。 没有粉丝，这点我觉得特别惋惜。虽然说浏览量微不足道，但多多少少还是有人瞥两眼的，至于说为什么人家瞥了两眼，没有为我点赞，没有和我交流，这就是我的不对啦，这就好比我是那街上浓妆艳抹的美女，而你就是匆匆瞥了我两眼的过客，然而你眼中充满的是另外一个美女的幻想，那就是这种滋味。 没有伯乐，所谓“那个赏识你的人来了”没有达到预期效果，至今我这匹千里马（显然我在为自己扣高帽子，不然呢）还没有得到伯乐们的赏识，苦苦的@伯乐，那人却杳无音讯，当然了，这一点如果要追本溯源的话，请看第1条。 … 听我废话这么多，我觉得我还得回归到正题上，我写这篇文章的缘由是什么，其实也和上面这些废话有关系，这就好比，你xxoo的时候要有前戏（这™有点太直接），或者说你屙屎之前可能要先放点五谷杂粮之气到外面（这话听起来怎么像在骂我自己）。不过这些举例都是不争的事实，所以你不应该发笑，因为你也这么干过。 为什么要说我的文章浏览量少，既然我找到了原因，那么我也就找到了解决办法，那就是 读书 ！ 所谓书中自有颜如玉，书中自有黄金屋，我就必须要多读书（所以我写了 你不得不读的书籍清单 ，自命清高的认为自己推荐的书还不赖），方能提高我的写作水平。 这些我读的书里面就包含了王小波的《黄金时代》，没办法，一个牛逼的作家还是能透过他的文字影响到他的读者的，显然，我就是被“蛊惑”的那一个（说我是他的读者，真是有点大言不惭；说被他蛊惑，是因为我找不到再合适的词来形容他对我的影响力）。 《黄金时代》这本书，其实我并没有读完，至于读了多少，反正是没有未读的多。不过，这恰恰就是我要写《沉默王二的黄金时代》的缘由，说白了，就是读后感（但不贴合实际，因为我未曾读完）。 书没有读完，我已经耐不住性子要写篇文章以示敬意，在这之前我已经迫不及待的改了我的CSDN名字，至于我为什么要改名，你切往下看！ 改名 写小说不可以用真名，尤其是小说里的正面人物。所以在本书里，没有一个名字是真的。小转铃可能不是小转铃，她是永乐大钟。王二不是王二，他是李麻子。 看到王小波先生这段话，你也许早就明白我为什么要改名为沉默“王二”了，当然了，如果你知道了，那就可以跳过这段，去看下个章节了。 但如果我就这么放你看下个章节，那我岂不是白费功夫，写改名这章节作甚，做嘛子？你说是吧？ 编号 头像 昵称 1 晴落花香 2 山下小青 3 沉默王二 这里面也是有一些故事要交代的，不然王二怎么会和我关联起来，而我又怎么会关联到李孝利，李孝利又怎么会关联到苍井空老师，我想，你一定会好奇！当然，你也许不会好奇，因为你可能和我有类似的心理。 至于编号1，这个图像和昵称，我都觉得最像虚拟世界（听说虚拟世界这玩意以后要火，什么Facebook啦，都在玩这科技，如果有可能，我想我应该是这个头像的样子）里的我，所以就不解释了，因为没有人（包括正在看这篇文章的你啦）喜欢了解一个男人的背后故事。 接下来是编号2，这个头像其实说起来很尴尬，曾经一位小伙伴还称呼我漂亮姐姐，好吧，其实李孝利在韩国就是被称为漂亮姐姐的，但是有人不乐意，有人说我一爷们，干嘛用一女人的头像，无非就是想增加点人气浏览量。说实话，我不想否认这观点，但又觉得理亏，其实我不应该觉得理亏的，我也不知道，这搞得我有点丈二和尚摸不着头脑。 互联网造就了我们这个发达的网络世界，也造就了一个辉煌的虚拟世界，就如同我记得高中的时候，一个同学玩传奇，他最牛的时候，就是在里面娶了一个媳妇，然后还养育了一个宝宝，听说养宝宝很贵的。 我是喜欢李孝利的，记得上高四（高三复读—-王二注）的时候，第一次用mp4看她Anycall广告中主唱MV《 AnyMotion 》及《 AnyClub 》，当时第一次感觉女人跳舞这么妖娆，身材一级棒！所以我想用她作为我的头像，这原本无可厚非。 No.3，也许这张你认不出来，如果你是男孩子，我可要问，“ 当年，你的左手是你的最爱，还是你的右手呢 ”，假如你还想不起来，我只能说你太不近乎人情。当然如果你是女孩子，看到这，想必也能认出这位美丽的大姐姐，她曾教给你无数华丽的岛国动作，好吧，说到这份上，我觉得我有点无耻。 至于为什么叫“沉默”王二，这也是因为 沉默的阿福 有史以来第一次上《程序人生》！ 不过现在我已经叫“王二”啦，至于你怎么看待我，我都保持沉默，或者说，发挥我作为程序猿的特性，用“闷骚”来回击你，当然也就是保持沉默这招杀手锏！ 黄金时代 下面，我将不再是我，我是王二，身高1米9O，是个篮球好手，曾经虐过无数小朋友，我的偶像是特雷西麦克格雷迪。 如何定义王二的黄金时代，也就是我的黄金时代，我觉得有点为难，因为我有点吃不准，原本我想拿王小波作品中王二的黄金时代来作为我博文中王二的黄金时代，但没有找到年龄界限，姑且从18岁开始算起，到26岁，抑或是到三十而立？ 当然啦，现在我可以糊里糊涂，因为我将不再是我！ 其实，我之前写过一篇 从小学到高中，一个程序猿的独白 ，看的人寥寥无几，我以为这篇文章可以上《程序人生》，但现实是没上。但这段时光，也刚好是我黄金时代的开始。 突然回想起来，我还写过一篇 职业生涯之初恋，没有攻略 ，其实这就应该囊入到我的黄金时代中，那将是我往事回首中历历在目的阶段。 王二从苏州回来后，定居在洛阳（或者说不叫洛阳，这容易暴露我的本身，也不知道为什么会叫洛阳，我其实挺想研究一下的，因为我身上有着一种叫做“格物致知”的精神，但终究我没有研究，有愧于这种精神）。随随便便在洛阳找了一家IT公司，就又来继续程序猿的生涯，说来也怪，王二天生与程序结缘。 在CSDN上的200多篇博客，也诞生于这段黄金时代。浑浑噩噩的这两年时光，王二买了房，成了家，唯一缺的就是“立业”，不过，俗话说，“三十而立”，离王二发迹的年龄还有段时日，还有得奋斗。 不过遗憾的是，这段时间，由于洛阳的软件产业确实不够景气，找点“耳鬓厮磨”的小伙伴，确实很难，也就说，找一个能够组成3对3打篮球的团队都很难，于是乎，王二不得不荒废了他的正业（我的副业才是写程序）—–打篮球，这真是亏了王二1米9O的身高，1米9O的男人还是不多见，尤其是像王二这么英俊潇洒，风流倜傥的男人，放眼程序猿的世界，从外形上看，王二这家伙就应该像张亮一样去走个模特，然后再上个“爸爸去哪儿”，一点都不具备程序猿的属性。 王二其实应该去学历史的，他不明白为什么要分文科和理科，并且当时的老师都说文科以后不好找工作，这包含教文科的老师! 于是只能默默地选择了理科，抛弃了他心爱的历史。当然，王二更不明白，从小学到高中，他连电脑（他很傻，当时见这玩意，叫TA“ 带疙瘩电视 ”）都没有摸过几次的人，竟然在上大学以后被专业调剂到“计算机网络专业”，从而开启了他的黄金时代—–也就是程序员世界。 也许每个理工男内心都有一颗玩文艺的心，就如《三体》的作者刘慈欣，“锤子科技”教英语的老罗（这伙计教会王二很多新鲜的词，“漂亮的不像实力派”、“东半球最好的工艺”，呀，好像他不是个理工男）。 王二也喜欢写文章，他的内心早就埋下了一颗“写作”的种子，等待时机成熟。 好吧，为了不显得我是虚构的，我决定还是用第一人称来描述这件事： 重要的事情要着色，并且加粗，我懂得： 今早的时候，电子工业出版社的刘芸女士找到我，问我有没有打算出书的意向 。 对于这件事，我觉得这是我黄金时代的一个重大转折点，从此，我将踏上“伪作家”这条不归路！ 说实在的，我内心暗暗窃喜（好像这样说，显得我有点虚伪，显然我为此高调的一塌糊涂，我高兴的向朋友炫耀，我甚至想打电话告诉我的父亲），但是，按耐住我狂热的内心，我还是滚回到了现实，我知道，自己几斤几两，也就是父亲常说的“一瓶子不响，半瓶子晃荡”，真是知子莫若父。 我还是百无聊赖的如实的吐露了自己的真实水平，还不到出书的水准，不过，至于未来有机会没机会，谁说的准呢？ 何去何从 写完了黄金时代，其实应该写“三十而立”呢，但我未到三十，所以无从写起，但我还想交代一些什么，毕竟像王小波的黄金时代，就交代了很多王二和陈清扬敦伟大友谊的事，但我的文学水平又够烂，若让我如王小波那样铺天盖地的谈论伟大友谊，显然强人所难，所以我还是谈谈 程序猿的何去何从 吧！ 不过，我是没有资格去谈“程序猿的何去何从”的，我唯一能谈的就是王二的何去何从！ 要谈我的何去何从，还得从我现在的公司谈起，但谈到这，又怕别人说我在发招聘信息，但若不发一些证据，证明我的现状，我又怕我在胡言乱语。 在洛阳干程序员这行当，要说月薪过万，我打死都不相信！当然了，倘若真有月入过万的公司，我就去投奔，毕竟很多人都说，跳槽才是升职加薪的最佳途径，我虽然不大同意，但多少觉得合情合理。 因为我就是从前任跳槽到现在的这个公司的，然后就可以挂着 项目总监 的头衔，不过要说挂项目总监这个事，我就觉得有点不妥，毕竟我手下—-没有手下，只有我的同事，我就是一个打杂的，项目架构，技术调研，联络客户，请客吃饭，打扫卫生，反正只要是个该干的，我就得干！ 当然，有这个头衔还是很好的，因为我可以制定弹性的上下班制度，这样便于自己睡个懒觉；我还可以给自己发工资，但显然经济大权不在我手；我也可以上班的时候睡觉，但我好像不会这么做，不像个领导的样子。最重要的是，我想看书，就看书，我想写博客就写博客，有点嚣张是不是？我也是这么觉得，但又如何，然并卵，我还是一个程序猿！ 最让我咬牙切齿的是，招聘人才，这一点就够我受的。 也有人给我们投简历，但我一个没有看上，说实在，不是我眼光高，而是洛阳做IT的人才稀缺，换句话说，想找一个“ 程序员陪聊师 ”都难以上青天！ 那么，这就是一个问题，也就是说，这是阻碍我 何去何从 的一个难题。可又有什么办法呢？谁也救不了我！ 不过人总是要积极向上的，我想唯有 坚持 方能守得云开见月明！ 好了，好了，听我唠叨了半天功夫，想必你也累了，不如停下来，我们一起喝个茶吧（我这句话纯属扯淡），下班回家才是王道，你说呢？！ 相关文章 从小学到高中，一个程序猿的独白 职业生涯之初恋，没有攻略 沉默的阿福 你不得不读的书籍清单 王二语录 那么人生何处不爬虫，爬虫请标 http://blog.csdn.net/qing_gee 平日不欣赏发馊的传统成语，更讨厌邪恶的现代成语，它麻木观感，了无生趣。文学上我依靠永不枯竭、古老的故乡思维。—-黄永玉 上一篇 java把dbf文件写入远程2003服务器 下一篇 ImageIO Can't create output stream! 顶 3 踩 0 我的同类文章 北洋杂录 （9） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157825次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 50
URL:: http://blog.csdn.net/qing_gee/article/details/50034319

ParseText::
ImageIO Can't create output stream! - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 ImageIO Can't create output stream! 标签： ImageIO 2015-11-25 11:53 537人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ java在生成验证码时，经常要用到ImageIO类，今天在一台windows 2008 server上部署好项目之后，项目怎么都刷不出来验证码，后台可以捕捉到的异常，里面包含有Can’t create output stream! 初步调查 在我开始写这篇解决问题的办法时，我还没有解决问题。 项目已经成功运行了很多个版本，在windows server 2003上运行OK。 在windows7上运行也OK。 但偏偏到了windows server 2008上却拉不出来验证码，真是引起了我极大的兴趣！ 主要的异常信息如下： ERROR 2015 - 11 - 25 10 : 25 : 44 , 061 com.honzh.socket.server.communicate.biz.CodeBiz: Can 't create output stream! javax.imageio.IIOException: Can' t create output stream! at javax.imageio.ImageIO.write(Unknown Source) Caused by: javax.imageio.IIOException: Can 't create cache file! at javax.imageio.ImageIO.createImageOutputStream(Unknown Source) ... 11 more Caused by: java.io.IOException: 系统找不到指定的路径。 at java.io.WinNTFileSystem.createFileExclusively(Native Method) at java.io.File.checkAndCreate(Unknown Source) at java.io.File.createTempFile0(Unknown Source) at java.io.File.access$100(Unknown Source) at java.io.File$1.createTempFile(Unknown Source) at sun.misc.IOUtils.createTempFile(Unknown Source) at javax.imageio.stream.FileCacheImageOutputStream.<init>(Unknown Source) at com.sun.imageio.spi.OutputStreamImageOutputStreamSpi.createOutputStreamInstance(Unknown Source) ... 12 more 透过这个异常信息，我开始追本溯源，当然就是翻看源码了。 先看 ImageIO.write 内容，可以定位到是createImageOutputStream抛出了IIOException异常。 public static boolean write (RenderedImage im, String formatName, OutputStream output) throws IOException { if (output == null ) { throw new IllegalArgumentException( "output == null!" ); } ImageOutputStream stream = null ; try { stream = createImageOutputStream(output); } catch (IOException e) { throw new IIOException( "Can't create output stream!" , e); } boolean val; try { val = write(im, formatName, stream); } finally { stream.close(); } return val; } 再看createImageOutputStream方法，可以定位到ImageOutputStreamSpi类的createOutputStreamInstance方法 try { return spi.createOutputStreamInstance(output, usecache, getCacheDirectory()); } catch (IOException e) { throw new IIOException( "Can't create cache file!" , e); } 然后，我们定位到OutputStreamImageOutputStreamSpi的createOutputStreamInstance方法， OutputStreamImageOutputStreamSpi继承了ImageOutputStreamSpi类 public ImageOutputStream createOutputStreamInstance (Object output, boolean useCache, File cacheDir) throws IOException { if (output instanceof OutputStream) { OutputStream os = (OutputStream)output; if (useCache) { return new FileCacheImageOutputStream(os, cacheDir); } else { return new MemoryCacheImageOutputStream(os); } } else { throw new IllegalArgumentException(); } } OK，关键的地方来了，我们继续挖，直到挖到 FileCacheImageOutputStream构造方法 。 public FileCacheImageOutputStream (OutputStream stream, File cacheDir) throws IOException { if (stream == null ) { throw new IllegalArgumentException( "stream == null!" ); } if ((cacheDir != null ) && !(cacheDir.isDirectory())) { throw new IllegalArgumentException( "Not a directory!" ); } this .stream = stream; this .cacheFile = sun.misc.IOUtils.createTempFile( "imageio" , ".tmp" , cacheDir); this .cache = new RandomAccessFile(cacheFile, "rw" ); this .closeAction = StreamCloser.createCloseAction( this ); StreamCloser.addToQueue(closeAction); } 到这里，我想你需要看一看该方法的javadoc了。 Constructs a FileCacheImageOutputStream that will write to a given outputStream. A temporary file is used as a cache. If cacheDiris non-null and is a directory, the file will be created there. If it is null, the system-dependent default temporary-file directory will be used (see the documentation for File.createTempFile for details). 让我们去看File.createTempFile方法，这时候就需要上java api帮助文档了！ createTempFile public static File createTempFile(String prefix, String suffix, File directory) throws IOException在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。如果此方法成功返回，则可以保证： 由返回的抽象路径名表示的文件在此方法被调用之前不存在。 此方法及其所有变体都不会在虚拟机的当前调用中再次返回相同的抽象路径名。 此方法只提供了临时文件的部分功能。要安排自动删除此方法创建的文件，可使用 deleteOnExit() 方法。 prefix 参数至少必须是三个字节长。建议前缀使用一个短的、有意义的字符串，比如 “hjb” 或 “mail”。suffix 参数可以为 null，在这种情况下，将使用后缀 “.tmp”。 要创建新文件，可能首先要调整前缀和后缀，使其满足底层平台的限制。如果前缀太长，则将它截断，但前三个字符将始终保留。如果后缀太长，则将它截断，但如果它以句点字符 (‘.’) 开始，则该句点以及后跟的前三个字符将始终保留。进行了这些调整后，通过连接前缀、五个或更多个内部生成的字符以及后缀，便生成了新文件的名称。 如果 directory 参数为 null，则使用与系统有关的默认临时文件目录。默认临时文件目录由系统属性 java.io.tmpdir 指定。在 UNIX 系统上，此属性的默认值通常是 “/tmp” 或 “/var/tmp”； 在 Microsoft Windows 系统上，该值通常是 “C:\WINNT\TEMP” 。在调用 Java 虚拟机时，可为此系统属性提供不同的值，但不保证使用程序更改此属性会对此方法使用的临时目录产生影响。 参数： prefix - 用于生成文件名的前缀字符串；必须至少是三字符长 suffix - 用于生成文件名的后缀字符串；可以为 null，在这种情况下，将使用后缀 “.tmp” directory - 将创建的文件所在的目录；如果使用默认临时文件目录，则该参数为 null 返回： 表示新建空文件的抽象路径名 抛出： IllegalArgumentException - 如果 prefix 参数包含的字符少于三个 IOException - 如果无法创建文件 SecurityException - 如果存在安全管理器，且其 SecurityManager.checkWrite(java.lang.String) 方法不允许创建文件 注意，这里告诉我们去看一下windows的 C:\WINNT\TEMP 目录。 WINNT是啥玩意，我反正是不太清楚，问问度娘： Microsoft Windows NT(New Technology)是Microsoft在1993年推出的面向工作站、网络服务器和大型计算机的网络操作系统，也可做PC操作系统。它与通信服务紧密集成，基于OS/2 NT基础编制。OS/2由微软和IBM联合研制，分为微软的Microsoft OS/2 NT与IBM的IBM OS/2。协作后来不欢而散，IBM继续向市场提供先前的OS/2版本，微软则把自己的OS/2 NT的名称改为Windows NT，即第一代的Windows NT 3.1。 大概可能是以上的意思。 然后，我对比了一下win7和windows server 2008的 很遗憾，没有找到我想要的，不高兴！ 继续探索 再回过头来看看，发现这句关键字： 默认临时文件目录由系统属性 java.io.tmpdir 指定 写个程序测试下 public class Test { public static void main (String[] args) { System.out.println(System.getProperty( "java.io.tmpdir" )); } } 系统 输出 win7 C:\Users\abc\AppData\Local\Temp\ server 2008 C:\Users\ADMINI~1\AppData\Local\Temp\2\ 顺着目录找下来，windows 2008的大概目录应该是C:\Users\Administrator\AppData\Local，但是也找不下去，没有找到2。 先新建一个2目录试试，结果发现验证码可以输出了！ 王二语录 那么人生何处不爬虫，爬虫请标 http://blog.csdn.net/qing_gee 小问题，大经验！ 上一篇 沉默王二的黄金时代 下一篇 Open quote is expected for attribute "{1}" associated with an element type "id". 顶 0 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157829次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 51
URL:: http://blog.csdn.net/qing_gee/article/details/50066619

ParseText::
Open quote is expected for attribute "{1}" associated with an element type "id". - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 Open quote is expected for attribute "{1}" associated with an element type "id". 标签： mybatis 中文标点 2015-11-27 09:59 132人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 今天在写完一个mybatis的xml配置后，项目怎么就是启动不起来，后台一直报Open quote is expected for attribute “{1}” associated with an element type “id”. Caused by: org.xml.sax.SAXParseException: Open quote is expected for attribute "{1}" associated with an element type "id" . at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java: 195 ) at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java: 174 ) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java: 388 ) 虽然看不懂错误信息，但可以感觉到时xml哪里写错了，但是看来看去，看不出门道，真是奇了怪了！ <select id=“getDealsById“ parameterType=“hashmap“ resultMap=“BaseResultMap“> SELECT * FROM ym_deals WHERE id = #{id} and is_delete=#{is_delete} </select> 哦，信息贴到markdown中到很明显的看出错误了。 对，是中文标点符号的原因。 在eclipse中看得并不明显，再加上是去mybatis的帮助文档上拷贝的，一时半会竟然没有发现错误。 不知道伙伴们有没有好的办法来eclipse中显示明显的中文标点符号的做法？ 王二语录 那么人生何处不爬虫，爬虫请标 http://blog.csdn.net/qing_gee 小小错误，大大经验 上一篇 ImageIO Can't create output stream! 下一篇 mybatis简单sql使用java注解而不是xml配置 顶 1 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157817次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 52
URL:: http://blog.csdn.net/qing_gee/article/details/50067251

ParseText::
mybatis简单sql使用java注解而不是xml配置 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 mybatis简单sql使用java注解而不是xml配置 标签： mybatis mapper java注解 2015-11-27 10:41 868人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 一直没有系统的接触mybatis，这就导致对其构建模式并没有清晰的认知，所以项目中所有的查询语句都使用在xml中配置，无论是简单sql，还是复杂sql，无一例外的没有使用java注解，这一点，现在看来，真是后悔莫及！那么请你牢记这点原则吧：mybatis简单sql使用java注解而不是xml配置！ 再次使用mybatis，觉得有必要重新认识一下它。这就好比，在你上班的路上，如果偶尔抬抬头扫一扫你的周围，也许就会瞥见不一样的风景──非常有气质的美女映入眼帘，你不得不聚精会神的把眼光的焦点全部集中于其一身，这种偶然的发现真令人心旷神怡！ 重新再阅读一遍 官方帮助文档 吧！ xml配置 需要新建一个mapper.java接口，再建一个mapper.xml. Deal getDealById(Map param); < select id = “getDealById“ parameterType = “hashmap“ resultMap = “BaseResultMap“ > SELECT * FROM deal WHERE id = #{id} and is_delete=#{is_delete} </ select > java注解 一个mapper.java接口 @Select ( "SELECT * FROM deal WHERE id = #{id} and is_delete=#{is_delete}" ) Deal getDealById( @Param ( "id" ) long id, @Param ( "is_delete" ) int is_delete); 对于这种简单的查询语句，java注解处理起来绰绰有余！ 注意是简单的sql语句，如果是复杂的语句，当然还是要使用xml配置的，把握好这个度就会让你心旷神怡，就如同不经间瞥见那个美女一样！ 王二语录 那么人生何处不爬虫，爬虫请标 http://blog.csdn.net/qing_gee 流年似水，日月如梭，转眼间2015年就剩下一个末尾了！ 上一篇 Open quote is expected for attribute "{1}" associated with an element type "id". 下一篇 利用springsecurity做用户权限限制 顶 2 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157824次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 53
URL:: http://blog.csdn.net/qing_gee/article/details/50184583

ParseText::
利用springsecurity做用户权限限制 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 利用springsecurity做用户权限限制 标签： spring security 用户 权限限制 2015-12-05 11:31 766人阅读 评论 (1) 收藏 举报 分类： spring （3） 作者同类文章 X Java （28） 作者同类文章 X Javaweb （32） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 一、概述 不同的user（用户）需要不同的role（角色），不同的role（角色）又会需要不同的resource（资源权限），比如说我王二，是个管理员（admin），我的权限大到什么都能操作，包括新建一个代理（proxy），再比如说我弟弟王三，是个代理（proxy），他却不能新建代理，他权限不够大。 利用springsecurity来实现的话，就非常简便（当然了，必须先做点准备工作）。 < security:authorize name = "newAgentPage" > < li > < a class = "add" title = "新建代理" > < span > 新建代理 </ span > </ a > </ li > </ security:authorize > 注释一下： security是规定的一个taglib前标记。 authorize是规定的一个tld后标记。 name是规定的适配属性。 newAgentPage是规定的权限名字。 二、直观体验 来看看我王二和弟弟王三的操作权限效果： 三、具体实现 1、添加security前缀 < %@ taglib prefix= "security" uri= "http://www.springsecurity.org/jsp" %> 2、添加authorize后缀 <?xml version="1.0" encoding="UTF-8" ?> < taglib xmlns = "http://java.sun.com/xml/ns/javaee" xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version = "2.1" > < description > <![CDATA[security Tags]]> </ description > < tlib-version > 1.0 </ tlib-version > < short-name > security </ short-name > < uri > http://www.springsecurity.org/jsp </ uri > < tag > < description > <![CDATA[authorize Tag]]> </ description > < name > authorize </ name > < tag-class > com.honzh.security.filter.tag.AuthorizeTag </ tag-class > < body-content > JSP </ body-content > < attribute > < name > name </ name > < required > false </ required > < rtexprvalue > true </ rtexprvalue > < type > java.lang.String </ type > </ attribute > </ tag > </ taglib > 把以上xml内容保存到WebContent/WEB-INF目录下的authorize.tld文件中。 稍作注释： name标签中authorize就是定义的后缀名。 tag-class标签中为继承BodyTagSupport标记的子类，3小节中介绍。 attribute标签中定义了name属性，用来页面上传递name的value值。 3、AuthorizeTag类 package com.honzh.security.filter.tag; import java.util.HashMap; import java.util.List; import javax.servlet.jsp.tagext.BodyTagSupport; import org.apache.log4j.Logger; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import com.honzh.biz.database.entity.security.SecurityUserDto; public class AuthorizeTag extends BodyTagSupport { private static Logger logger = Logger.getLogger(AuthorizeTag.class); private static final long serialVersionUID = - 5772328723066649929 L; // 页面上设置的name值 private String name; /* * (non-Javadoc) * * @see javax.servlet.jsp.tagext.BodyTagSupport#doStartTag() */ @SuppressWarnings ( "unchecked" ) public int doStartTag () { try { // 登陆用户的权限对象 Authentication auth = SecurityContextHolder.getContext().getAuthentication(); if (auth == null ) { return SKIP_BODY; } // 封装了一系列便捷信息的登陆用户 SecurityUserDto securityUserDto = (SecurityUserDto) auth.getPrincipal(); // 匹配用户是否具有该权限 List<HashMap<String, String>> resources = securityUserDto.getResources(); for (HashMap<String, String> resource : resources) { if (resource.get( "name" ).equals( this .getName())) { return EVAL_BODY_INCLUDE; } } } catch (Exception e) { logger.error(e.getMessage()); logger.error(e.getMessage(), e); } return SKIP_BODY; } public String getName () { return name; } public void setName (String name) { this .name = name; } } 稍作介绍： 对于BodyTagSupport 类，你可以参照 自定义jsp标签: TagSupport与BodyTagSupport的区别 (转) ，了解一下类方法介绍，以及常量作用。 SecurityUserDto 类是针对我项目封装的用户权限类，主要作用就是获取登陆用户的角色，角色对应的权限，限于篇幅，本篇只做简单的介绍。 4、SecurityUserDto 类 package com.honzh.biz.database.entity.security; import java.util.Collection; import java.util.List; import org.springframework.security.core.GrantedAuthority; @SuppressWarnings ( "rawtypes" ) public class SecurityUserDto extends SecurityUser { private static final long serialVersionUID = - 2841646575237530938 L; private Integer id; private String rolename; private List resources; public SecurityUserDto () { } public SecurityUserDto (String username, String password, Integer id, boolean enabled, Collection<GrantedAuthority> authorities, List resources) { super (username, password, enabled, authorities); this .id = id; this .setResources(resources); } /** * @return the rolename */ public String getRolename () { return rolename; } /** * @param rolename * the rolename to set */ public void setRolename (String rolename) { this .rolename = rolename; } public Integer getId () { return this .id; } public void setId (Integer id) { this .id = id; } public List getResources () { return resources; } public void setResources (List resources) { this .resources = resources; } } 稍作介绍： 限于篇幅，我删掉了一些属性。 关键内容是rolename、resources、 Collection<GrantedAuthority> authorities 。 5、用户登陆 < security:authentication-manager alias = "authenticationManager" > < security:authentication-provider user-service-ref = "customUserDetailsService" > < security:password-encoder hash = "md5" /> </ security:authentication-provider > </ security:authentication-manager > 稍作解释： 以上xml内容片段来自于applicationContext-security.xml，使用过springsecurity的朋友对该文件都不会陌生。 用户登陆时，springsecurity机制会将用户名和密码传递到指定的customUserDetailsService服务对象。 然后我们来看看customUserDetailsService服务对象： package com.honzh.spring.service.security.impl; import java.util.HashSet; import java.util.List; import java.util.Set; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.GrantedAuthorityImpl; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; import com.honzh.biz.database.entity.UserRole; import com.honzh.biz.database.entity.security.SecurityUserDto; import com.honzh.biz.database.mapper.ResourceMapper; import com.honzh.biz.database.mapper.SecurityUserSpecMapper; import com.honzh.biz.database.mapper.UserRoleMapper; import com.honzh.spring.service.security.CustomUserDetailsService; @Service ( "customUserDetailsService" ) public class CustomUserDetailsServiceImpl implements CustomUserDetailsService { @Autowired private SecurityUserSpecMapper securityUserSpecMapper; @Autowired private UserRoleMapper userRoleMapper; @Autowired private ResourceMapper resourceMapper; @SuppressWarnings ( "rawtypes" ) public UserDetails loadUserByUsername (String userName) throws UsernameNotFoundException { SecurityUserDto user = this .securityUserSpecMapper.selectByUsername(userName); UserRole userRole = this .userRoleMapper.selectByUserid(user.getId()); List resources = this .resourceMapper.selectResources(user.getUsername(), userRole.getRoleId1()); Set<GrantedAuthority> auths = new HashSet<GrantedAuthority>(); auths.add( new GrantedAuthorityImpl(user.getRolename().replaceAll( "\\*\\d{1,}\\*" , "" ))); return new SecurityUserDto(user.getUsername(), user.getPassword(), user.getId(), auths, resources); } } 稍作解释： 关于如何获得权限resource，以及SecurityUserDto 对象就不多做介绍了。 通过loadUserByUsername方法，就把role、resource等信息全部封装到 SecurityContextHolder.getContext().getAuthentication() 权限对象中了。 6、权限配置 关于权限配置的相关内容也不做介绍了，因为数据表不一致，大家伙用的方法也不一致，如果以后需要的话，再另做介绍。 这里就只看看页面上如何配置权限，仅供参考。 为“新建代理”创建指定的 newAgentPage 权限，其父菜单为整个代理列表页面。 7、为角色分配权限 代码实现上也不多做介绍了。 代理角色不具有“新建代理”的权限。 8、为用户分配角色 代码实现上不多做介绍了。 为我弟弟王三分配了代理（proxy）的角色。 到此就算是全部结束了，后续如果有朋友需要权限分配的介绍，再做说明。 该不该搁下重重的壳，寻找哪里到底有蓝天──周杰伦《蜗牛》 本文出自:【 沉默王二的博客 】 博乐点评 一共有 1位 博乐进行推荐 u011225629    2015-12-12 10:35:36 文章讲解spring security讲解的非常详细，有讲解，有代码，有运行结果，非常的好，在实际的开发当中，当然会遇到有关权限的问题，而这篇文章就解决了这样的问题。学习中，推荐！ 上一篇 mybatis简单sql使用java注解而不是xml配置 下一篇 26岁程序员的出路 顶 1 踩 0 我的同类文章 spring （3） Java （28） Javaweb （32） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157830次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 54
URL:: http://blog.csdn.net/qing_gee/article/details/50259601

ParseText::
26岁程序员的出路 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 [置顶] 26岁程序员的出路 标签： 程序员 出路 2015-12-11 15:48 2196人阅读 评论 (23) 收藏 举报 分类： 北洋杂录 （9） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 所谓路，途也，道也，古人有云：路漫漫其修远兮，吾将上下而求索；歌曲有唱：敢问路在何方，路在脚下；我心有念：流年似水，三十将至，然迷，不复得路。 一、坦诚交代 为了探寻26岁程序员的出路，决定先粗略的交代一下我的个人信息。 姓名：王二 年龄：26 职业：程序猿（犭旁的，鉴定性别为男） 所在地：九朝古都 身高：190cm（可能虚报） 履历： 2011年7月份毕业于一所大专院校，学无所成。 2010年底在苏州一家日企开始实习、工作，直到2014年2月份拖着那一身疲倦回到老家。若有所获，也若无所获。 2015年7月份之前就职于洛阳一家做IT教育的软件项目部，兢兢业业。在这期间，获得了一个本科毕业证。 8月份作为技术合伙人身份开始创业，担子颇重，把190的身高压扁到了175。 明眼的人从上面这段描述中不难发现，我是一名极其普通的程序员。学习能力差，所以考了一个大专；人际关系差，所以被迫回老家；养家糊口难，所以升级了学历，跳了槽，开始了创业。 套用莫迪阿诺《暗店街》中的一句话来说，27岁之前，“ 我的过去一片朦胧… ” 二、寻找导师 但我不想在27岁以后，依然“一片朦胧”。 所以我决定寻找一名生活和工作中的导师，以便给我有所指引。因为我总觉得自己就是那浩瀚大海上的一叶方舟，在渺无边际的黑夜里随波逐流，不知宁静的港湾在何方，如果能有一座点亮希望的灯塔照亮前方，我将奋不顾身的向此前行，那将多么的美妙。 请别戳着脊梁骨对我骂：“26都快过完了，还™在幻想什么导师，都该摸到程序员的天花板了！” 且听听我的辩解。马云当年还去请教过王林（好像已经收押）大师不是，人总有迷茫困惑的时候。人们焚香拜佛，吟经诵文，也只是想要寻找心灵精神上的导师。反正王二（我，为了免去烦扰，这里只好称我为王二）高考的时候，他女朋友就曾告诉他，为了他的高考，她曾到一个XX寺叩头祈祷过，只求他能考上一个好大学，但至于有没有如愿，这显而易见，王二考了一个大专，理论上是不符合预期的。 我就曾经恳请过 foruok 能够做为我的导师，因为在我眼里，他就是我的标杆，虽然被婉拒，但至少我曾尝试过。 《程序员的修炼──从优秀到卓越》一书中就曾倡导过学徒制： 一开始，师傅通常会把任务讲解给学徒听，然后示范，接着让学徒亲手做，并在任务完成后提出反馈意见。这个过程简单来说就是：听、看、做、评审。 foruok没有同意做我的导师，我想抛去他本人的谦虚外，多半的原因在我，毕竟，如果让一名大学教授去教高中生，而不是大学生，难免让人失去兴趣。 所以，我的出路，还需我自己来摸索。当然了，如果你有机会找到一名导师，千万不要错过，这可是千载难逢的好机会，他会在你迷途时给予你点化。 三、向老婆请教 由于公司目前就仨人，王二（我，为了陈述一个事实，就用第三人称）还挂着负责人的头衔，这让寻找导师的方案变得不太可行。 一天，我弱弱的给老婆感叹道： ”我在博客上看到了很多大牛，我不具备他们的能力，我也想成为他们…“ ”那你就努力啊，多读书，多写博客，然后在工作成实践，如果遇到难题，就自学成材…“老婆说得风生水起。 ”哦，那你得督促我，我的修养不够，需要有人鞭策和指导…“我喃喃道。 ”你说啥，你也有自知之明啊，知道自己修养不够，那你知道自己还缺什么吗？“老婆用鄙夷的眼光看着我说道。 ”老婆大人说的对，大爷我啥都缺，缺钱，缺朋友，缺…“我欠了个身，答道。 四、四条出路 你别说，女人说话真狠，一针见血。这也恰如其分的道出了 像我这样的程序员出路，那就是读书、写博客、工作实践、积累人脉 。 ①、读书 读史使人明智，读诗使人聪慧，数学使人精密，哲理使人深刻，伦理学使人有修养，逻辑修辞使人善辩。 读《大学之路》的时候，吴军博士详细的介绍了牛津剑桥大学，说上面这句话的培根先生就出自于剑桥大学，应该说是剑桥大学的一个标杆人物。 培根先生竭力提倡的6大类书籍于我来说，就像窗外隐约的山峰一样遥远，但作为一个程序猿，我还是为自己定下了三大类的书籍： 社会人文、研发编程、项目管理 。 前段时间，我百无聊懒的写了一篇 你不得不读的书籍清单 ，这篇文章的浏览量完全出乎我的意料，很多朋友喜欢，到让我有点“受宠若惊“。我更希望读者能看到我对书的感受，引发大家的共鸣。 我的案边暂时摆了这么多书，有的在上面这篇文章中略有介绍。但说到这里，我还是想要交代一些对于读书的其他感受： 从2008年9月份进入大学，到2014年6月份，我近乎讨厌读书，只要眼睛在书本上停留超过3秒，我就能想入非非。我的眼睛对于那些密密麻麻的宋体楷书总是视而不见，选择性的过滤掉。现在回想起来那段可怕的年月，真让人不堪回首。这多半的原因可以归咎于高考的失意，让我厌倦了读书，厌倦了学习，厌倦了考试，这都是隐隐作痛，不可抹去的伤啊。 我在 你不得不读的书籍清单 这篇文章中也交代过，很幸运，获得《微管理，给你一个技术团队，你该怎么管》的赠书后，我渐渐地对读书重拾兴趣，买书也变得一发不可收拾。 但到现在，读书这件事，并没有成为我的启明星，有的时候，我仍然感到困惑，读这些书，并没有让我快速的积累金钱（自从读了《黑客与画家》，我知道了金钱≠财富），并没有使我清晰的认知到我的未来，也没有告知我该成为什么样的人。 但是，《中国合伙人》有句台词说得好：“ 做了不一定能实现，但不做一定不会实现。没试过的人不会因为没实现梦想而难过，因为他一开始就放弃了梦想 。”所以，我依然要对读书stay hungry（保持饥饿）！ ②、写博客 我曾经在极客头条发布了一条链接 我们为什么应该坚持写博客 ，本来我以为这种老生常谈的话题，大家会感到倦怠，却不曾想，引起了很多朋友的共鸣，这能说明什么呢？──机智如我（请停顿）老婆大人。 原作者的贴图非常非常入木三分，这里借用一下： 咋眼一看，图中没有写博客嘛，但是当你阅读完作者的文章后，你会明白，写博客恰好贯穿于主动学习的过程中。 在我们博文写成，会有很多道友阅读。很多我们自己认为是对的，实际上是错误的东西、或是我们难以发现的错误，热心的道友会帮你指出。 很多时候，我们也会有心或是无心帮到一些初学者或是遇到同样问题的人。 当然了，关于写博客，我还有一些感慨想要交代： 2014-11-09 09:00，王二（我，为了回避被猜测为炫耀的嫌疑，用第三人称）在CSDN上发表了第一篇博文 忆软件架构师考试之旅 ，到2015-12-11日午时点亮CSDN博客专家的头衔，大概有一年零一个月的光景。如前文所述， 我是一名极其普通的程序员 ，获得这个殊荣，自感受之有愧。把时光拉回到2014年11月，我动笔要在CSDN上发表博文时，对“博客专家”有着一种可望而不可及的感觉，如今成为现实，不免恍然如梦。 26岁成为博客专家，本就是一件可怜可悲的事情。放眼望去，有很多年纪较轻的朋友，甚至在校的学生，都早已成为博客专家，他们都非常的优秀，比如说 浅墨_毛星云 90后，海归， 微软最具价值专家（C++），南京航空航天大学航天学院研究生在读。著作逐梦旅程:《Windows游戏编程之从零开始》，《OpenCV3编程入门》。中国2013年度十大杰出IT博客作者，CSDN 2012年博客大赛年度博客之星，CSDN 2012年度十大风云专栏作者 。擅长Unity3D、OpenCV、 Win32 API，DirectX，MFC，数字图像处理，3D图形渲染。 单看这些简历，都让人顶礼膜拜、相形见绌。 而自己的博文呢，套用 伯乐在线 的评语就是： 1、虽然很多文章是原创，但是参考别人博客或者读书笔记一类为主，自己见解的东西相对较少。 2、文章内容多为入门级的，深入某一领域的文章很少。 对于这样的评语，我就像被刮光毛的野猪，晾在带有血腥的砧板上，原形毕露。 但，对于26岁的我来说，坦然接受这样的现实（苏洵：年二十七，始发愤读书），所谓“念念不忘，必有回响，有一口气，点一盏灯”，我所要做的就是──继续写出高质量的博客。 ③、工作实践 1978年5月11日，《光明日报》发表本报特约评论员文章《实践是检验真理的唯一标准》，这在当时的社会上，引起了强烈的反响。 没错，学再多的理论，懂再多的知识，如果不在工作中加以实践，时间久了，都会忘到九霄云外。 我个人就对这方面就有深刻的体会，顺便交代一下： 我原以为，走上创业这条路后，我一个技术人员，想要带领团队走向成功，没有管理方便的理论方法是不行的。所以我通读了《人月神话》、《人件》、《微管理》等等一系列项目管理的书籍，但非常尴尬的是，由于项目团队到目前只有三个人，完全不给我一丁点实践的机会，我只要做到“团队要什么，我提供什么”，开发就非常高效。 当然了，上面这段陈述是反证法，正面的例子也有： public void dailyUpdateSystemData () { // 每日更新时进行一次会员信息更新 AllMembercoes.init(); checkPrivilege(); initUserMoney(); // 刷新一次行情信息 sendToQuotationJadeQuotations(); 这段代码是我读了《代码整洁之道》后修改的，在这之前，是什么样子呢？我已懒得再回想起那种糟糕的代码格式，如果你有兴趣，可以看一看 代码整洁之道札记：函数 ，总之，《代码整洁之道》这本书棒极了！ 王二身上的例子如果不够如雷贯耳的话，那么三国时“马谡失街亭”无疑是最好的历史见证，经不起实战检验的纸上谈兵是万万不可取的；再举一个正面的例子，看看刘关张就知道了，这哥仨，参加十八路诸侯的时候，各种被看不起，各种被吐槽，此时他们最好的出路无非就是步步为营，通过实践来增强自身能力，最终成就了一方霸业。 作为程序员的我也是如此，依稀记得当初敲“hello world”时，自己是多么懵懂，或者说狼狈，照着书本抄，计算机都有可能不打印出来这几个英文单词，整个人都不好。望天长叹：“吾路何在？”，现在可答曰：“路在脚下～”，哈哈，实践就是出路啊。 ④、人脉积累 Jeff的《 孤独的人是可耻的！ 》曾有这样一句话： 没有人会在临终之时说，“哎，我希望我能花更多的时间与我的计算机单独相处。” 反正我是不会这样说，你呢？ 我曾经在 温故而知新，人月徒伤悲 一文中说过： 我自认为，程序员很“闷骚”，当然我自己就是一个程序员，哈哈。不过我认为闷骚的含义应该是这样的： 闷，代表我们很单纯，我们通过编程，不断地解决用户的痛点，我们深陷于这种快乐而无法自拔，我们不愿意花费精力在其他方面，唯有编程；骚，代表我们富有活力，一旦有事情激起我们的兴趣，我们为之亢奋，不惜暴露我们的激情。 闷骚这个词也许带有一点戏谑的口味，但恰如其分的描述我们程序员的个性，我善于孤独，善于单干。所以，人际关系往往是我们程序员的黑洞。 就连村上春树先生就曾在《当我谈跑步时我谈些什么》一书中这样描述他自己： 说起来，我是那种喜爱独处的性情，表达的准确一点，是那种 不太以独处为苦 的性情。 这放在我身上，也很贴切，我也喜欢独处，你呢？ 但是，坦白的讲，我如果没有和出资人打好关系（这里，不是讨好的意思）的话，我如今也没有创业的机会，别人愿意拉拢你入伙，凭借的不仅仅是编程的硬实力，还会在意你为人的表现。这一点，从我和出资人的交谈中，有意发现的。 如果再直接一点的话，就是，人脉可以为你创造财富。 很多创业的伙伴们都会感叹，创业初期，人才难求，假如当初能够像马云那样，有“金刚十八罗汉”助阵的，或许也能创造比阿里更多的财富（请原谅我的YY）。 反正我就挺后悔，创业前没有拉拢好技术人员。现如今，创业虽然有风险，但是高风险才能高回报啊，那么，有一定的人脉积累，不失为一条好出路。 综上所述，26岁的程序员，大到身居要职，小到我这种打杂工，出路在哪？在于读书、写博客、工作实践、积累人脉也。so，王二有念：得路，然前。 相关文章 你不得不读的书籍清单 我们为什么应该坚持写博客 忆软件架构师考试之旅 代码整洁之道札记：函数 孤独的人是可耻的！ 温故而知新，人月徒伤悲 王二语录 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 沉默王二的博客 】 上一篇 利用springsecurity做用户权限限制 下一篇 操作符 顶 12 踩 0 我的同类文章 北洋杂录 （9） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157832次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 55
URL:: http://blog.csdn.net/qing_gee/article/details/50319127

ParseText::
操作符 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 操作符 标签： 操作符 java 2015-12-15 18:27 486人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 重新再来看（总感觉第一次看）《java编程思想》的话，还是有很多的收获，比如这篇操作符。 一、算术操作符 ①、Random public static void main (String[] args) { for ( int i = 0 ; i < 10 ; i++) { Random r = new Random( 2008 ); System.out.println(r.nextInt( 3 )+ "-----------" ); } } 为什么会输出1，确实让人百感交集，至少到目前为止，我还是没有弄清楚为什么会等于1，不是等于2，或者是0。 【小测试】Random的使用问题 这里有个话题可以参考，有人说的让人很懂的样子，但是我还是没懂，但明白了以下： new Random()在没有传递指定种子的时候，默认种子为当前时间（毫微秒为单位）。 设置种子后，就意味着r对象有着固定的形态，其第一次的next是固定的，第二次的next也是固定的，我本来以为有什么规律可以发现，但没有找到。 当前时间（毫微秒）作为种子时，也就意味着生成的随机数将会尽可能的不同 public Random () { this (++seedUniquifier + System.nanoTime()); } private static volatile long seedUniquifier = 8682522807148012 L; ②、魔幻数字47 本来我以为47是个神奇的数字，但其意义和我所想的截然相反，就是指单纯的下面的意思 虽然程式作者写的时候自己能了解数值的意义，但对其他程式员而言，甚至制作者本人经过一段时间后，会难以了解这个数值的用途，只能苦笑讽刺“这个数值的意义虽然不懂，不过至少程式会动，真是个魔术般的数字”而得名。 二、自动递增和递减 事到如今，我依然憎恨自动递增和递减，我觉得这个太魔幻，尤其是前缀和后缀还不一样。我是极不情愿理解这样的含义，但这一次，我好像“懂”了。 int i= 0 ; System.out.println(i++); System.out.println(i); System.out.println(++i); System.out.println(i); System.out.println(i--); System.out.println(i); System.out.println(--i); System.out.println(i); 第一次输出0，第二次1，第三次2，第四次2、、、 我从情感上讨厌这样的写法。 三、关系操作符 ①、== 不过对于==操作符来说，如果是要比较基本类型，ok，如果是基本类型的装箱混比，那么转成基本类型再==，就不容易出现逻辑上错误。 int i = 1 ; Integer j = 1 ; Integer k = new Integer( 1 ); Integer k1 = new Integer( 1 ); System.out.println(i == j); System.out.println(i == k); System.out.println(j == k); System.out.println(k1 == k); 不关乎答案如何，我觉得这种比较真心受够了，真让人久久不能释怀。 ②、短路 static boolean getB() { Random r = new Random(); if (r.nextInt( 5 ) < 4 ) { return false ; } return true ; } static boolean getA() { Random r = new Random(); if (r.nextInt( 5 ) < 2 ) { return false ; } return true ; } public static void main (String[] args) { for ( int i = 0 ; i < 5 ; i++) { boolean c = getA() && getB(); System.out.println(c); } } 假如说存在以上这样的一个程序，从概率上来讲，把 getA() && getB() 的形式换成 getB() && getA() 更能节省时间。 为什么会这样，因为后一种形式在几率上更容易形成短路，也就是说getB()形成false的情况更多，这个时候getA()执行的机会就会少。 四、截尾和舍入 double d = 10.99 ; float a = ( float )d; System.out.println(a); int b = ( int ) a; int f = Math.round(a); System.out.println(b); System.out.println(f); 向下转型的时候会丢弃精度。 王二语录 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 qing_gee的博客 】 上一篇 26岁程序员的出路 下一篇 吸血鬼数字 顶 0 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157823次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 56
URL:: http://blog.csdn.net/qing_gee/article/details/50328679

ParseText::
吸血鬼数字 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 吸血鬼数字 标签： 吸血鬼数字 java 2015-12-16 15:57 691人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 很惭愧（其实没什么惭愧，水平就这样），搞了半晌才写出来了一个求四位吸血鬼数字的方法 吸血鬼数字是指位数为偶数的数字，可以由一对数字相乘而得到，而这对数字各包含乘积的一半位数的数字，其中从最初的数字中选取的数字可以任意排序。 以两个0结尾的数字是不允许的，例如，下列数字都是“吸血鬼”数字： 1260 = 21 * 60 　1827 = 21 * 87 　2187 = 27 * 81 int len = 4 ; // 求出四位值得范围 int max = ( int ) (Math.pow( 10 , len) - 1 ); int min = ( int ) (Math.pow( 10 , len- 1 )); for ( int num = min; num <= max; num++) { // 过滤掉诸如60*50=3000这样的数 if (num % 100 == 0 ) { continue ; } // 主要思路，分解四位数字，拿出来排列组合，然后根据条件a*b=c来筛选，费劲心思也就做到这程度了，真™想回家种地 List<String> list = Arrays.asList(String.valueOf(num).split( "" )); List<String> ss = new ArrayList<String>(); for ( int i = 1 ; i < list.size(); i++) { for ( int j = 1 ; j < list.size(); j++) { if (j == i) { continue ; } List<String> halfs = new ArrayList<String>(); halfs.addAll(list); halfs.remove(i); halfs.remove(j - 1 ); String a = list.get(i) + list.get(j); if (!ss.contains(a)) { for ( int k = 1 ; k < halfs.size(); k++) { String b = halfs.get(k) + halfs.get(halfs.size() - k); if (!ss.contains(b)) { ss.add(b); } int i1 = Integer.parseInt(a); int i2 = Integer.parseInt(b); if (i1 * i2 == num) { System.out.print(a + "、" + b + "=" + num + "，" ); } } } } } } 得出结论如下： 21、60=1260，15、93=1395，41、35=1435，51、30=1530，21、87=1827，27、81=2187，86、80=6880，86、80=6880， 还多出了一组相同的数据，也是醉了，真灰心！ 当然了，悻悻然的做出了结果，也算不负于王二（我，已经无法用第一人称了）的智商。为了保持一颗上进的心，我还是看看高手们怎么完成的。 参见 AVA实现的吸血鬼数字算法,高效率版本(已有网友给出算法说明) ，说实话，看了几遍也没有看懂，真扫兴，你要是看懂了，可以教一教王二这个榆木疙瘩。 相关文章 AVA实现的吸血鬼数字算法,高效率版本(已有网友给出算法说明) 王二语录 the best things in life,they are free,but if you wanna cry,cry on my shoulder.──《cry on my shoulder》 本文出自:【 qing_gee的博客 】 上一篇 操作符 下一篇 你不得不读的书籍清单 顶 2 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157842次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 57
URL:: http://blog.csdn.net/qing_gee/article/details/50339901

ParseText::
斐波那契数列 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 斐波那契数列 标签： 斐波那契数列 java 2015-12-17 12:26 696人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 斐波那契数列在编程界无人不晓，不晓得以前是否已经写过这样的程序，也不关乎王二如今已经编程了多少年，再次来感受一下该数列的牛逼之处吧！ public static void main (String args[]) { try { BufferedReader br = new BufferedReader( new InputStreamReader(System.in)); while ( true ) { int num = Integer.parseInt(br.readLine()); if (num == - 1 ) { break ; } int start = 1 ; int next = 1 ; System.out.print(start + "、" ); System.out.print(next + "、" ); // 从3开始到第num个斐波那契数 for ( int i = 3 ; i <= num; i++) { int last = start + next; System.out.print(last + "、" ); start = next; next = last; } System.out.println(); for ( int i = 1 ; i <= num; i++) { System.out.print(getF(i) + "、" ); } System.out.println(); } br.close(); } catch (IOException e) { e.printStackTrace(); } } static int getF( int i) { if (i == 1 || i == 2 ) { return 1 ; } else { return getF(i - 1 ) + getF(i - 2 ); } } 一个递归，一个前两位相加，这两个方法很常用，也很简单，就不费口舌了。 重要的不是这个，是斐波那契数列 翻阅百度百科，让我记忆犹新的有： 斐波那契数列是斐波那契在养兔子时候发现的非常用意思的数列，虽然我不知道新生兔子第一个月是不生产的，但想来所有的规律都是和生活所贴近的。 斐波那契数列能计算出黄金分割，随着数量的增加，前一项与后一项的比重越接近0.618，哦，天哪，这肯定不是斐波那契发现的，后人研究的成果。 树木发芽也符合斐波那契数列，好神奇。 杨辉三角好像也和斐波那契数列有点关系，虽然没有细读。 相关文章 斐波那契数列-百度百科 王二语录 I dont care who you are, where you are from,what you did,as long as you love me──后街男孩《as long as you love me》 本文出自:【 qing_gee的博客 】 上一篇 你不得不读的书籍清单 下一篇 初始化与清理 顶 2 踩 1 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157820次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 58
URL:: http://blog.csdn.net/qing_gee/article/details/50343489

ParseText::
初始化与清理 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 初始化与清理 标签： 初始化 清理 java 2015-12-17 16:29 496人阅读 评论 (0) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 说实话，关于《JAVA编程思想》中“初始化与清理”章节，我细致看完后，感觉若无所获，让我大失所望，姑且记录在本博客中，是因为希望未来一天再读关于“初始化”、“清理”的时候能够大彻大悟。 一、以返回值区分重载方法 我曾经就干过这样的傻事，项目中我们经常会编写自己的DateUtils包，来转换各种日期格式。 int getFromDate(Date date){ } long getFromDate(Date date){ } 例如上面这串代码，本意是想通过一个方法名getFromDate来获得日期的long时间戳（13位）或者int时间戳（10位），我原来总觉得这样的写法，编译器应该认为是合乎情理的，但编译器是不通过的。 需要改成这样的写法： int getIntFromDate(Date date){ } long getLongFromDate(Date date){ } 有时你并不关心方法的返回值，你想要的是方法调用的其他效果。 所以这种情况下，针对getFromDate方法，编译器就不知道你要调用哪一个？ 所以，返回值区分重载方法是不可行的。 二、this和static 本来这个小节，我是很感兴趣的，对于这两个关键字，王二一直没有“深入浅出”，以后还需再总结。 三、垃圾回收 Bruce花费了大量的文字来介绍java的垃圾回收机制，无论是“标记-清扫”，还是“停止-复制”，我都没有看明白，没有大彻大悟，实在抱歉，只恨自己脑瓜郁闷。 四、初始化 记得看尚学堂马士兵的视频，或者魔乐科技的李兴华老师视频时，都会花一定的时间介绍java类在初始化时的顺序，今天再次重温了一遍，但依然没啥感觉，不做深究。 ①、可变参数列表 可变参数列表其实是很有用的，尤其是在做sql语句的变量赋值时。 public void fillStatement (PreparedStatement pst, Object... paras) throws SQLException { for ( int i= 0 ; i<paras.length; i++) { pst.setObject(i + 1 , paras[i]); } } 拼预处理sql语句时，我们基本上都会使用“？”来代替参数，然后将参数放在可变参数paras中，这是非常好用的做法。 ②、枚举类型 王二觉得，枚举并没有发挥其原本想要的作用，至少现在看来，枚举在使用过程中还是略显疲态，不过有一个很重要的地方用枚举就特别给力，那就是单例。 public enum Single { INSTANCE; } 非常简洁 无偿提供序列号机制 绝对防止多次实例化 这三点在《effective java》中已强烈推荐，实现singleston的最佳方式！关于singleston，还有很多其他的版本，你可以参阅 深入浅出单实例Singleton设计模式 ，非常详细。 本篇我并没有学到太多的至少，水平有限，只能一点一点来，如果你是大神级别的，请自动过滤！ 相关文章 深入浅出单实例Singleton设计模式 王二语录 it will all get better in time, And even though i really love you,i am gonna smile cause i deserve to(一切都会好起来，即便我真的真的爱你，我也要微笑面对，因为我原本如此)──Leona Lewis《Better In Time》 本文出自:【 qing_gee的博客 】 上一篇 斐波那契数列 下一篇 import static 顶 0 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157834次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 59
URL:: http://blog.csdn.net/qing_gee/article/details/50351100

ParseText::
import static - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 import static 标签： import static 2015-12-18 13:12 389人阅读 评论 (5) 收藏 举报 分类： Java （28） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 今天读到《JAVA编程思想》的访问权限控制，本章讲的当然是package、import、private、protected、public、默认权限，很遗憾，关于这些内容，总是吃不进我的脑子里，唯一感兴趣的就是import static，说实话，第一次见。 import static java.lang.System.out; public class D { public static void debug (String [] args) { out.println(args); } } import static debug.D.debug; public class Test1 { public static void main (String args[]) { debug(args); } } 使用的注意点就是注意import到对应的静态方法上、对象上、属性上，一定要到位。 这里可以参照 Java静态导入(import static)需谨慎 ，里面讲的很不错，import static也要谨慎使用。 相关文章 Java静态导入(import static)需谨慎 王二语录 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 qing_gee的博客 】 上一篇 初始化与清理 下一篇 CSDN博客QQ加群 顶 0 踩 0 我的同类文章 Java （28） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157832次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 60
URL:: http://blog.csdn.net/qing_gee/article/details/50351697

ParseText::
CSDN博客QQ加群 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 CSDN博客QQ加群 标签： csdn博客 QQ加群 2015-12-18 14:49 394人阅读 评论 (0) 收藏 举报 分类： IT技术 （7） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 对于QQ加群我一直是拒绝的，不是自己摆姿态，而是实在没有这样的影响力和能力。然而今日一朋友的话改变了我这种想法，所以尝试在CSDN博客首页上添加QQ加群功能，此博客也就权当一个记录(主要是为了上传一张二维码，哈哈)。 一、前言 记得在 26岁程序员的出路 一文中这样提及过： 1、虽然很多文章是原创，但是参考别人博客或者读书笔记一类为主，自己见解的东西相对较少。 2、文章内容多为入门级的，深入某一领域的文章很少。 这是当时申请加入伯乐在线原创作者时，对方给出的评语，我自己的感受就是“我就像被刮光毛的野猪，晾在带有血腥的砧板上，原形毕露。” 但是今天一朋友这些留言： 虽然楼主的博客像伯乐在线说的那样，但是刚好适合我这样的雏鸟。 并且朋友主动加我QQ，希望有所交流，我就突然萌生创建一个QQ群的想法，虽然自己很low，但是希望未来的一段岁月里，能够与更多心有灵犀的朋友一起交流和进步。 二、配置QQ加群 ①、一键加群 首先，到 QQ群官网-一键加群 ，这里会生成对应的网页代码和二维码。 < a target = "_blank" href = "http://shang.qq.com/wpa/qunwpa?idkey=03d3e3bec47ad6a627c6214c1c882763083bda21b73e54289187e5226378c5c7" > < img border = "0" src = "http://pub.idqqimg.com/wpa/images/group.png" alt = "沉默王二" title = "沉默王二" > </ a > 这是我对应群生成的网页代码。 这是对应的二维码。 ②、加入CSDN博客栏目 进入到博客配置页面，我把二维码和网页代码做了融合。 之后效果图在你浏览博客的时候就已经可见了。 QQ群公告： 希望在这里见面的我们能够相互帮助，相互交流，更重要的是，给你积累人脉，给你积累财富（这不仅仅包含的是金钱，还有生活得幸福感，事业的成就感） 虽然现在群里只有两个人，一个我，一个上文描述的朋友，但诚如这位朋友所说： 嗯嗯，相信我们会由小变大。 数量并不重要，不宜多寡论成败。 相关文章 QQ群官网-一键加群 王二语录 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 qing_gee的博客 】 上一篇 import static 下一篇 了解Activity 顶 3 踩 1 我的同类文章 IT技术 （7） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157827次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 61
URL:: http://blog.csdn.net/qing_gee/article/details/50370541

ParseText::
了解Activity - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 了解Activity 标签： android Activity 了解 2015-12-21 11:11 548人阅读 评论 (2) 收藏 举报 分类： android （3） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 依照郭霖老师的《第一行代码Android》，今天我要来学习Activity，首先来初步了解Activity，基本上就是照葫芦画瓢的模式，有点回到当初敲java的hello world的模式。 顺便介绍一下我为什么要学习安卓，至于说自己能够学习到什么程度，这完全看项目的需要以及个人的兴趣，但是我对自己持怀疑态度。项目未来要由pc端转向手机端，虽然有专业的安卓工程师，但作为创业团队，我必须要对安卓有所了解，况且我还“精通”（姑且这么说来着，王二的脸皮本来就厚）java，所以之前就研究了 安卓环境的部署 ，花了100多人民币注册了红杏出墙（不料不到两周的时间，突然被封杀了，这种付费模式真不敢恭维，所以在国内免费来得更加让人心安理得些），写了一篇 安卓版的hello world ，之后就忙其他的事情，时隔多日，再次学习安卓，只想一步一个脚印儿。 一、Activity基本用法 ①、新建button < Button android:id = "@+id/button_1" android:layout_width = "match_parent" android:layout_height = "wrap_content" android:text = "aaa" /> 至于说id为什么是”@+id”作为定义方式，不清楚，约定俗成的东西，先记住。 match_parent比较好理解，匹配父容器的宽度 wrap_content自动换行 text=”aaa”，不知道为什么会有黄点，可能是要定义到string里，先记录疑问。 另外还有一点不知道为什么： 新建一个Android 布局xml后，双击怎么就是打不开，删掉项目，重启ATD几次后方可打开 。 ②、新建Activity package com.mwq.activity; import android.app.Activity; import android.os.Bundle; public class FirstActivity extends Activity { @Override protected void onCreate (Bundle savedInstanceState) { super .onCreate(savedInstanceState); setContentView(R.layout.first_layout); } } 被 R.layout.first_layout 纠结了好一会，在引入R包的时候，切记是本项目的包（也就是你创建项目app时指定的package），而非android包下的R，这个R对应也有自己的layout属性，但是调不出来first_layout（也就是上文中创建的layout），这有点坑。不过书中也提到了，但王二我就是容易眼瞎，还是忽略掉了友情提示。 ③、注册Activity < activity android:name = "com.mwq.activity.FirstActivity" android:label = "first activity" > < intent-filter > < action android:name = "android.intent.action.MAIN" /> < category android:name = "android.intent.category.LAUNCHER" /> </ intent-filter > </ activity > 感觉label很多余，不过验证后，发现还是有区别的，这个可能书中某处已有介绍，我没有注意。 对于ATD来说，提示确实不够灵活， android.intent.action.MAIN 对于这样的提示应该输入一个main就可以定位到，但是完全没办法做到，够low的。 ④、基本拓展 protected void onCreate (Bundle savedInstanceState) { super .onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.first_layout); Button button = (Button) findViewById(R.id.button_1); button.setOnClickListener( new OnClickListener() { @Override public void onClick (View v) { Toast.makeText(FirstActivity. this , "王二表现不错" , Toast.LENGTH_SHORT).show(); } }); } requestWindowFeature(Window.FEATURE_NO_TITLE) 设置后，运行虚拟机过程中有延迟，先显示后不显示，以后不知道是否有新用法。 Toast消息提醒，感觉挺不错的，makeText方法的第一个参数为context，从api上来看就是application和activity，第三个参数为显示周期，长或者短，但不知道默认的长短是多少时间，看代码，好像是可以指定。 /** * Show the view or text notification for a short period of time. This time * could be user-definable. This is the default. * @see #setDuration */ public static final int LENGTH_SHORT = 0 ; ⑤、使用menu 先新建一个menu.xml < menu xmlns:android = "http://schemas.android.com/apk/res/android" > < item android:id = "@+id/item1" android:title = "add" /> < item android:id = "@+id/item2" android:title = "update" /> </ menu > 重写onCreateOptionsMenu方法 public boolean onCreateOptionsMenu (Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true ; } getMenuInflater方法依照书中所说是获得menu的Inflater对象，再调用inflate方法可以显示对应的菜单，我反正还不太懂，只是理解会用。 return true和false控制菜单显示和不显示，确实这样子。 弹出消息 public boolean onOptionsItemSelected (MenuItem item) { switch (item.getItemId()) { case R.id.item1: Toast.makeText( this , "add" , Toast.LENGTH_LONG).show(); break ; case R.id.item2: Toast.makeText( this , "update" , Toast.LENGTH_LONG).show(); break ; default : break ; } return true ; } 先了解到这里吧，项目中来问题了。整体来看，安卓的activity还是蛮有意思的。 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 沉默王二的博客 】 上一篇 CSDN博客QQ加群 下一篇 了解intent 顶 5 踩 1 我的同类文章 android （3） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157836次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 62
URL:: http://blog.csdn.net/qing_gee/article/details/50378561

ParseText::
了解intent - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 了解intent 标签： intent android 2015-12-22 16:51 405人阅读 评论 (0) 收藏 举报 分类： android （3） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 了解完activity的基本知识，接下来了解intent（据说是多个activity之间的媒介）。 学习的过程自然少不了参照，我选择的参照是郭霖老师的《第一行代码Android》。 学习是个循序渐进的过程，王二不是一个天赋异禀的同学，所以只能每天多积积硅步。今天看到 专访任玉刚：从菜鸟到资深工程师的进阶之路 ，又一个移动端的大牛登上了CSDN的首页资讯，王二我略感兴奋，这兴奋不是说我自己也想有朝一日如此（但隐隐约约有点，笑），而是心中又多了一个行进的标杆。 一、显式intent 新建second_layout.xml。 < Button android:id = "@+id/button_2" android:layout_width = "match_parent" android:layout_height = "wrap_content" android:text = "button2" /> 新建SecondActivity.java protected void onCreate (Bundle savedInstanceState) { super .onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); } 注册activity < activity android:name = "com.mwq.activity.SecondActivity" > </ activity > 在FirstActivity.java中增加显示intent button.setOnClickListener( new OnClickListener() { @Override public void onClick (View v) { Intent intent = new Intent(FirstActivity. this , SecondActivity.class); startActivity(intent); } }); 通过new关键字创建intent对象，其构造方法的参数分别是FirstActivity这个context，以及SecondActivity这个class。 通过startActivity方法启动intent。 关键的地方来了，如果首次见 FirstActivity.this 一定会感兴趣， 类名.this就是匿名内部类访问外部类对象 的一种方法，这是约定俗成的格式。至于说在上面这段代码中，谁是匿名内部类，谁是外部类，答案是显而易见的： new OnClickListener() {} 就是匿名内部类，而代码所在的FirstActivity.java文件对应的上下文就是外部类。 如果你对类名.this和类名.class感兴趣的话，可以参阅 类名.this与类名.class 。 二、隐式intent 首先关于隐式intent的概念，我没有很好的理解，无论是书中所说“相比于显式intent，隐式intent则含蓄得多，它并不明确指出我们想要启动哪一个活动，而指定了一系列更为抽象的action和category等信息，然后交由系统分析这个intent，并帮助我们找到合适的活动去启动”，还是 Android入门：隐式Intent 文中所说 顾名思义，隐式意图就是在不明确设置激活对象的前提下寻找最匹配的组件，举个例子，比如有5个人： (1)A：170cm (2)B：160cm (3)C：180cm (4)D：190cm (5)E：200cm 如果是显式意图的话，如果我们要指明选择A的话会说：”我选择A.“，但是如果是隐式意图，则会说：”我要选择170cm的人“，虽然没有指明要选A，但会寻找条件最匹配的人。 我都不太认可这种说法，但我此刻也没有好的说法，真是无奈。 AndroidManifest.xml中为SecondActivity增加action和category。 < activity android:name = "com.mwq.activity.SecondActivity" > < intent-filter > < action android:name = "com.mwq.activity.ACTION_START" /> < category android:name = "android.intent.category.DEFAULT" /> </ intent-filter > </ activity > 非常诧异的是，为什么 action android:name 要使用一个附带包路径的字符串，当然了去掉包路径，使用“ACTION_START”也能启动，只要和intent中的参数匹配就行，但因为我是初学者，先按照规矩来办事吧。 至于说 category android:name 为什么是· android.intent.category.DEFAULT ，我也不太清楚，不过去掉这个参数后，隐式intent就不能跳转了，整个app会跳出。 FirstActivity.java，把显式intent改成隐式intent。 // Intent intent = new Intent(FirstActivity.this, SecondActivity.class); Intent intent = new Intent( "com.mwq.activity.ACTION_START" ); 这样启动程序后，发现也是可以跳转的。 另外书中提到增加一个category，我就不再赘述了。 三、好玩的intent ①、打开网页 Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse( "http://blog.csdn.net/qing_gee" )); startActivity(intent); Create an intent with a given action. All other fields (data, type, class) are null. Note that the action must be in a namespace because Intents are used globally in the system – for example the system VIEW action is android.intent.action.VIEW; an application’s custom action would be something like com.google.app.myapp.CUSTOM_ACTION. 关于Intent(String)的构造方法，上面的doc说得也够仔细的。 嗨嗨，挺不错，可以打开我的博客。 请允许我再说几句题外话。前几日，我更新了自己的头像，终于可以见到王二的真面目了，只可惜，像素低了点，遗憾，以后可以再聚焦到头部一些。以前有为叫momasp的朋友，喷我用女生李孝利的头像赚取流量，我是十分的不解，我没见到自己流量上增加了多少，真是愧对了李孝利这位美女。做一个沉默的程序员都挺难了，还得被说三道四，真是难上加难，哈哈。不过呢，经过反思和自我教育，我还是决定痛改前非，使用自己真实的头像。 ②、打电话 Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse( "tel:10086" )); dial的英文单词意思就是拨打电话的意思。 有点遗憾的是我的安卓模拟器出来的内容和书中不一样，显然这也不是我想要的效果。 另外，还有其他的使用，可参见 Android 打开地图并显示指定的经纬度 ，发短信，显示地理位置等等。 四、数据传递 ①、向下传递 FirstActivity.java Intent intent = new Intent(FirstActivity. this , SecondActivity.class); intent.putExtra( "name" , "沉默王二" ); SecondActivity.java Intent intent = getIntent(); String name = intent.getStringExtra( "name" ); Log.d( "SecondActivity" , name); 方式呢，前后呼应，倒也挺好记忆的。 ②、向上传递 FirstActivity.java Intent intent = new Intent(FirstActivity. this , SecondActivity.class); startActivityForResult(intent, 1111 ); 使用startActivityForResult方法来启动intent，传递的第二个参数是一个requestcode。 requestCode If >= 0, this code will be returned in onActivityResult() when the activity exits. protected void onActivityResult ( int requestCode, int resultCode, Intent data) { switch (requestCode) { case 1111 : if (resultCode == RESULT_OK) { String response = data.getStringExtra( "name" ); Log.d( "FirstActivity" , response); } break ; default : break ; } } 匹配requestcode后，判断resultcode是否为ok，然后输出response。 SecondActivity.java中增加对应的处理 Button button = (Button)findViewById(R.id.button_2); button.setOnClickListener( new OnClickListener() { @Override public void onClick (View v) { Intent intent = new Intent(); intent.putExtra( "name" , "沉默王三" ); setResult(RESULT_OK, intent); finish(); } }); 使用默认的构造方法新建intent。 传递参数name setResult 1 方法来向上一个activity传递数据 finish主动结束活动 为什么创建一个默认的intent就能向上一个活动传递参数，之前的intent都需要指定对应参数，这一次为什么不呢？显然这就需要下一次学习活动的生命周期了，据说是先进后出的栈。 至于说按菜单中的back键返回，只需要重写SecondActivity.java的onBackPressed方法就行了。 目前学习到的intent的知识倒是不难，很容易理解，但要整理成文，的确还是花了不少时间。 相关文章 Android SDK Manager 更新代理配置 Android 打开地图并显示指定的经纬度 类名.this与类名.class 了解Activity 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 沉默王二的博客 】 Call this to set the result that your activity will return to its caller. ↩ 上一篇 了解Activity 下一篇 更改mysql数据库目录 顶 1 踩 1 我的同类文章 android （3） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157817次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 63
URL:: http://blog.csdn.net/qing_gee/article/details/50387516

ParseText::
更改mysql数据库目录 - qing_gee的专栏 - 博客频道 - CSDN.NET qing_gee的专栏 路漫漫其修远兮，吾将上下而求索 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 更改mysql数据库目录 标签： 更改 mysql 数据库目录 2015-12-23 15:42 385人阅读 评论 (0) 收藏 举报 分类： mysql （14） 作者同类文章 X Linux （1） 作者同类文章 X 版权声明：这是自封为沉默王二的挨踢工作者，用文字打造的一个高品质的博客栏目。让你拥有一段快乐的阅读时光，不再是奢侈的梦想！ 更改mysql数据库目录，是一个辛酸历程，其实我想交代更多的内容，只是限于文章的实用性，我决定去繁就简。 今天早上，客户告诉我期货交易平台登陆不上去，这肯定是项目出了bug。 一、show processlist show processlist; 发现部分sql等待表级锁（且这么叫吧，懒得找翻译软件了），我首先想到的是“某几张表是myisam引擎，容易发生表级锁，之前就有类似的问题发生，先kill掉sql进程，然后将表引擎由 myisam改为innodb 。” 当然了，我按照这个想法准备要执行表引擎的更换了，但出现了突发状况。 二、got error 28 from storage engine 如题所示，当我准备打开表查看数据的时候，出现了“got error 28 from storage engine”错误消息提示，我的翻译是“存储引擎出现了28错误”。 当然我百度了，找到这样一篇 mysql的“Got error 28 from storage engine”错误 ，说实话，这篇文章没有给我什么鸟的帮助，但现在回想起来，确实是我自己大意了，虽然说清空“/tmp”目录的做法不值得推荐， 但至少应该去清空一些磁盘，把数据库备份一下 。 当然了，我想到去备份数据，使用了“mysqldump”命令尝试了一次数据备份，但是遗憾的是，报了一个错误，提示我无法保存。这是显而易见的，因为磁盘本身就不足了，没有清空磁盘，搞毛线的备份。但这是事后诸葛亮的想法，当时的我显然没有针对性的对数据进行备份！ 再次奉劝各位，数据库出问题时，即使有自动化的数据备份，但尽量在修正问题之前再做一次实时的备份！ 三、df -h 没有备份成功，我就转向了另外一个方向，查看数据磁盘空间。 [root @iZ23gsv94suZ run] # df -h Filesystem Size Used Avail Use% Mounted on /dev/xvda1 20G 19G 16M 100% / tmpfs 1.9 G 0 1.9 G 0 % /dev/shm /dev/xvdb1 99 G 255 M 99 G 1 % /mnt 看到use等于“100%”，我已经确定问题出在哪里了，但是我在这里继续犯了一个错误。 “莫非是阿里云的磁盘没有挂载成功，就是/dev/xvdb1对应的这个100G磁盘没有挂载成功，否则怎么把20G的这个盘给沾满了呢？” 后知后觉的我现在恍然大悟，对于windows操作系统，C盘满了，怎么也不会把数据移动到D盘来，然而当时我怎么都在怀疑阿里云的磁盘没有挂载成功！ 这就是一个天大的错误！ 四、阿里云磁盘挂载 由于上面这一步认为阿里云磁盘没有挂载成功，所以当时糊涂的我一心要重新挂载磁盘，于是我又在 Linux 系统挂载数据盘 这个泥潭里深陷不已，久久不能自拔，由于硬盘确实已经挂在成功，所以我再怎么费尽心思也只能得到“磁盘已挂载成功”的答案。但是，这里还是不得不说，一个人的精力实在有限，我几乎已经是一个全栈工程师，自己对自己在意的标签是“打杂工，偏java”，这就让我不得不感慨万千。 由于是个创业团队，我又是一个负责人，所以我要做的工作有： java编程 web编程 Linux编程（shell脚本、项目部署） C#客户端协调（调查bug、业务探讨、相关代码审核） 安卓编程（目前处于学习阶段） 项目管理（麻雀虽小肝胆俱全，我必须要让每个人开心快乐的工作，效率最大化） 财务、行政（发发工资、请大家聚餐活动、游玩、工作环境布置、浇花、打扫卫生） 需求分析（客户沟通、需求调查、业务建模） 个人能力提升（编程能力、为人处事能力） 等等等等，只要能想得到的，没有不做的，实在是无法集中重心专业负责哪一块，就导致哪一块都不精通，这也是导致本次问题出现一个关键因素。 所以， 如果朋友们有好的解决方案，请不吝赐教，我希望通过互联网认识更多朋友，在未来的创业道路上一路前行，互惠互利 。 五、mysql数据库目录更改 既然阿里云的磁盘已经挂在，那么接下来的工作就是把mysql的默认数据目录迁移到100G的盘上，而不是系统盘！ 这个过程现在说起来很简单，但是在执行的过程中，却是千辛万苦！ linux 更改mysql的数据库目录 ，这篇文章提供了相应的办法，按理说，按照里面提到的方法执行下去就OK，但这里，我不得不强调， 项目千差万别，每个人解决问题的办法也不尽相同，所以，动数据库之前，千万要先备份！ 显然，我按照这篇文章所说，是没有把目录迁移成功，所以你也需要这样，请千万注意！ ①、mv Linux的mv命令很强大，但风险系数也很高！ 强烈建议使用cp命令，而非mv命令，除非你一万个确定方案可行。 ②、chown -R mysql:mysql /home/data/mysql/ chown - R mysql:mysql /home/ data /mysql/　 # 改变数据库的归属为mysql 这个语句慎用，反正坑哭了我！ ③、 /mnt 前面曾提到 /dev/xvdb1 99G 255M 99G 1% /mnt 不知道，你是否注意，对于我一个Linux的雏鸟来说，显然没有意识到这个100G的磁盘，其路径是“/mnt”，也就是说， mysql的数据目录需要重置到该“/mnt”目录下 。 ④、目录迁移 1、cp -afpr /var/lib/mysql/ /mnt/ 使用cp命令，将mysql的数据默认目录，移动到新的挂载盘/mnt下面 [root@iZ23gsv94suZ mysql] # pwd /mnt/mysql [root@iZ23gsv94suZ mysql] # ls auto .cnf ib_logfile0 ibtmp1 iZ23gsv94suZ .pid mysql-bin .000001 mysql .sock RPM_UPGRADE_HISTORY ibdata1 ib_logfile1 iZ23gsv94suZ .err mysql mysql-bin .index performance_schema RPM_UPGRADE_MARKER-LAST 2、vim /etc/my.cnf [mysql] default- character - set =utf8 socket = /mnt/mysql/mysql.sock # [mysqld] # The TCP/IP Port the MySQL Server will listen on port= 3306 socket = /mnt/mysql/mysql.sock 把mysql配置文件的socket目录更改到/mnt下对应的路径 3、vim /etc/init.d/mysql then # datadir=/var/lib/mysql datadir= /mnt/mysql 将该文件中的datadir修改为对应的/mnt目录 4、ln -s /mnt/mysql/mysql.sock /var/lib/mysql/mysql.sock 使用ln命令，指定一条链接给mysql.sock，具体的作用，我不知，你可百度。 按照以上四步，就可以转移mysql的数据库目录了，但是，我的过程远比这个艰辛。 搞来搞去，我的mysql是搞崩溃了，没有办法，需要重新安装。这里，你可以参照 centOS下安装mysql5.7 、 升级mysql到5.7 。然后，数据恢复你可以使用source命令，如果涉及到二进制日志恢复，你可以参照 mysql之备份和导入数据（包括二进制日志） 但最重要的是，操作数据库之前，想尽一切办法先备份数据库！ 相关文章 centOS下安装mysql5.7 升级mysql到5.7 mysql之备份和导入数据（包括二进制日志） 笑对现实的无奈，不能后退的时候，不再傍徨的时候，永远向前　路一直都在──陈奕迅《路一直都在》 本文出自:【 沉默王二的博客 】 上一篇 了解intent 下一篇 wysiwyg富文本数据如何保存到mysql 顶 0 踩 0 我的同类文章 mysql （14） Linux （1） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 qing_gee 访问： 157838次 积分： 3210 等级： 积分：3210 排名： 第5842名 原创： 137篇 转载： 0篇 译文： 0篇 评论： 345条 我的微博 我的QQ群 扫描、点击二维码都可加群，QQ群： 120926808 博客专栏 北洋杂录：阿猿的浮想录 文章：18篇 阅读：20183 Java，漂亮的不像实力派 文章：24篇 阅读：18126 我的标杆 程序视界foruok 豆巴陆其明 JFinal 极速开发 阅读排行 你不得不读的书籍清单 (10855) VS2013安装SVN插件 (4832) jQuery validate之remote (2898) bootstrap input-file小例子 (2496) 论证select count(*)和select count(1) (2318) dwz中jqGrid的主题变更 (2258) 26岁程序员的出路 (2188) 升级mysql到5.7 (2084) Illegal overloaded getter method with ambiguous type for property (2019) 读京东技术解密，感桑田沧海变迁 (1791) 最新评论 wysiwyg富文本数据如何保存到mysql mxh403 : 不能后退的时候，不再彷徨的时候 ^_^.Merry Christmas！ 了解Activity u010247281 : 不错，写的很详细嘛 26岁程序员的出路 wtjandjay : 你还找辉哥给你当导师了，他竟然还拒绝了哈哈太有意思了 26岁程序员的出路 wtjandjay : 二哥你是来拉仇恨的吗 同 26 同it码农 哎不能比啊 你不得不读的书籍清单 wtjandjay : 哈哈楼主终于换头像了 我有个二十多年的发小也叫王二后来我给他起了个外号叫王俩 wysiwyg富文本数据如何保存到mysql qingluohuaxiang : 赞 你不得不读的书籍清单 liran9094 : @qing_gee:买的跑步说些什么 到了 打算平时在地铁时候慢慢的看它我平时也没怎么读书吧，... 你不得不读的书籍清单 xx326664162 : @qing_gee:我是来学习的，这些书我只有一本Java编程思想，刚买的，正在看，希望看完对我的技... 了解Activity Dark_Crow : 你不得不读的书籍清单 qing_gee : @xx326664162:诚如朋友所说，即使书读完一遍也不一定能领会得了。上面列出这18本书，有一些... 文章搜索 文章存档 2015年12月 (15) 2015年11月 (11) 2015年10月 (14) 2015年09月 (23) 2015年08月 (6) 2015年07月 (8) 2015年06月 (5) 2015年05月 (10) 2015年04月 (12) 2015年03月 (4) 2015年02月 (2) 2015年01月 (9) 2014年12月 (9) 2014年11月 (10)

Recno:: 64
URL:: http://blog.csdn.net/testcs_dn/article/details/50403032

ParseText::
HP 1522NF一体机网打怎么弄啊？打印机的IP怎么设置。 - 无知人生，记录点滴 - 博客频道 - CSDN.NET 无知人生，记录点滴 不积硅步，无以至千里；不积小流，无以成江海…… 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 HP 1522NF一体机网打怎么弄啊？打印机的IP怎么设置。 标签： 惠普 打印机 1522NF 2015-12-25 14:32 16人阅读 评论 (0) 收藏 举报 推荐本产品使用此网络配置模式。 1. 在打开产品之前，先将网络电缆插入产品网络端口，以将产品直接连接到网络。 2. 打开产品电源，等待 2 分钟，然后使用控制面板打印配置页。 注： 确保配置页上列出 IP 地址，然后继续执行下一步。如果配置页上未列出 IP 地址，请重新打 印配置页。 3. 将产品 CD 插入计算机。如果软件安装程序未启动，请浏览到 CD 上的 hpsetup.exe 文件，然后双 击该文件。 4. 按照安装程序说明进行操作。 注： 当安装程序提示输入网络地址时，请输入您在启动安装程序之前打印的配置页上列出的 IP 地址，或在网络上搜索产品。 5. 完成安装过程，然后重新启动计算机。 IP 地址 可手动设置产品 IP 地址，也可通过 DHCP、BootP 或 AutoIP 自动配置。 手动配置 1. 在控制面板上按下设置 ( )。 2. 使用箭头按钮选择网络配置，然后按下 确定。 3. 使用箭头按钮选择 TCP/IP 配置，然后按下 确定。 4. 使用箭头按钮选择手动，然后按下 确定。 5. 使用字母数字按钮键入 IP 地址，然后按下 确定。 6. 如果 IP 地址不正确，请使用箭头按钮选择否，然后按下 确定。重复步骤 5 键入正确的 IP 地址， 然后重复步骤 5 设置子网掩码和默认网关。 自动配置 1. 在控制面板上按下设置 ( )。 2. 使用箭头按钮选择网络配置，然后按下 确定。 3. 使用箭头按钮选择 TCP/IP 配置，然后按下 确定。 4. 使用箭头按钮选择自动，然后按下 确定。 自动获得的 IP 地址可能要过几分钟才能使用。 上一篇 Routing Error uninitialized constant TransController 顶 1 踩 0 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 testcs_dn 访问： 1858725次 积分： 22270 等级： 积分：22270 排名： 第165名 原创： 466篇 转载： 169篇 译文： 7篇 评论： 512条 文章搜索 博客专栏 JAVA学习实践及问题记录 文章：98篇 阅读：390501 VC学习实践及问题记录 文章：33篇 阅读：89083 Markdown 文章：15篇 阅读：27803 NoSQL入门与提高 文章：0篇 阅读：0 CentOS服务器配置管理 文章：25篇 阅读：118455 MySQL图文进阶 文章：18篇 阅读：89044 C#软件开发实例 文章：44篇 阅读：147398 文章分类 VC (79) C# (88) JAVA (132) jquery (20) InstallShield (3) php (9) Android (1) sock5 (2) JavaScript (25) HTML5 (6) IIS (6) VS2010 (9) ASP.NET (4) Python (1) 数据库 (21) MySQL (24) CentOS (55) 操作系统 (20) Database (4) css (1) linux (14) 动态共享库 (2) gcc (3) gdb (1) ThinkPHP (5) 浏览器 (9) 调试 (6) 系统安全 (3) 其它 (29) C语言 (2) 开源协议 (2) 直播 (2) Maven (21) Redis (9) Nginx (5) FFmpeg (2) Hadoop (3) 逆向分析 (1) visio (1) mybatis (5) VB.NET (1) 同步机制 (2) 系统架构 (4) Eclipse (33) R语言 (2) Markdown (14) Tomcat (10) SVN (8) 活动 (9) 书摘 (2) WindowsAPI (2) UI设计 (1) UE设计 (2) Proguard (15) spring (2) 成功励志 (1) powerdesigner (1) 养生保健 (2) 数据结构 (1) 编程语言 (2) 星星点灯 (1) 程序猿/缘 (2) asp (3) 云服务器 (2) go语言入门 (4) Bluemix (3) Ruby (7) rails (2) 文章存档 2015年12月 (15) 2015年11月 (12) 2015年10月 (12) 2015年09月 (14) 2015年08月 (13) 2015年07月 (14) 2015年06月 (20) 2015年05月 (58) 2015年04月 (25) 2015年03月 (31) 2015年02月 (16) 2015年01月 (33) 2014年12月 (31) 2014年11月 (20) 2014年10月 (24) 2014年09月 (23) 2014年08月 (21) 2014年07月 (20) 2014年06月 (14) 2014年05月 (36) 2014年04月 (14) 2014年03月 (14) 2014年02月 (7) 2014年01月 (6) 2013年12月 (15) 2013年08月 (3) 2013年07月 (2) 2013年06月 (9) 2013年05月 (6) 2013年04月 (7) 2013年03月 (32) 2013年02月 (3) 2012年10月 (8) 2012年09月 (7) 2012年08月 (22) 2012年07月 (2) 2012年06月 (30) 2012年05月 (4) 阅读排行 Uncaught SyntaxError: Unexpected token ILLEGAL (56336) MICRO SIM卡(SIM小卡)尺寸图及剪卡图解 (55486) Uncaught SyntaxError: Unexpected token ) (51563) HTTP错误 404.17 - Not Found" IIS 7.5 请求的内容似乎是脚本，因而将无法由静态文件处理程序来处理 (43344) xxx cannot be resolved to a type 错误解决方法 (33234) The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path (27780) HTML5使用 JavaScript File API 实现文件上传 (27251) js如何判断一个对象{}是否为空对象，没有任何属性 (26210) A child container failed during start (20944) ThinkPHP学习（二）理清ThinkPHP的目录结构及访问规则，创建第一个控制器 (19957) 评论排行 CSDN-markdown编辑器语法——字体、字号与颜色 (35) 你曾后悔进入 IT 行业吗？ (25) xxx cannot be resolved to a type 错误解决方法 (19) 欢迎使用CSDN-markdown编辑器 (15) HTTP错误 404.17 - Not Found" IIS 7.5 请求的内容似乎是脚本，因而将无法由静态文件处理程序来处理 (12) A child container failed during start (12) 《Visual c++2013入门经典（第7版）》上机练习：为 Win32 控制台应用程序创建项目 (11) The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path (11) C语言中函数参数为什么是由右往左入栈的？ (10) VC Windows API应用之GetDesktopWindow ——获得桌面所有窗口句柄的方法 (9) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 Your Ruby version is 2.2.3, but your Gemfile specified 2.2.2 u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ C#软件开发实例.私人订制自己的屏幕截图工具（十）在截图中包含鼠标指针形状 qigeminghaofan : 大神，可以把完整的代码放出来吗？好像没有截图信息栏、编辑工具栏这些功能 欢迎使用CSDN-markdown编辑器 scufzk2008 : 代码块那地方很丑，不知道楼主怎么优化下？ A child container failed during start testcs_dn : @plok741:谢谢补充！ A child container failed during start plok741 : 遇到相同的问题，是由于tomcat的版本的问题导致的。用tomcat8之后，可以成功启动应用。或者使... Notepad++输入模式之修改模式、插入模式 testcs_dn : @zxbdlv:欢迎来踩！ Notepad++输入模式之修改模式、插入模式 zxbdlv : 谢谢分享！ Ruby On Rails中REST API使用示例——基于云平台+云服务打造自己的在线翻译工具 testcs_dn : @mengdonghui123456:欢迎来踩！ Could not publish to the server. java.lang.NullPointerException testcs_dn : @liutong123987:恩恩 Could not publish to the server. java.lang.NullPointerException liutong123987 : 今天刚好碰到，用解决方法的第一种可以解决 友情链接 computer99999999的专栏 陌路缘

Recno:: 65
URL:: http://blog.csdn.net/wangshubo1989/article/details/50347905

ParseText::
实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> 标签： vector c++ 2015-12-17 23:05 829人阅读 评论 (1) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 之前博客讲到 vector可以使用insert方法，将一个vector copy到另一个vector的后面。 之前的博客也讲到过，如果vector容器内部放的是unique_ptr是需要进行所有权转移的。 现在就来八一八如何 vector<unique_ptr<>> insert to vector<unique_ptr<>> 如果常规的vector，我们就可以这么使用insert： // inserting into a vector #include <iostream> #include <vector> int main () { std :: vector < int > myvector ( 3 , 100 ); //100 100 100 std :: vector < int > ::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); //200 100 100 100 myvector.insert (it, 2 , 300 ); //300 300 200 100 100 100 // "it" no longer valid, get a new one: it = myvector.begin(); std :: vector < int > anothervector ( 2 , 400 ); myvector.insert (it+ 2 ,anothervector.begin(),anothervector.end()); //now, 300 300 400 400 200 100 100 100 int myarray [] = { 501 , 502 , 503 }; myvector.insert (myvector.begin(), myarray, myarray+ 3 ); std :: cout << "myvector contains:" ; for (it=myvector.begin(); it<myvector.end(); it++) std :: cout << ' ' << *it; std :: cout << '\n' ; return 0 ; } //输出： 501 502 503 300 300 400 400 200 100 100 100 但是对于vector内的unique point来说，就不能简单的使用普通迭代器了：需要使用对迭代器就行std::make_move_iterator操作： 看下英文描述最可靠： A move_iterator is an iterator adaptor that adapts an iterator (it) so that dereferencing it produces rvalue references (as if std::move was applied), while all other operations behave the same. 就跟我们之前用到的std::move作用是一样一样的~ 看看使用例子： #include <iostream> // std::cout #include <iterator> // std::make_move_iterator #include <vector> // std::vector #include <string> // std::string #include <algorithm> // std::copy int main () { std :: vector < std :: string > foo ( 3 ); std :: vector < std :: string > bar { "one" , "two" , "three" }; std ::copy ( make_move_iterator(bar.begin()), make_move_iterator(bar.end()), foo.begin() ); // bar now contains unspecified values; clear it: bar.clear(); std :: cout << "foo:" ; for ( std :: string & x : foo) std :: cout << ' ' << x; std :: cout << '\n' ; return 0 ; } //输出： foo: one two three 接下来就是我们的使用了，简单了吧： #include<iostream> #include<vector> #include <memory> using namespace std ; void display_vector( vector <unique_ptr< int > > &vec); int main() { vector <unique_ptr< int > > vec; unique_ptr< int > s1( new int ( 1 )); unique_ptr< int > s2( new int ( 2 )); unique_ptr< int > s3( new int ( 3 )); unique_ptr< int > s4( new int ( 4 )); vec.push_back( std ::move(s1)); vec.push_back( std ::move(s2)); vec.push_back( std ::move(s3)); vec.push_back( std ::move(s4)); unique_ptr< int > s5( new int ( 5 )); vector <unique_ptr< int > > des_vec; des_vec.push_back( std ::move(s5)); des_vec.insert(des_vec.end(), std ::make_move_iterator(vec.begin()), std ::make_move_iterator(vec.end())); display_vector(des_vec); cout << "now, des_vec size: " << des_vec.size() << endl; cout << "now, vec size: " << vec.size() << endl; return 0 ; } void display_vector( vector <unique_ptr< int > > &vec) { for ( auto it = vec.begin(); it != vec.end(); it++) { cout << **it << endl; } //输出结果： 5 1 2 3 4 now, des_vec size: 5 now, vec size: 4 上一篇 实战c++中的vector系列--vector<unique_ptr<>>作为函数的参数 下一篇 实战c++中的vector系列--creating vector of local structure、vector of structs initialization 顶 1 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127083次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 66
URL:: http://blog.csdn.net/wangshubo1989/article/details/50355732

ParseText::
实战c++中的vector系列--creating vector of local structure、vector of structs initialization - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的vector系列--creating vector of local structure、vector of structs initialization 标签： vector c++ 2015-12-19 00:52 638人阅读 评论 (0) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 之前一直没有使用过 vector<struct>，现在就写一个简短的代码： #include <vector> #include <iostream> int main() { struct st { int a; }; std :: vector <st> v; v.resize( 4 ); for ( std :: vector <st> ::size_type i = 0 ; i < v.size(); i++) { v. operator [](i).a = i + 1 ; // v[i].a = i+1; } for ( int i = 0 ; i < v.size(); i++) { std :: cout << v[i].a << std ::endl; } } 用VS2015编译成功，运行结果： 1 2 3 4 但是，这是C++11之后才允许的，之前编译器并不允许你写这样的语法，不允许vector容器内放local structure。 更进一步，如果struct里面有好几个字段呢？ #include<iostream> #include<string> #include<vector> using namespace std; struct subject { string name; int marks; int credits; }; int main() { vector<subject> sub ; //Push back new subject created with default constructor. sub .push_back(subject()); //Vector now has 1 element @ index 0 , so modify it. sub [0].name = "english"; //Add a new element if you want another: sub .push_back(subject()); //Modify its name and marks. sub [1].name = "math"; sub [1].marks = 90; sub .push_back({ "Sport", 70, 0 }); sub .resize(8); // sub .emplace_back("Sport", 70, 0 ); for ( int i = 0 ; i < sub .size(); i++) { std::cout << sub [i].name << std::endl; } } 但是上面的做法不好，我们应该先构造对象，后进行push_back 也许更加明智。 subject subObj; subObj.name = s1; sub.push_back(subObj); 这个就牵扯到一个问题，为什么不使用emplace_back来替代push_back呢，这也是我们接下来讨论 话题。 上一篇 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> 下一篇 实战c++中的vector系列--知道emplace_back为何优于push_back吗？ 顶 1 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127082次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 67
URL:: http://blog.csdn.net/wangshubo1989/article/details/50357549

ParseText::
实战c++中的vector系列--知道emplace_back为何优于push_back吗？ - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的vector系列--知道emplace_back为何优于push_back吗？ 标签： vector c++ 2015-12-19 10:51 570人阅读 评论 (0) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 上一篇博客说道vector中放入struct，我们先构造一个struct对象，再push_back。 那段代码中，之所以不能使用emplace_back，就是因为我们定义的struct没有显示的构造函数。 emplace和解？ 放列的意思。 这次我们不把struct当做vector的元素了，我们把一个class当做vector的元素，写下代码： #include <iostream> #include <vector> #include<string> using namespace std ; class CText { private : string str; public : text( string s) :str(s) { } void show() const { cout << str << endl; } }; int main() { vector <CText > vi; vi.emplace_back( "hey" ); vi.front().show(); vi.push_back( "girl" ); //错误 vi.back().show(); return 0 ; } 其中vi.push_back(“girl”);这条语句错误，VS2015报错为： error C2664: “ void std :: vector <text, std ::allocator<_Ty> >::push_back( const text &)”: 无法将参数 1 从“ const char [ 5 ]”转换为“text &&” 但此时我们稍作修改： 把 vi.push_back(“girl”) 改为 vi.push_back(CText(“girl”)); 问题就解决了。。 简而言之，就是empace_back与push_back相比，替我们省去了调用CText进行构造。 emplace_back 添加一个新元素到结束的容器。该元件是构成在就地，即没有复制或移动操作进行。 inserts a new element at the end of the vector, right after its current last element. This new element is constructed in place using args as the arguments for its constructor. This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity. The element is constructed in-place by calling allocator_traits::construct with args forwarded. A similar member function exists, push_back, which either copies or moves an existing object into the container. 写到这里，你应该明白emplace_back如何是也了吧。 最后再来一段代码，涉及到使用右值引用和std::move的： #include <vector> #include <string> #include <iostream> struct President { std :: string name; std :: string country; int year; President( std :: string && p_name, std :: string && p_country, int p_year) : name( std ::move(p_name)), country( std ::move(p_country)), year(p_year) { std :: cout << "I am being constructed.\n" ; } President(President&& other) : name( std ::move(other.name)), country( std ::move(other.country)), year(other.year) { std :: cout << "I am being moved.\n" ; } President& operator =( const President& other) = default ; }; int main() { std :: vector <President> elections; std :: cout << "emplace_back:\n" ; elections.emplace_back( "Nelson Mandela" , "South Africa" , 1994 ); std :: vector <President> reElections; std :: cout << "\npush_back:\n" ; reElections.push_back(President( "Franklin Delano Roosevelt" , "the USA" , 1936 )); std :: cout << "\nContents:\n" ; for (President const & president : elections) { std :: cout << president.name << " was elected president of " << president.country << " in " << president.year << ".\n" ; } for (President const & president : reElections) { std :: cout << president.name << " was re-elected president of " << president.country << " in " << president.year << ".\n" ; } } //输出： emplace_back: I am being constructed. push_back: I am being constructed. I am being moved. Contents: Nelson Mandela was elected president of South Africa in 1994. Franklin Delano Roosevelt was re-elected president of the USA in 1936. 上一篇 实战c++中的vector系列--creating vector of local structure、vector of structs initialization 下一篇 实战c++中的vector系列--emplace_back造成的引用失效 顶 1 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127085次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 68
URL:: http://blog.csdn.net/wangshubo1989/article/details/50358044

ParseText::
实战c++中的vector系列--emplace_back造成的引用失效 - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的vector系列--emplace_back造成的引用失效 标签： vector c++ 2015-12-19 13:32 516人阅读 评论 (0) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 上篇将了对于struct或是class为何emplace_back要优越于push_back，但是还有一些细节没有提及。今天就谈一谈emplace_back造成的引用失效。 直接撸代码了： #include <vector> #include <string> #include <iostream> using namespace std ; int main() { vector < int > ivec; ivec.emplace_back( 1 ); ivec.emplace_back(ivec.back()); for ( auto it = ivec.begin(); it != ivec.end(); ++it) cout << *it << " " ; return 0 ; } //输出： 1 - 572662307 尝试1：不直接给emplace_back传递ivec.back()： #include <vector> #include <string> #include <iostream> using namespace std ; int main() { vector < int > ivec; ivec.emplace_back( 1 ); auto &it = ivec.back(); ivec.emplace_back(it); for ( auto it = ivec.begin(); it != ivec.end(); ++it) cout << *it << " " ; return 0 ; } 输出： 1 - 572662307 尝试2：不给emplace_back传递引用： #include <vector> #include <string> #include <iostream> using namespace std ; int main() { vector < int > ivec; ivec.emplace_back( 1 ); auto it = ivec.back(); ivec.emplace_back(it); for ( auto it = ivec.begin(); it != ivec.end(); ++it) cout << *it << " " ; return 0 ; } 输出： 1 1 我们如愿以偿，这时候应该可以得到结论了，ivec.back()返回的是引用，但是这个引用失效了，所以才会输出不正确；我们之前也提到过，重新分配内存会造成迭代器的失效，这里是造成了引用的失效。 再回头看看emplace_back的描述： if a reallocation happens, all iterators, pointers and references related to this container are invalidated. Otherwise, only the end iterator is invalidated, and all other iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call. 进一步。 尝试3：避免emplace_back引起重新分配内存： #include <vector> #include <string> #include <iostream> using namespace std ; int main() { vector < int > ivec; ivec.reserve( 4 ); ivec.emplace_back( 1 ); ivec.emplace_back(ivec.back()); for ( auto it = ivec.begin(); it != ivec.end(); ++it) cout << *it << " " ; return 0 ; } 输出： 1 1 但是这个时候问题来了，如果不使用emplace_back而改用push_back呢？ #include <vector> #include <string> #include <iostream> using namespace std ; int main() { vector < int > ivec; ivec.push_back( 1 ); ivec.push_back(ivec.back()); ivec.push_back(ivec.back()); ivec.push_back(ivec.back()); for ( auto it = ivec.begin(); it != ivec.end(); ++it) cout << *it << " " ; return 0 ; } //输出： 1 1 1 1 为什么使用push_back就不失效呢？ 上一篇 实战c++中的vector系列--知道emplace_back为何优于push_back吗？ 下一篇 实战c++中的vector系列--C++11对vector成员函数的扩展(cbegin()、cend()、crbegin()、crend()、emplace()、data()) 顶 1 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127079次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 69
URL:: http://blog.csdn.net/wangshubo1989/article/details/50359181

ParseText::
实战c++中的vector系列--C++11对vector成员函数的扩展(cbegin()、cend()、crbegin()、crend()、emplace()、data()) - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的vector系列--C++11对vector成员函数的扩展(cbegin()、cend()、crbegin()、crend()、emplace()、data()) 标签： vector c++ 2015-12-19 18:07 797人阅读 评论 (0) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 前面提到的emplace_back就是C++11所增加的内容。 所以这篇博客就是想罗列一下C++11对vector容器的扩充。 std::vector::cbegin和std::vector::cend 这两个方法是与std::vector::begin和std::vector::end相对应的，从字面就能看出来，多了一个’c’，顾名思义就是const的意思。 所以： std::vector::cbegin： Returns a const_iterator pointing to the first element in the container. std::vector::cend： Returns a const_iterator pointing to the past-the-end element in the container. #include <iostream> #include <vector> int main () { std :: vector < int > myvector = { 10 , 20 , 30 , 40 , 50 }; std :: cout << "myvector contains:" ; for ( auto it = myvector.cbegin(); it != myvector.cend(); ++it) std :: cout << ' ' << *it; std :: cout << '\n' ; return 0 ; } Output: myvector contains: 10 20 30 40 50 std::vector::crbegin和std::vector::crend 这两个方法就不解释了，与上面的相比就是多了个’r’， reverse的缩写，反转迭代器，代码就省略了。 std::vector::emplace 之前已经对emplace_back进行了讨论，其实还有一个方法叫emplace。 我想说的就是，emplace之于emplace_back就像insert之于push_back。 看英文描述就直观： emplace：Construct and insert element emplace_back：Construct and insert element at the end 如何使用： #include <iostream> #include <vector> int main () { std :: vector < int > myvector = { 10 , 20 , 30 }; auto it = myvector.emplace ( myvector.begin()+ 1 , 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std :: cout << "myvector contains:" ; for ( auto & x: myvector) std :: cout << ' ' << x; std :: cout << '\n' ; return 0 ; } Output: myvector contains: 10 200 100 20 30 300 std::vector::data Returns a direct pointer to the memory array used internally by the vector to store its owned elements. #include <iostream> #include <vector> int main () { std :: vector < int > myvector ( 5 ); int * p = myvector.data(); *p = 10 ; ++p; *p = 20 ; p[ 2 ] = 100 ; std :: cout << "myvector contains:" ; for ( unsigned i= 0 ; i<myvector.size(); ++i) std :: cout << ' ' << myvector[i]; std :: cout << '\n' ; return 0 ; } Output: myvector contains: 10 20 0 100 0 std::vector::shrink_to_fit Requests the container to reduce its capacity to fit its size. 就是减少空间 #include <iostream> #include <vector> int main () { std :: vector < int > myvector ( 100 ); std :: cout << "1. capacity of myvector: " << myvector.capacity() << '\n' ; std :: cout << "1. size of myvector: " << myvector.size() << '\n' ; myvector.resize( 10 ); std :: cout << "2. capacity of myvector: " << myvector.capacity() << '\n' ; std :: cout << "2. size of myvector: " << myvector.size() << '\n' ; myvector.shrink_to_fit(); std :: cout << "3. capacity of myvector: " << myvector.capacity() << '\n' ; std :: cout << "3. size of myvector: " << myvector.size() << '\n' ; return 0 ; } //输出 1. capacity of myvector: 100 1. size of myvector: 100 2. capacity of myvector: 100 2. size of myvector: 10 3. capacity of myvector: 10 3. size of myvector: 10 此时，就是要明白size和capacity的区别，也就会更加理解resize和reserve的区别了！ 上一篇 实战c++中的vector系列--emplace_back造成的引用失效 下一篇 实战c++中的vector系列--正确释放vector的内存(clear(), swap(), shrink_to_fit()) 顶 1 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127078次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 70
URL:: http://blog.csdn.net/wangshubo1989/article/details/50397066

ParseText::
实战c++中的智能指针unique_ptr系列-- 使用std::unique_ptr代替new operator(错误：‘unique_ptr’ is not a member of ‘std’) - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的智能指针unique_ptr系列-- 使用std::unique_ptr代替new operator(错误：‘unique_ptr’ is not a member of ‘std’) 标签： unique-ptr c++ 2015-12-24 22:05 484人阅读 评论 (0) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 写了很多篇关于vector的博客，其实vector很便捷，也很简单。但是很多易错的问题都是vector中的元素为智能指针所引起的。所以决定开始写一写关于智能指针的故事，尤其是unique_ptr指针的故事。 这是个开始，就让我们使用std::unique_ptr代替new operator吧！ 还是用程序说话： #include<iostream> int main() { while ( true ) int *x = new int ; } 看下任务管理器中的内存： 此时使用智能指针unique_ptr: #include<iostream> #include<memory> int main() { while ( true ) std ::unique_ptr< int > x( new int ( 10 )); } 两张图片就可以清晰看到智能指针带来的好处。 如果我们对传统的指针及时的释放，我们也可以达到智能指针的效果： #include <iostream> using namespace std ; int main() { while ( true ) { int *x = new int ; delete x; } return 0 ; } 这里再分享一个错误，在MAC编辑器上写的C++代码，其中用到了智能指针unique_ptr，这个代码在vs2015中时候的时候，就会提示错误： ‘unique_ptr’ is not a member of ‘std’ 原因很简单，就是缺少unique_ptr的头文件： #include<memory> 那么你也许会问题，智能指针是何时释放内存的呢？ unique_ptr objects automatically delete the object they manage (using a deleter) as soon as they themselves are destroyed , or as soon as their value changes either by an assignment operation or by an explicit call to unique_ptr::reset . 下一篇会从unique_ptr的构造函数说起！！ 上一篇 实战c++中的vector系列--再谈vector的insert()方法(都是make_move_iterator惹的祸) 下一篇 实战c++中的智能指针unique_ptr系列-- std::unique_ptr的构造(尽量使用C++14中的std::make_unique，而不是new) 顶 1 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127080次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 71
URL:: http://blog.csdn.net/wangshubo1989/article/details/50397553

ParseText::
实战c++中的智能指针unique_ptr系列-- std::unique_ptr的构造(尽量使用C++14中的std::make_unique，而不是new) - wangshubo1989的博客 - 博客频道 - CSDN.NET wangshubo1989的博客 勿在浮沙筑高台 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 实战c++中的智能指针unique_ptr系列-- std::unique_ptr的构造(尽量使用C++14中的std::make_unique，而不是new) 标签： unique-ptr c++ 2015-12-24 23:59 507人阅读 评论 (0) 收藏 举报 分类： C++ （147） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 上篇博客算是unique_ptr的一个开篇，就是简单说说为何要使用unique_ptr，与传统指针相比，智能指针的优势而已。 现在就从构造开始说起！ 看看这些构造方法： default ( 1 ) constexpr unique_ptr() noexcept ; from null pointer ( 2 ) constexpr unique_ptr (nullptr_t) noexcept : unique_ptr() {} from pointer ( 3 ) explicit unique_ptr (pointer p) noexcept ; from pointer + lvalue deleter ( 4 ) unique_ptr (pointer p, typename conditional<is_reference<D>::value,D, const D&> del) noexcept ; from pointer + rvalue deleter ( 5 ) unique_ptr (pointer p, typename remove_reference<D>::type&& del) noexcept ; move ( 6 ) unique_ptr (unique_ptr&& x) noexcept ; move-cast ( 7 ) template < class U, class E> unique_ptr (unique_ptr<U,E>&& x) noexcept ; move from auto_ptr ( 8 ) template < class U> unique_ptr ( auto_ptr <U>&& x) noexcept ; copy (deleted!) ( 9 ) unique_ptr ( const unique_ptr&) = delete ; 下面就是各个构造unique_ptr的方法： 先看看1 2 3 4 5 8 #include <iostream> #include <memory> int main() { std ::default_delete< int > d; std ::unique_ptr< int > u1; std ::unique_ptr< int > u2( nullptr ); std ::unique_ptr< int > u3( new int ); std ::unique_ptr< int > u4( new int , d); std ::unique_ptr< int > u5( new int , std ::default_delete< int >()); std ::unique_ptr< int > u8( std :: auto_ptr < int >( new int )); std :: cout << "u1: " << (u1 ? "not null" : "null" ) << '\n' ; if (u1 != nullptr ) { std :: cout << "*u1: " << *u1 << std ::endl; } std :: cout << "u2: " << (u2 ? "not null" : "null" ) << '\n' ; if (u2 != nullptr ) { std :: cout << "*u2: " << *u2 << std ::endl; } std :: cout << "u3: " << (u3 ? "not null" : "null" ) << '\n' ; if (u3 != nullptr ) { std :: cout << "*u3: " << *u3 << std ::endl; } std :: cout << "u4: " << (u4 ? "not null" : "null" ) << '\n' ; if (u4 != nullptr ) { std :: cout << "*u4: " << *u4 << std ::endl; } std :: cout << "u5: " << (u5 ? "not null" : "null" ) << '\n' ; if (u5 != nullptr ) { std :: cout << "*u5: " << *u5 << std ::endl; } std :: cout << "u8: " << (u8 ? "not null" : "null" ) << '\n' ; if (u8 != nullptr ) { std :: cout << "*u8: " << *u8 << std ::endl; } return 0 ; } 输出如下： u1: null u2: null u3: not null *u3: - 842150451 u4: not null *u4: - 842150451 u5: not null *u5: - 842150451 u8: not null *u8: - 842150451 分析可以看出构造函数1 2两个构造方法等价，就是nullptr, 而其他的都是垃圾值。 构造函数3 也许是我们最熟悉的 形如 int* p = new int; 这里的构造函数4 5都用到了一个std::default_delete，这个是什么鬼？ std::default_delete is the default destruction policy used by std::unique_ptr when no deleter is specified. 1) The non-specialized default_delete uses delete to deallocate memory for a single object. 2) A partial specialization for array types that uses delete[] is also provided. 构造函数8 就是从其他智能指针进行构造unique_ptr. 接下来就剩下构造方法6和7个，都使用了std::move语义，我们加上，进行演示： #include <iostream> #include <memory> int main() { std ::default_delete< int > d; std ::unique_ptr< int > u1; std ::unique_ptr< int > u2( nullptr ); std ::unique_ptr< int > u3( new int ); std ::unique_ptr< int > u4( new int , d); std ::unique_ptr< int > u5( new int , std ::default_delete< int >()); std ::unique_ptr< int > u8( std :: auto_ptr < int >( new int )); std :: cout << "u1: " << (u1 ? "not null" : "null" ) << '\n' ; if (u1 != nullptr ) { std :: cout << "*u1: " << *u1 << std ::endl; } std :: cout << "u2: " << (u2 ? "not null" : "null" ) << '\n' ; if (u2 != nullptr ) { std :: cout << "*u2: " << *u2 << std ::endl; } std :: cout << "u3: " << (u3 ? "not null" : "null" ) << '\n' ; if (u3 != nullptr ) { std :: cout << "*u3: " << *u3 << std ::endl; } std :: cout << "u4: " << (u4 ? "not null" : "null" ) << '\n' ; if (u4 != nullptr ) { std :: cout << "*u4: " << *u4 << std ::endl; } std :: cout << "u5: " << (u5 ? "not null" : "null" ) << '\n' ; if (u5 != nullptr ) { std :: cout << "*u5: " << *u5 << std ::endl; } std :: cout << "u8: " << (u8 ? "not null" : "null" ) << '\n' ; if (u8 != nullptr ) { std :: cout << "*u8: " << *u8 << std ::endl; } std ::unique_ptr< int > u6( std ::move(u5)); std :: cout << "u6: " << (u6 ? "not null" : "null" ) << '\n' ; if (u6 != nullptr ) { std :: cout << "*u6: " << *u6 << std ::endl; } std :: cout << "now, let us see u5:" ; std :: cout << "u5: " << (u5 ? "not null" : "null" ) << '\n' ; if (u5 != nullptr ) { std :: cout << "*u5: " << *u5 << std ::endl; } std ::unique_ptr< int > u7( std ::move(u6)); std :: cout << "u7: " << (u7 ? "not null" : "null" ) << '\n' ; if (u7 != nullptr ) { std :: cout << "*u7: " << *u7 << std ::endl; } std :: cout << "now, let us see u6:" ; std :: cout << "u6: " << (u6 ? "not null" : "null" ) << '\n' ; if (u6 != nullptr ) { std :: cout << "*u6: " << *u6 << std ::endl; } return 0 ; } //输出： // u1 : null // u2 : null // u3 : not null // *u3 : -842150451 // u4 : not null // *u4 : -842150451 // u5 : not null // *u5 : -842150451 // u8 : not null // *u8 : -842150451 // u6 : not null // *u6 : -842150451 // now, let us see u5 : u5 : null // u7 : not null // *u7 : -842150451 // now, let us see u6 : u6 : null 这里最最想说明的就是： u5原来不是null，但是std::move后，u5就变为了空， u6最开始也不为空，std::move后，u6也变为了空。 还需要强调的一点，就是在对指针进行解除引用的时候，一定要验证指针是否为空，如果指针为空，再进行取值操作，程序就会崩溃。严重的bug。 如果我写到现在就停下来，你又会说我是标题党，但是我不是。 继续： std::make_unique没有纳入C++11，是C++14的内容： 构造函数有三个： template< class T, class… Args > unique_ptr make_unique( Args&&… args ); template< class T > unique_ptr make_unique( std::size_t size ); template< class T, class… Args > /* unspecified */ make_unique( Args&&… args ) = delete; #include <iostream> #include <memory> struct Vec3 { int x, y, z; Vec3() : x( 0 ), y( 0 ), z( 0 ) { } Vec3( int x, int y, int z) :x(x), y(y), z(z) { } friend std ::ostream& operator <<( std ::ostream& os, Vec3& v) { return os << '{' << "x:" << v.x << " y:" << v.y << " z:" << v.z << '}' ; } }; int main() { // Use the default constructor. std ::unique_ptr<Vec3> v1 = std ::make_unique<Vec3>(); // Use the constructor that matches these arguments std ::unique_ptr<Vec3> v2 = std ::make_unique<Vec3>( 0 , 1 , 2 ); // Create a unique_ptr to an array of 5 elements std ::unique_ptr<Vec3[]> v3 = std ::make_unique<Vec3[]>( 5 ); std :: cout << "make_unique<Vec3>(): " << *v1 << '\n' << "make_unique<Vec3>(0,1,2): " << *v2 << '\n' << "make_unique<Vec3[]>(5): " << '\n' ; for ( int i = 0 ; i < 5 ; i++) { std :: cout << " " << v3[i] << '\n' ; } } //输出： //make_unique<Vec3>() : {x:0 y : 0 z : 0} //make_unique<Vec3>(0, 1, 2) : {x:0 y : 1 z : 2} //make_unique<Vec3[]>(5) : //{x:0 y : 0 z : 0} //{x:0 y : 0 z : 0} //{x:0 y : 0 z : 0} //{x:0 y : 0 z : 0} //{x:0 y : 0 z : 0} 正如你看到的，make_unique完美的传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器 同直接使用new相比，make函数减小了代码重复，提高的异常安全，并且对于std::make_shared和std::allcoated_shared，生成的代码会更小更快。 此时，可以参考博客 http://blog.csdn.net/coolmeme/article/details/43405155 上一篇 实战c++中的智能指针unique_ptr系列-- 使用std::unique_ptr代替new operator(错误：‘unique_ptr’ is not a member of ‘std’) 顶 0 踩 0 我的同类文章 C++ （147） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 个人资料 wangshubo1989 访问： 127084次 积分： 3664 等级： 积分：3664 排名： 第4994名 原创： 212篇 转载： 14篇 译文： 6篇 评论： 153条 文章搜索 博客专栏 实战c++中的vector系列 文章：22篇 阅读：14137 实战c++中的string系列 文章：15篇 阅读：14121 一起学libcef 文章：5篇 阅读：4637 那些年躲过的坑儿 文章：33篇 阅读：37229 浅析C++11新特性 文章：19篇 阅读：12645 C++你所不知道的事儿 文章：4篇 阅读：4206 文章分类 WPF (20) MFC (17) C++ (147) C# (36) DuiLib (4) windows编程 (11) 非技术 (8) libcef (5) 文章存档 2015年12月 (49) 2015年11月 (49) 2015年10月 (36) 2015年09月 (26) 2015年08月 (45) 2015年07月 (22) 2015年06月 (5) 阅读排行 没有躲过的坑--正则表达式截取字符串 (14349) 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (2485) C\C++编译器的未来.我们还需要C++么? (2168) 浅析C++中的初始化列表（区别赋值和初始化） (1749) 你所不知道的事儿--C++中delete指针后最好赋值为NULL (1529) C++11新特性之 std::array container (1512) 没有躲过的坑--std::string初始化、最快速判断字符串为空 (1466) 没有躲过的坑--指针（内存泄露） (1382) 没有躲过的坑--头文件相互包含（Compiler error C2653: not a class or namespace name） (1266) MVVM设计模式基础知识--NotificationObject类（Prism框架） (1265) 评论排行 为何我工作十年，内心仍无比恐慌（腾讯产品总监曹菲） (9) C++11新特性之 CALLBACKS (5) 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） (4) 没有躲过的坑--智能指针陷阱 (4) C++11新特性之 default and delete specifiers (4) C++11新特性之 std::future and std::async (4) 开始使用C++11的几个理由 (4) C++11新特性之 std::array container (3) 微软VS苹果 桌面操作系统的终极一战 (3) 没有躲过的坑--指针（内存泄露） (3) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 最新评论 C\C++编译器的未来.我们还需要C++么? cosmart : Delphi可以做到跨平台了吧 实战c++中的vector系列--使用sort算法对vector进行排序(对vector<string>排序、使用稳定的排序std::stable_sort()) u010850027 : 没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。 实战c++中的vector系列--vector应用之STL的find、find_if、find_end、find_first_of、find_if_not(C++11) u010850027 : 感谢楼主的分享，学习了`(*∩_∩*)′ 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : @wangshubo1989:好像找到原因了，我用的是64位的cef源码，博主的是32位吧，我换回3... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） wangshubo1989 : @sinat_27399773:留邮箱 把我的win32的libcef项目发给你 vs2015的 我... 一起学libcef--搭建自己的libcef运行环境（Win32程序，错误C2220解决方案） sinat_27399773 : 我按你的步骤发现源文件的includ头都报错，然后修改路径后下面的代码还是有错，找不到错误的地方，有... 实战c++中的vector系列--vector<unique_ptr<>>赋值给vector<unique_ptr<>> chenyd9027 : 学习了 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） wangshubo1989 : @zouzhipeng1717:每一次erase()，删除元素后面的元素依次向前移动一个位置，所以这... 实战c++中的vector系列--可怕的迭代器失效（vector重新申请内存） wangyaninglm : 受益匪浅，学习了，这个之前用vector 的迭代器时候确实很少注意到 实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素） zouzhipeng1717 : 在擦除容器的时候，并不会改变vector的容量，那么自然就不会造成容器的重新加载，那么，为何迭代器会...

Recno:: 72
URL:: http://blog.csdn.net/zhouzhaoxiong1227/article/details/50403299

ParseText::
Linux中在主机上实现对备机上目录及文件的操作的C代码实现 - 周兆熊的专栏 - 博客频道 - CSDN.NET 周兆熊的专栏 目录视图 摘要视图 订阅 学院APP首次下载，可得50C币！     欢迎来帮助开源“进步”     当讲师？爱学习？投票攒课吧     认识Atlassian Datacenter产品     深圳小伙伴的福利来啦 Linux中在主机上实现对备机上目录及文件的操作的C代码实现 2015-12-25 15:06 89人阅读 评论 (0) 收藏 举报 分类： 编程 （40） 作者同类文章 X 版权声明：本文为博主原创文章，未经博主允许不得转载。 需求描述 编写程序，完成在主机上实现对备机上目录及文件的操作。例如，主机为A，备机为B，要求编写的程序运行在A机上，该程序实现在B机上创建文件目录及拷贝文件的操作。 需求分析 我们先不考虑用程序实现需求，如果是让我们用手工实现需求中描述的操作，我们会怎么做呢？大家也许都会想到使用telnet的方式。也就是说，在A机上使用telnet远程到B机上去，然后在B机上执行创建目录和拷贝文件的操作。 我们也可以在程序中使用telnet来完成上述需求。 程序编写 我们可以使用两种方式来执行telnet命令，一种是直接使用系统提供的system函数，另一种是使用管道的方式。以下是这两种方式编写出来的程序： 1.使用system函数 / ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** * 版权所有 (C)2015, Zhou Zhaoxiong。 * * 文件名称：System.c * 文件标识：无 * 内容摘要：测试system的用法 * 其它说明：利用system实现远程操作 * 当前版本：V1.0 * 作 者：Zhou Zhaoxiong * 完成日期：20151225 * ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** / #include <stdio.h> #include <string.h> // 重定义数据类型 typedef unsigned char UINT8; typedef signed int INT32; // 函数声明 void DealRemoteFile(void); / ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** * 功能描述：主函数 * 输入参数：无 * 输出参数：无 * 返 回 值：无 * 其它说明：无 * 修改日期 版本号 修改人 修改内容 * --------------------------------------------------------------- * 20151225 V1.0 Zhou Zhaoxiong 创建 ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */ INT32 main() { DealRemoteFile(); return 0; } / ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** * 功能描述：处理远端的文件 * 输入参数：无 * 输出参数：无 * 返 回 值：无 * 其它说明：无 * 修改日期 版本号 修改人 修改内容 * --------------------------------------------------------------- * 20151225 V1.0 Zhou Zhaoxiong 创建 ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */ void DealRemoteFile(void) { UINT8 szCmdBuf[1024] = {0}; UINT8 szResultBuf[1024] = {0}; snprintf(szCmdBuf, sizeof(szCmdBuf)-1, "(sleep 0.5; echo zhou; sleep 1; echo zhou; sleep 5; echo \"cd /home/zhou/zhouzx/Test;mkdir -p TestFile;cp TestFile.txt ./TestFile;\"; sleep 2) | telnet 10.10.10.10"); printf("DealRemoteFile: Cmd is %s\n", szCmdBuf); system(szCmdBuf); } 2.使用管道的方式 / ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** * 版权所有 (C)2015, Zhou Zhaoxiong。 * * 文件名称：PipeOpenAndClose.c * 文件标识：无 * 内容摘要：测试popen和pclose的用法 * 其它说明：利用popen和pclose处理远端的文件 * 当前版本：V1.0 * 作 者：Zhou Zhaoxiong * 完成日期：20151225 * ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** / #include <stdio.h> #include <string.h> // 重定义数据类型 typedef unsigned char UINT8; typedef signed int INT32; // 函数声明 void DealRemoteFile(void); / ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** * 功能描述：主函数 * 输入参数：无 * 输出参数：无 * 返 回 值：无 * 其它说明：无 * 修改日期 版本号 修改人 修改内容 * --------------------------------------------------------------- * 20151225 V1.0 Zhou Zhaoxiong 创建 ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */ INT32 main() { DealRemoteFile(); return 0; } / ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** * 功能描述：处理远端的文件 * 输入参数：无 * 输出参数：无 * 返 回 值：无 * 其它说明：无 * 修改日期 版本号 修改人 修改内容 * --------------------------------------------------------------- * 20151225 V1.0 Zhou Zhaoxiong 创建 ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */ void DealRemoteFile(void) { UINT8 szCmdBuf[1024] = {0}; UINT8 szResultBuf[1024] = {0}; FILE *fpPipe = NULL; snprintf(szCmdBuf, sizeof(szCmdBuf)-1, "(sleep 0.5; echo zhou; sleep 1; echo zhou; sleep 5; echo \"cd /home/zhou/zhouzx/Test;mkdir -p TestFile;cp TestFile.txt ./TestFile;\"; sleep 2) | telnet 10.10.10.10"); printf("DealRemoteFile: Cmd is %s\n", szCmdBuf); fpPipe = popen(szCmdBuf, "r"); if (NULL == fpPipe) { printf("DealRemoteFile: fpPipe is NULL!\n"); return; } while (fgets(szResultBuf, sizeof(szResultBuf), fpPipe) != NULL) { if ('\n' == szResultBuf[strlen(szResultBuf)-1]) // 将换行符去掉 { szResultBuf[strlen(szResultBuf)-1] = '\0'; } printf("DealRemoteFile: ResultBuf is %s\n", szResultBuf); } pclose(fpPipe); // 关闭管道 fpPipe = NULL; } 程序编译及运行 将System.c和PipeOpenAndClose.c文件上传到A机上，分别使用“gcc -g -o System System.c”和“gcc -g -o PipeOpenAndClose PipeOpenAndClose.c”命令对这两个文件进行编译，再分别运行“System”和“PipeOpenAndClose”命令，即可在B机上观察到相关操作已执行成功。 程序说明 1.以上两个程序中的szCmdBuf中的命令是程序的核心，其模式是“shell命令 | telnet x.x.x.x”，其中“x.x.x.x”是B机的IP，shell命令中的“sleep”让程序休眠，第一个echo后面的变量是用户名，第二个echo后面的变量是密码，第三个echo便执行具体的创建目录和拷贝文件的操作。 2.popen和pclose配合来实现相关shell命令的执行。popen函数通过创建一个管道，调用fork产生一个子进程，这个进程必须由pclose函数来关闭。 上一篇 展示C代码覆盖率的gcovr工具简介及相关命令使用示例 顶 2 踩 0 我的同类文章 编程 （40） http://blog.csdn.net 猜你在找 查看评论 * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场 我的微信 与本人单独交流~~ 个人资料 zhouzxi 访问： 574055次 积分： 12297 等级： 积分：12297 排名： 第552名 原创： 359篇 转载： 7篇 译文： 8篇 评论： 1204条 《C程序员从校园到职场》 京东    china-pub    亚马逊    当当网 试读章节    豆瓣 《信息通信技术百科全书》 京东商城    china-pub 博客专栏 一个程序员的成长史 文章：5篇 阅读：3991 IT读者问答 文章：30篇 阅读：31888 软件项目实践中的C语言一瞥 文章：41篇 阅读：62912 我的微博 友情链接 周兆熊的独立博客 周兆熊的微博 周兆熊的GitHub 文章搜索 文章分类 编程 (41) 操作系统 (14) 杂谈 (114) 电子技术 (1) 算法 (4) 行业预测 (5) 设计模式 (5) 软件工程 (3) 计算机网络 (12) 软件项目实践中的C语言一瞥 (55) 经典书籍读后感 (26) 软件研发项目工作总结 (35) 答读者问 (32) 软件项目实践中的SQL语言一瞥 (23) 一个程序员的成长史 (5) 文章存档 2015年12月 (8) 2015年11月 (7) 2015年10月 (2) 2015年09月 (7) 2015年08月 (3) 2015年07月 (14) 2015年06月 (15) 2015年05月 (14) 2015年04月 (12) 2015年03月 (16) 2015年02月 (1) 2014年11月 (5) 2014年10月 (13) 2014年09月 (11) 2014年08月 (17) 2014年07月 (19) 2014年06月 (14) 2014年05月 (14) 2014年04月 (13) 2014年03月 (11) 2014年02月 (2) 2014年01月 (3) 2013年12月 (2) 2013年11月 (1) 2013年10月 (2) 2013年05月 (1) 2013年04月 (2) 2013年03月 (5) 2013年02月 (1) 2013年01月 (5) 2012年12月 (2) 2012年11月 (1) 2012年10月 (3) 2012年09月 (2) 2012年08月 (4) 2012年07月 (5) 2012年06月 (2) 2012年05月 (8) 2012年04月 (18) 2012年03月 (16) 2012年02月 (17) 2012年01月 (7) 2011年12月 (9) 2011年11月 (15) 2011年10月 (25) 阅读排行 《C程序员从校园到职场》带领大家从校园走向职场 (10839) 再见，南邮！别了，南京！ (8062) 读《桥—巴拉克•奥巴马的人生及其崛起》有感 (7395) 学习习惯浅谈(二) (7294) 两年开发工作总结及未来展望 (7120) 软件开发模式 (5909) 我在南邮的三年—保研生涯 (5666) 蚂蚁与蚱蜢(The Ant and the Grasshopper) (5311) 我在南邮的三年—研二生活 (4728) 我在南邮的三年—研三生活 (4471) 推荐文章 *App竞品技术分析 （6）热修复 *架构设计：系统间通信（17）——服务治理与Dubbo 中篇（分析） *一款炫酷Loading动画--加载失败 *图解堆算法、链表、栈与队列（多图预警） *Android中ContentProvider组件详解 *Android平台Camera实时滤镜实现方法探讨(九)--磨皮算法探讨(一) 评论排行 两年开发工作总结及未来展望 (68) 《C程序员从校园到职场》带领大家从校园走向职场 (52) 一个女程序员的故事 (47) 答读者问(8)：有关Java学习的相关问题 (44) 再见，南邮！别了，南京！ (33) 学习习惯浅谈(二) (32) 我与京东的那些事儿 (26) 我在南邮的三年—总结篇 (24) 写博客的那些事儿 (19) 我在南邮的三年—保研生涯 (18) 最新评论 《C程序员从校园到职场》勘误 zhouzxi : 谢谢，请多多支持！ 《C程序员从校园到职场》勘误 zjy15203167987 : 又有了一些收获，多谢分享 《黑客与画家》阅读笔记 zhouzxi : 谢谢。 《C程序员从校园到职场》勘误 ikkmme28206 : 支持一个！ 《黑客与画家》阅读笔记 ikkmme28206 : 支持一个！ 查找栈的增长方向的分析及C代码实现 u013312497 : @zhouzxi:谢谢! 查找栈的增长方向的分析及C代码实现 zhouzxi : 手动写的。 查找栈的增长方向的分析及C代码实现 u013312497 : /*************************************************... 读取配置文件的shell脚本实现 qq_33329066 : 不错，学习了 去除源文件中的重复行的程序流程及其C代码实现 zhouzxi : 这个要看数据量及数据内容，对于一般的小文件，链表已经够用了。

Recno:: 73
URL:: http://bss.csdn.net/m/topic/cuanke_vote

ParseText::
“攒课”开始投票啦，就投自己想听的课！ CSDN“攒课”活动第三期的课题征集活动已经圆满结束了！ 第三期课题征集回顾： CSDN个性化知识服务2015第三期 啥是攒课活动？ 攒课活动是CSDN社区发起的个性化知识服务活动 首先，通过面向社区用户收集技术课题；CSDN会将收集的课题进行展示，供大家投票； 而得票较高的课程，CSDN将负责招募、推荐讲师、提供会议服务，共同“攒”一场大家真正有兴趣的技术课程 在活动中，大家踊跃提出课题，现在，经过CSDN编辑筛选，总计推出五个课题供大家投票 CSDN“攒课”活动往期资料： 课程学习资料 如果您对下面的某个课程有兴趣，就一起来投票吧！ 同时我们也邀请高水平专家报名加入到课程讲师中，只要您的技术水平够高，愿意传授、分享技术经验，CSDN攒课活动将会成为您不错的展示平台。 当讲师，还有更多福利，请查看： 讲师福利！ 第三期投票 课题1：微信公众平台应用开发（开发模式） 114 票 发起者： yjc_1111 课题简介： 1、微信消息的接收与响应；2、高级接口的使用；3、网络表情的使用；4、公众平台的开发技巧。 我要投票 课题2：Nginx服务器入门 95 票 发起者： wl812peter 课题简介： 1、Nginx服务器工作原理，特点，以及优势的讲解；2、Nginx服务器环境安装及配置； 3、Nginx服务器的实例应用；4、Nginx的未来定位和目前走势。 我要投票 课题3：手机游戏服务器开发 28 票 发起者： sincala 课题简介： 1.了解手机游戏服务器的一些框架结构；2.了解一些热门手游所使用的框架；3.游戏的算法，业务逻辑；4.相关实例讲解。 我要投票 课题4：通过.NET构建大规模并发网站 22 票 发起者： jaylongli 课题简介： 想通过学习了解通过.NET构建大规模并发网站，设计高性能站点的处理方法，如何实现高性能架构，需要哪些环境条件及相关知识点介绍等。 我要投票 课题5：Python脚本应用及学习方法 65 票 发起者： jingzhengyi 课题简介： 1.Python作为脚本语言快速构建系统优势；2.Python入门的介绍，实战分享；3.如何循序渐进学习。 我要投票 我要讲课 本期已申请讲课的讲师 分享到：

Recno:: 74
URL:: http://c.csdnimg.cn/pubfooter/js/tracking.js

ParseText::


Recno:: 75
URL:: http://edu.csdn.net/app

ParseText::
CSDN学院移动客户端 分享到:

Recno:: 76
URL:: http://img.blog.csdn.net/column

ParseText::

